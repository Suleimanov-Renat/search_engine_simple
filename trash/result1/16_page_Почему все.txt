Почему все работают с ООП? Кратко о главном или «пища» для размышления
Не знаю пока, зачем и почему первым постом я выбрал именно этот. Да я прекрасно понимаю, что из этого поста я получу много отрицательных комментариев и возможно карма будет неизбежно испорчена, но будем надеяться оно того стоит.

На что хотелось бы обратить Ваше внимание, что я не хочу никого переубеждать или менять точку зрения. Этот пост, как и звучит в заголовке, просто заставит Вас задуматся. 

В этот же момент я пропишу немного материала, которая позволит исключить часть негатива, который вызывает данный пост в истинных ООП-ков.
 
Все примеры и рассуждения будут для небольших и специализированных проектов, часть ссылок будут на ресурсы, которые я делал, часть просто взята из сети. Для тех, кто перестал читать пост, так как посчитал, что я рекламист, увы уже не смогу их в этом переубедить. Для тех кто остался, я уже отошел от того что целью в жизни является зарабатывание денег, к счастью я уже добился того успеха, которого хотел, еще в 19 лет. 

Приступим к теме обсуждения. Зададим несколько вопросов, почему и зачем используется ООП. Из википедии для тех, кто не знает что это, может прочитать детально по каждому пункту. 


Абстракция
Инкапсуляция
Наследование
Полиморфизм

Пройдемся по каждому из них отдельно, и я попытаюсь опровергнуть целесообразность их использования.
Во время абстрагирования основной целью является исключить из рассмотрения незначимые характеристики объекта. Я уже более 6-ти лет программирую на PHP, и даже с данным опытом я не могу на 100% выбрать значимые и незначимые характеристики, и в процессе роботы я возвращаюсь к уже написанному, тем же самым, не могу использовать базовый принцип ООП. Из тех, кто считает себя истинным ООП-ком попытайтесь вспомнить сколько раз Вы возвращались и редактировали функцию в классе, и после редактирования которой у Вас вылетал баг или ошибка в предыдущем использовании. 

Что касается инкапсуляции, насколько сложно вывести обрабатывание данных в отдельный файл, не используя классы и функции? Это не проблема даже для новичка, поэтому обсуждение на этом прекращу. 
По поводу наследование, это вообще бред, так как вовремя любого программирования это используется. Мы делаем одни действия ради использования результата в других. Сейчас уже кто-то готов разгромить меня и мое мнения в комментариях, но перед тем как это сделать, попытайтесь вникнуть в суть наследования, которое Вы используете у себя в ООП. Просмотрите последнее использование и перечитайте то, что я написал. Суть осталась та же? 

Перейдем к полиморфизму, да с одной стороны это классно, не приходится отвлекаться на мелочи, не получаешь никакой лишней информации и не можешь использовать ее. И опять же, а какая информация лишняя? Вы, вряд ли сможете сказать с 100% уверенностью что тот или иной параметр или характеристика не будут использованы в дальнейшем. И тогда использование полиморфизма начинает требовать больше времени на применение.

И хочется немножко подвести итог по ООП:


Делает затруднительным использование не значимых характеристик
Можно сделать тоже самое, без использования ООП
Все что используется и говорится в идеологии, используется и без внедрения ООП
Внедрение ООП в код, дополнительно тратится от 12% до 75% времени


Несколько успешных примеров как достичь цели без использования ООП, что б меня не считали «пустозвоном»: 

fastchange.com.ua в ресурсе огромная масса кросс-серверной и кросс — сайтовой работы, сам по себе явлется просто оболочкой для пользователя, и генератором отчетности для владельца, применение ООП только от API Яндекса, время разработки 4,5 часа. 

watchcases.ru, magniflex.ru/shop/, xpectik.com.ua раньше стояли на системе OsCommerce, который «насквозь пропитан» ООП, теперь на системе, которую я разработал, без единого элемента ООП, скорость загрузки сайта выросла от 1200% до 3600%, первая разработка 16-17 часов, последующие до 6,5 часов.

Что ж, если Вы желаете тратить свое время для того, что б считаться ООП-ешником, выбор за Вами. 
Пост, не направлен для тех кто пишет ресурсы с более чем на 400-600кб. ручного кода.

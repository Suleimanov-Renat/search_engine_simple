записка программиста: ооп and и or философия ооп инкапсуляция наследование полиморфизм… метод член класс разграничение приватность абстракция… как часто я видеть статья на тема ооп и как часто не видеть самый ооп в этот статья не видеть настоящий живой объектно-ориентированный программирование автор владеть терминология мочь привести тысяча определение пресловутый ооп вспомнить пара классический пример с простенький наследование везде напихать утверждение что инкапсуляция — это хорошо… да инкапсуляция — это хорошо но это не быть ооп как не быть весь остальной термин не быть даже то что в ооп принять оперировать класс на самый дело слово «принято» — неправильный в ооп можно оперировать класс и удобно работать именно с класс однако существовать подход когда класс нет а ооп — есть как так почему? разве класс — не самый главный часть ооп разве он можно выбросить разве остаться ооп избавиться мы от классов? остаться ведь что есть «класс»? инструмент сложный многофункциональный инструмент а что есть «ооп»? философия философия взаимодействие философия программистский мышление философия в который есть закон и правило способ и методика инструмент и материал вы мочь выгнать музыкант из-за фортепиано — он взять флейта отобрать флейта — музыкант натянуть струна и изобразить мелодия завязать он рука и он просто стать напевать: музыка в немой самый ооп подобно музыка он можно изучать в теории: обширный партитура ооп-код гордый скрипичный абстрактный класс нота-класс в связка бемоль наследник рефрен идти перегрузка метод и ещё пара ловкий переход с размер на размер чтобы достигнуть определённый эффекта… с практика тоже весь хорошо сложить простой мелодия с помощь металлофон постучать молоточек по чужое класс выучить гитарный аккорд — и скомпоновать простой программа с стандартный решение стандартный алгоритм стандартный подход хотеть что-то нестандартное? тогда вы — в музыкальный школа в она вы научить играть на разный инструмент и правильно сочетать они вы узнать про паттерн проектирование шаблонный класс абстрагирование от алгоритм сокрытие информация и много что ещё вы вдруг понять что сочинять мелодия — тоже искусство прошлое ваш поделка показаться вы грубый аморфный безобразный и вы удивиться что ранний писать так неуклюже вон там хороший быть бы создать класс и перенести в он часть функций; здесь хороший воспользоваться стандартный решение чем придумывать свое; а вот этот неочевидный обходный манёвр решаться всего-навсего абстрактный класс и три простейшее наследниками… знайте: вы на верный путь вы уже понимать что ооп — это не нота но музыка и вы учиться гармония теперь чтобы дирижировать оркестр ооп или быть хороший композитор остаться совсем немного всего-то лишь закончить консерватория там вы не только изучать музыка — вы учиться она чувствовать дышать она думать она проблема and и or в свой работа над 04 версия orm для qt я столкнуться с интересный программистский проблема и смочь она красиво решить я захотеться поделиться мысль с кто-то ещё и я стать записывать они в вид отрывочный фраза вскоре я взяться за более содержательный предложение — так появиться этот записка программист в мой orm-библиотека qst о 03 версия который я уже писать на хабра пока нет генерация сложный запрос и это как раз то что я хотеть реализовать сейчас но где сложный запрос там и большой условный конструкция который попробовать разобрать на приоритетность весь этот вложить and и or условие да ещё если без скобка — с ум можно сойти пока придумать как это хороший сделать я понять что я прежде всего нужный класс для один маленький простой условие пусть это быть qstcondition — и ничто что длинный название на этап предварительный проектирование сойти и так сначала я расписать на бумажка какой хотеть бы видеть код на с++ если бы класс qstcondition у я уже быть для начало «запрограммируем» простой условие f1 и f2 — это поль в sql-запрос f1 = f2 f1 = 5 5 = 5 я бы хотеть создавать экземпляр класс qstcondition разнообразный способ qstcondition("f1" functorequal "f2") qstcondition("f1" functorequal qvariant(5)) qstcondition("f1 = f2") qstcondition(qvariant(5) functorequal qvariant(5)) qstcondition("f1 = " qvariant(5)) в мой библиотека есть класс qstfield — абстракция над поль в sql-понимание qstvalue — абстракция над константа класс qstcondition должный они понимать qstcondition(qstfield("f1") functorequal "f2") // здесь матрешка: в qstcondition передаваться qstfield в который передаваться qstvalue в который передаваться qvariant запись можно чуть-чуть укоротить оставить 5 вместо qvariant(5) qstcondition(qstfield("f1" qstvalue(qvariant(5) functorequal))) qstcondition(qstfield("f1") functorequal qstfield("f2")) qstcondition(qstvalue(qvariant(5)) functorequal qvariant(5)) qstcondition(qstvalue(qvariant(5) functorequal) qvariant(5)) какой же должный быть конструктор для весь этот случаев? в первое приближение получиться пять штук: (1) qstcondition(qstring field1 comparefunctor functor qstring field2) (2) qstcondition(qstring field1 comparefunctor functor qvariant value) (3) qstcondition(qvariant value1 comparefunctor functor qvariant value2) (4) qstcondition(qstring stringcondition) (5) qstcondition(qstfield qstfield1 comparefunctor functor qstfield qstfield2) я уже понимать что далее у я есть два вариант развитие где-то внутри класс qstcondition быть лежать имя полый функтор значение можно быть бы положить имя полый в два строка что-то вроде: qstcondition { qstring _fieldname1 _fieldname2; qvariant _value1 _value2; comparefunctor _functor; } что же тогда делать с пять конструктором? в qstfield есть «имя поля» — name () я мочь бы извлечь он и положить в строку: qstcondition(qstfield field1 comparefunctor functor qstfield field2) : _fieldname1(field1name()) // извлекать и класть в строка _fieldname2(field2name()) _value1(qvariant()) _value2(qvariant()) _functor(functor) {} прогнозирую: я прийтись брать вот этот самый текстовый _fieldname1 _fieldname2 и передавать они по много раз в qstfield для генерация sql не хороший ли сразу хранить имя полый в готовый класс qstfield? и логичный и семантически правильный как там по затрата на создание/хранение/копирование объект класс qstfield — уж не знать это я волновать в последний очередь особенно на этап проектирование потом я вспомнить что один из конструктор qstfield выглядеть так: qstfield(const qstring &name const fieldvisibility &visibility = fieldvisible const char *columntitle = "" const int &columnwidth = 0 const qt::orientation &titleorientation = qt::horizontal); хранить я дать весь равно в qstfield значит конструктор (1) можно исключить вместо он быть вызываться конструктор (5) даже если мы передавать просто два строка в качество имя полый оставить я конструктор (1) и компилятор бы я обругал: эй прогера у ты конструктор ambiguous! чтобы в это убедиться я от теория перейти к практике: написать класс qstcondition поместить в он весь что выше и сделать несколько тестиковый так и есть компилятор выдавать ошибка вот только не там где я ожидал: maincpp:67: error: call of overloaded 'qstcondition(const char [3] qst::comparefunctor const char [3])' is ambiguous note: candidates are: qst::qstcondition::qstcondition(qvariant qst::comparefunctor qvariant) note: qst::qstcondition::qstcondition(qstring qst::comparefunctor qvariant) note: qst::qstcondition::qstcondition(qstring qst::comparefunctor qstring) вот так-то конфликтовать конструктор (1) (2) и (3) после непродолжительный раздумье я переписать класс поменять заодно порядок параметр сейчас конструктор выглядеть так: qstcondition(qstring stringcondition); qstcondition(qstfield field1 qstfield field2 comparefunctor functor); qstcondition(qstring fieldname1 qstring fieldname2 comparefunctor functor); qstcondition(qstvalue value1 qstvalue value2 comparefunctor functor); qstcondition(qstfield field qvariant value comparefunctor functor); qstcondition(qstfield field qstvalue value); qstcondition(qstring fieldname qstvalue value comparefunctor functor); вот с простейшее случай разобраться пора переходить к монстр вспоминать про приоритет булев операция в конструкция «a and b or c» и понимать что с приоритет возиться не хотеть значит надо как-то запретить создавать такой sql-запрос скобки? да а где скобка там вложить условия: «a and (b or c)» записать на язык sql целевой условие: f1 = f2 and (f3 < 5 or f3 is null) быть бы полезный некий гипотетический класс qstand и qstor qstand(qstcondition("f1 = f2") qstor("f3 < 5" qstcondition("f3 is null")) ) конструкция монструозный но пока на стадия предварительный дизайн ничто не поделать хотя можно быть бы сделать примерно так: qstcondition("f1 = f2")and( qstcondition("f3" functorless 5)or("f3 is null")or()or() )and()and() взять на заметка это «нанизывание» а пока просить обратить внимание: and и or равноправный за исключение приоритет конечно то есть оба следующий вариант должный работать: qstand(qstcondition("f1 = f2") qstor("f3 < 5" qstcondition("f3 is null")) ) qstor(qstcondition("f1 = f2") qstand("f3 < 5" qstcondition("f3 is null")) ) и вот задача: как сделать этот два класс qstand и qstor? оба «знают» друг друг теоретически когда такой встречаться в с++ можно попробовать предопределение class b; class a { // использоваться класс b }; class b { // использоваться класс a }; этот вариант я отбросить сразу даже не уяснить получиться бы что или нет класс qstand и qstor равноправный а если подумать они — один и то же только один выдавать «and» а два «or» они должный знать друг о друг как можно маленький не должный зависеть друг от друг в иной ситуация где быть бы не два вариант (и/или) а три пять десять и более равноправный класс предопределение не подойти бы я не нравиться сам вид предопределение что-то здесь нарушается: не то логический стройность не то принцип сокрытие информация я стать думать далёкий и прийти к вывод что с помощь наследование qstand и qstor сделать быть бы элементарный задавать абстрактный класс-предок qstbool прописывать у он виртуальный метод и наследоваться два раза: class qstbool { public: qstbool(); virtual ~qstbool() = 0; virtual qstring operatorname() const; }; class qstand : public qstbool { public: qstand(); virtual qstring operatorname() const { return "and"; }; }; class qstor : public qstbool { public: qstor(); virtual qstring operatorname() const { return "or"; }; }; весь работать бы замечательный вызываться какой надо конструктор но… посмотреть ещё раз на то что хотеть получить: qstand(qstcondition("f1 = f2") qstor("f3 < 5" qstcondition("f3 is null")) ) написать конструктор: qstand(qstcondition condition1 qstor orcondition2); qstand должный получать в конструктор объект qstor про который он ничто не известно я мочь бы сделать такой стандартный для ооп финт: qstbool(qstcondition condition1 qstbool * boolcondition2); и передавать уже не объект класс qstand и qstor а указатель на этот объект весь бы работать да вот незадача: мы бы прийтись либо передавать указатель на ранее описать объект либо создавать этот объект с помощь оператор new и следить потом что он удалённый 1) qstor myor1(qstcondition("f3 < 5") qstcondition("f3 is null")); qstand(qstcondition("f1 = f2") &myor1); 2) qstand(qstcondition("f1 = f2") new qstor(qstcondition("f3 < 5") qstcondition("f3 is null")) ); ни то ни другой не соответствовать тот что я хотеть получить наследование заставлять беспокоиться о лишний вещь утяжелять и без тот немаленький код есть ли выход? на ум крутиться шаблон где-то я уже встречаться с подобный задача я стать обдумывать класс qstor qstand и qstbool как если бы они быть шаблонный при это ни qstand ни qstor не должный с себя притащить такой громоздкий вещь как доопределение шаблон то есть вариант qstand<andstrategy> и qstor<orstrategy> отпадать поскольку заставлять писать много но сам идея стратегия кажется быть хороший я написать два простой класса: class qstandoperatorstrategy { public: qstring operatorname() const { return "and"; } }; class qstoroperatorstrategy { public: qstring operatorname() const { return "or"; } }; теперь они надо воспользоваться как? ничто придумать не получаться этот qstbool я нервировать и я решить что пока забить на он написать просто класс использовать шаблон «стратегия» template <class t> class booltemplate { public: qstring operatorname() const { t t; return toperatorname(); }; }; ну допустить как теперь из это вывести qstand и qstor? сначала попробовать так: typedef booltemplate<qstandoperatorstrategy> qstand; typedef booltemplate<qstoroperatorstrategy> qstor; весь бы хорошо да вот опять не получаться запихнуть в каждый из этот класс неявный знание о друг чего-то не хватать я снова зайти в тупик решить вернуться к qstbool поэкспериментировать пусть то что я написать и не компилироваться зато оно отражать что я хочу: template <class operator> class qstbool { public: qstbool() {}; // конструктор по умолчание qstbool(const qstcondition &cond const qstand &op) {}; qstbool(const qstcondition &cond const qstor &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; }; typedef booltemplate<qstandoperatorstrategy> qstandtemplate; typedef booltemplate<qstoroperatorstrategy> qstortemplate; typedef qstbool<qstandtemplate> qstand; typedef qstbool<qstortemplate> qstor; и опять же как передавать в класс qstbool то о чем он совсем ну совсем ничто не знает? и не надо передавать! пусть он получать в каждый из конструктор самый себя — а ведь qstand и qstor — это и есть qstbool только доопределить главный что я должный быть понять: весь три класс — это один и то же qstand и qstor — два сторона один монета а qstbool — это сам монета интересно что получиться если передать в qstbool оба стратегии? добавлять два стратегия переписывать typedef'ы: template <class operator1 class operator2> class qstbool { public: qstbool() {}; qstbool(const qstcondition &cond const qstand &op) {}; qstbool(const qstcondition &cond const qstor &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; }; typedef qstbool<qstandtemplate qstortemplate> qstand; // ставить два стратегия отличаться от один typedef qstbool<qstortemplate qstandtemplate> qstor; так… я чувствовать что загадка почти пасть заменять qstand и qstor тем что у я в typedef' и получать красоту: template <class operator1 class operator2> class qstbool { public: qstbool() {}; qstbool(const qstcondition &cond const qstbool<qstandtemplate qstortemplate> &op) {}; qstbool(const qstcondition &cond const qstbool<qstortemplate qstandtemplate> &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; }; и опять: qstbool ничто не знать о класс qstandtemplate qstortemplate но ведь именно они я передавать в качество стратегий! заменять qstandtemplate на operator1 qstortemplate на operator2 в итог код выглядеть так: template <class operator1 class operator2> class qstbool { public: qstbool() {}; qstbool(const qstcondition &cond const qstbool<operator1 operator2> &op) {}; qstbool(const qstcondition &cond const qstbool<operator2 operator1> &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; }; быстро писать примерчики: qstand andcond(qstcondition("f1 = f2") qstor(qstcondition("f3 = f4") qstcondition("f3 is null"))); qstor orcond(qstcondition("f1 = f2") qstand(qstcondition("f3 = f4") qstcondition("f3 is null"))); оба работают! остаться совсем немного хотеть чтобы объект возвращать строка свой оператор добавлять в qstbool функцию: qstring operatorname() const { operator1 t; return toperatorname(); }; фокус в тот что для qstand в качество operator1 приходить qstandtemplate а для qstor — qstortemplate и каждый раз функция выдавать именно то что нужно убедиться просто выводить результат: qstand andcond2; qstor orcond2; qdebug() << andcond2operatorname(); // выводить and qdebug() << orcond2operatorname(); // выводить or замечательно! так не расслабляться привести весь код который получился: class qstandoperatorstrategy { public: qstring operatorname() const { return "and"; } }; class qstoroperatorstrategy { public: qstring operatorname() const { return "or"; } }; template <class t> class booltemplate { public: qstring operatorname() const { t t; return toperatorname(); }; }; template <class operator1 class operator2> class qstbool { public: qstbool() {}; qstbool(const qstcondition &cond const qstbool<operator1 operator2> &op) {}; qstbool(const qstcondition &cond const qstbool<operator2 operator1> &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; qstring operatorname() const { operator1 t; return toperatorname(); }; }; typedef booltemplate<qstandoperatorstrategy> qstandtemplate; typedef booltemplate<qstoroperatorstrategy> qstortemplate; typedef qstbool<qstandtemplate qstortemplate> qstand; // ставить два стратегия отличаться от один typedef qstbool<qstortemplate qstandtemplate> qstor; приглядимся: класс booltemplate qstandtemplate и qstortemplate — лишний убирать этот ненужный прослойка теперь подумать насчёт два конструкторов: qstbool(const qstcondition &cond const qstbool<operator1 operator2> &op) {}; qstbool(const qstcondition &cond const qstbool<operator2 operator1> &op) {}; из-за первое возможный конструкция вид qstand(qstcondition qstand) и qstor(qstcondition qstor) они в принцип не сильно мешать если нужно построить такой sql-код: f1 and (f2 and f3) только особый смысл я в это не видеть убирать один конструктор — запрещать внутри класс qstand использовать он же то же самый для qstor template <class operator1 class operator2> class qstbool { public: qstbool() {}; qstbool(const qstcondition &cond const qstbool<operator2 operator1> &op) {}; qstbool(const qstcondition &cond1 const qstcondition &cond2) {}; qstbool(const qstring &stringcond1 const qstring &stringcond2) {}; qstring operatorname() const { operator1 op1; return op1operatorname(); }; }; typedef qstbool<qstandoperatorstrategy qstoroperatorstrategy> qstand; typedef qstbool<qstoroperatorstrategy qstandoperatorstrategy> qstor; итак главный задача решить — и решить красиво на последок привести ещё один выкрутас вспомнить что чуть ранее я рассуждать что можно быть бы организовать «нанизывание»: qstcondition("f1 = f2")and( qstcondition("f3" functorless 5)or("f3 is null")or()or() )and()and() для класс qstand и qstor этот функция быть бы полезный только я должный помнить что если нанизываться and' or уже недопустимый и наоборот как такой сделать? элементарный добавлять в класс-стратегия по один функция отвечать за свой операция прийтись функция написать больший буква потому что на функция «and()» компилятор ругаться class qstandoperatorstrategy { public: qstandoperatorstrategy and(const qstcondition &condition) { // код return *this; }; qstring operatorname() const { return "and"; } }; class qstoroperatorstrategy { public: qstoroperatorstrategy or(const qstcondition &condition) { // код return *this; }; qstring 
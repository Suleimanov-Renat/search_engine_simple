забытый история ооп большинство парадигма программирование который мы использовать сегодня быть впервые математически изучить в 1930-ха год с использование идея лямбда-исчисление и машина тьюринг который представлять себя вариант модель универсальный вычисление (этый формализованный система который мочь выполнять вычисление общий назначения) тезис чёрч-тьюринг показать что лямбда-исчисление и машина тьюринг функционально эквивалентный а именно речь идти о тот что весь что можно вычислить с использование машина тьюринг можно вычислить и с использование лямбда-исчисление и наоборот есть распространить заблуждение в соответствие с который машина тьюринг мочь вычислить весь поддаваться вычисление существовать класс проблема (например — проблема остановки) который мочь быть вычислимый с использование машина тьюринг лишь для некоторый случай когда в это текст использоваться слово «вычислимо» иметься в вид «вычислимый машина тьюринга» лямбда-исчисление демонстрировать подход применение функция к вычисление по принцип «сверху вниз» а ленточный машина тьюринг представлять императивный (пошаговый) подход к вычисление реализовать по принцип «снизу вверх» низкоуровневый язык программирование вроде машинный код или ассемблер появиться в 1940-е а к конец 1950-ха возникнуть один популярный высокоуровневый язык который реализовать и функциональный и императивный подход так диалект язык lisp до сей пора широко использоваться среди они можно отметить clojure scheme autolisp и так далее в пятьдесят появиться и такой язык как fortran и cobol они являться пример императивный высокоуровневый язык который весь ещё живой хотя надо отметить что язык семейство c в большинство сфера заменить и cobol и fortran корень императивный и функциональный программирование лежать в формальный математика вычисление они появиться ранний цифровой компьютер объектно-ориентированный программирование или ооп (object oriented programming oop) пришлый поздний оно брать начать в революция структурный программирование который происходить в шестьдесят-семьдесят год прошлое век один известный я объект быть использовать айвено сазерленд в он судьбоносный приложение sketchpad создать между 1961 и 1962 описать имя в этот работа в 1963 год объект представлять себя графический знак выводить на экран осциллограф (возможный это — один в история случай использование графический компьютерный монитора) и поддерживать наследование через динамический делегат который айвено сазерленд назвать в свой работа «мастер-объектами» (masters) люба объект мочь стать мастер-объект дополнительный экземпляр объект быть назвать «реализациями» (occurrences) это сделать система sketchpad обладатель один из известный язык программирование который реализовать прототипный наследование один язык программирование широко известный как «объектно-ориентированный» быть язык simula спецификация который быть разработать в 1965 год как и sketchpad silmula предусматривать работа с объект но также включать в себя класс наследование основать на класс подкласс и виртуальный метод виртуальный метод называться метод определённый в класс который предназначить для тот чтобы подкласс он переопределять виртуальный метод позволять программа вызывать метод который мочь не существовать на момент компиляция код благодаря задействование динамический диспетчеризация для определение тот какой конкретный метод нужно вызывать в время выполнение программа javascript иметь динамический тип и использовать цепочка делегирование для определение тот какой метод нужно вызватьва результат этот язык не нуждаться в представление концепция виртуальный метод программист другой слово весь метод в javascript использовать диспетчеризация в время выполнение программа в результат метод в javascript не нужно объявлять как «виртуальные» для обеспечение поддержка этот возможность мнение отец ооп о ооп «я придумать термин «объектно-ориентированный» и мочь сказать что я не иметь в вид с++» алан кэй конференция oopsla 1997 алан кэй придумать термин «объектно-ориентировать программирование» иметь в вид язык программирование smalltalk (1972) этот язык разработать алан кэй дэн инглзти и другой сотрудник научно-исследовательский центр xerox parc в рамка проект по создание устройство dynabook язык smalltalk быть более объектно-ориентированный чем simula в smalltalk весь являться объект включая класс целое число и блок (замыкания) первоначальный реализация язык smalltalk-72 не иметь возможность создание подкласс этот возможность появиться в smalltalk-76 в то время как smalltalk поддерживать класс и в итог создание подкласс в smalltalk этот идея не ставиться в глава угол это быть функциональный язык на который lisp повлиять так же сильно как simula по мнение алан кэя отношение к класс как к механизм повторный использование код — это ошибка индустрия программирование уделять огромный внимание создание подкласс отвлекаться от настоящий преимущество объектно-ориентированный программирование у javascript и smalltalk много общий я сказать бы что javascript — это месть smalltalk мир за неправильный понимать концепция ооп оба этот язык поддерживать следующий возможности: объект функция первое класс и замыкание динамический тип поздний связывание (функция и метод можно заменять в время выполнение программы) ооп без система наследование основать на класс «я сожалеть о тот что давным-давно придумать термин «объекты» для это явление так как он использование приводить к тот что многие человек уделять основный значение идея который не так важный как основный основный идея — это обмен сообщениями» алан кэй в переписка по электронный почта 2003-год алан кэй уточнить то что он иметь в вид когда называть smalltalk «объектно-ориентировать языком» «ооп для я означать лишь обмен сообщение локальный сохранение и защита и скрытие состояние и крайне поздний связывание» алан кэй другой слово в соответствие с идея алан кэя самый важный ингредиент ооп являться следующие: передача сообщение инкапсуляция динамический связывание важный отметить что алан кэй человек который изобрести термин «ооп» и принести он в масса не считать важный составной часть ооп наследование и полиморфизм сущность ооп комбинация передача сообщение и инкапсуляция служить несколько важный целям: уход от разделять мутабельный состояние объект благодаря инкапсуляция состояние и изоляция другой объект от локальный изменение он состояние единственный способ повлиять на состояние другой объект заключаться в тот чтобы попросить он (а не отдать он команду) о изменение отправить он сообщение изменение состояние контролироваться на локальный клеточный уровень состояние не делаться доступный другой объект отделение объект друг от друг отправитель сообщение слабо связать с получатель посредством api для работа с сообщение адаптируемость и устойчивость к изменение в время выполнение программа посредством поздний связывание адаптация к изменение в время выполнение программа давать множество значительный преимущество который алан кэй считать очень важный для ооп источник вдохновение алан кэя высказать этот идея стать он познание в биология и то что он быть известно о arpanet (этый — ранний версия интернета) а именно речь идти о биологический клетка и о отдельный компьютер подключить к сеть даже тогда алан кэй представлять себя как программа выполняться на огромный распределить компьютер (интернет) в то время как индивидуальный компьютер действовать как биологический клетка независимо работать с свой собственный изолировать состояние и обмениваться дать с другой компьютер путём отправка сообщение «я понять что метафора клетка или компьютер помочь избавиться от данных[]» алан кэй говорить «помочь избавиться от данных» алан кэй конечно знать о проблема вызвать разделять мутабельный состояние и о сильный связанность причина который являться общий доступ к данные сегодня этот тема у весь на слух но в конец 1960-ха программист arpanet быть недовольный необходимость выбирать представление модель дать для свой программа до начало разработка программа разработчик хотеть уйти от этот практика так как заранее загонять себя в рамка определять представление дать сложный изменить что-то в будущее проблема заключаться в тот что разный способ представление дать требовать для доступ к он разный код и разный синтаксис в использовать в некий момент время язык программирование святой граалем здесь быть бы универсальный способ для доступ к данные и для управление они если весь дать выглядеть бы для программа одинаково это решить бы множество проблема разработчик касаться развитие и сопровождение программа алан кэй пытаться «избавиться» от идея в соответствие с который дать и программа быть в какой-то смысл самостоятельный сущность они не рассматриваться таковой в list или в smalltalk тут нет разделение между тем что можно делать с дать (со значение переменный структура дать и так далее) и программный конструкция вроде функция функция — это «гражданин первое класса» а программа разрешить меняться в время они выполнение другой слово в smalltalk к данные нет особый привилегированный отношение алан кэй кроме тот рассматривать объект как алгебраический структура что давать определённый математически доказуемый гарантия они поведение «моё математический образование позволить я понять что каждый объект мочь иметь несколько алгебраический модель связанный с он что мочь быть целое группа подобный модель и что они мочь быть очень и очень полезными» алан кэй быть доказать что так оно и есть и это сформировать база для объект такой как промиса и линза причём и на то и на другой оказать влияние теория категория алгебраический природа тот как алан кэй видеть объект позволить бы объект обеспечить формальный верификация детерминистический поведение улучшить бы тестируемость так как алгебраический модель — это в сущность операция который подчиняться несколько правило в форма уравнение на жаргон программист «алгебраический модели» — это абстракция создать из функция (операций) который сопутствовать определённый правило приводить в жизнь модульный тест который этот функция должный пройти (аксиома уравнения) этот идея быть на десятилетие забытый в большинство объектно-ориентированный язык семейство c включая c++ java c# и так далее но этот идея начинать поиск обратный путь в свежий версия наиболее широко использовать объектно-ориентированный язык по это повод кто-то мочь сказать что мир программирование открывать заново преимущество функциональный программирование и привести рациональный довод в контекст объектно-ориентированный язык как javascript и smalltalk ранее большинство современный объектно-ориентированный язык становиться весь более и более «мультипарадигменными» нет причина выбирать между функциональный программирование и ооп когда мы смотреть на исторический сущность каждый из этот подход они выглядеть не только как совместимый но и как дополнять друг друг идея что в соответствие с мысль алан кэя являться самый главное в ооп? инкапсуляция передача сообщение динамический привязка (возможность программа развиваться и адаптироваться к изменение в время они выполнения) что в ооп несущественно? класс наследование основать на класс особый отношение к объект функция или данные ключевой слово new полиморфизм статический типизация отношение к класс как к «типам» если вы знаете java или c# вы мочь подумать что статический типизация или полиморфизм — это важный ингредиент ооп но алан кэй предпочитать иметь дело с универсальный шаблон поведение в алгебраический форма вот пример написать на haskell: fmap :: (a -> b) -> f a -> f b это — сигнатура универсальный функтор map который работать с неопределённый тип a и b применять функция от a к b в контекст функтор a для тот чтобы создать функтор b «функтор» — это слово из математический жаргон смысл который сводиться к «поддержка операция отображения» если вы знакомый с метод []map() в javascript то вы уже знаете о тот что это значит вот пара пример на javascript: // iseven = number => boolean const iseven = n => n % 2 === 0; const nums = [1 2 3 4 5 6]; // метод map принимать функция `a => b` и массив значение `a` (череза `this`) // он возвращать массив значение `b` // в дать случай значения`a` иметь тип `number` а значение `b` тип `boolean` const results = numsmap(iseven); consolelog(results); // [false true false true false true] метод map() являться универсальный в тот смысл что a и b мочь иметь люба тип и этот метод без проблема справляться с подобный ситуация так как массив — это структура дать который реализовать алгебраический закон функтор тип для map() не иметь значение так как этот метод не пытаться работать с соответствующий значение напрямую вместо это он использовать функция который ожидать и возвращать значение соответствующий тип корректный с точка зрение приложение // matches = a => boolean // здесь `a` мочь быть любой тип поддерживать сравнение const matches = control => input => input === control; const strings = ['foo' 'bar' 'baz']; const results = stringsmap(matches('bar')); consolelog(results); // [false true false] взаимоотношение универсальный тип мочь быть сложно правильно и полно выразить в язык вроде typescript но это очень просто сделать в система тип хиндли-милнера применять в haskell поддерживать тип высокий роды (тип типов) большинство система тип предусматривать слишком сильный ограничение для тот чтобы позволить свободный выражение динамический и функциональный идея такой как композиция функция свободный композиция объект расширение объект в время выполнение программа применение комбинатор линза и так далее другой словами? статический тип часто усложнять написание по с использование метод компоновка если ваш система тип отличаться слишком больший число ограничение (как в typescript или в java) то вы для достижение тот же цель вынудить писать более сложный код чем при использование язык с более свободный подход к типизация это не значит что использование статический тип — это неудачный идея или что весь реализация статический тип характеризоваться одинаковый ограничение я например сталкиваться с гораздо меньший количество проблема работать с система тип haskell если вы — фанат статический тип и не против ограничение — желать вы семь фут под киль но если вы обнаружить что некоторый из высказать здесь идея сложно реализовать из-за тот что непросто типизировать функция получить путём композиция другой функция и составной алгебраический структура тогда винить система тип а не идея водитель нравиться удобство который давать имя рамный внедорожник но никто не жаловаться на то что они не летать для полёт нужно транспортный средство у который большой степень свобода если ограничение упрощать ваш код — это замечательно! но если ограничение принуждать вы к написание более сложный код то возможно что-то не так с этот ограничение что такой «объект»? слово «объект» с время приобрести множество побочный оттенок значение то что мы называть «объектами» в javascript — это просто составной тип дать без намёк на что-то из программирование основать на класс или на идея алан кэя о передача сообщение в javascript этот объект мочь поддерживать и часто поддерживать инкапсуляция передача сообщение разделение поведение через метод даже полиморфизм с использование подкласс (хотеть и с использование цепочка делегирование а не диспетчеризация основать на типе) алан кэй хотеть избавиться от различие между программа и её дать javascript в некоторый степень достигать этот цель помещать метод объект туда же где находиться свойство хранить дать любой свойство например можно назначить любой функция конструировать поведение объект можно динамически и менять смысловой содержание объект в время выполнение программа объект — это всего лишь составной структура дать и он не нужно ничто особенный для тот чтобы считаться объект однако программирование с использование объект не вести к тот что такой код оказываться «объектно-ориентированным» так же как использование функция не делать код «функциональным» ооп большой не являться настоящее ооп так как понятие «объект» в современный язык программирование означать гораздо маленький чем означать для алан кэя я использовать слово «компонент» вместо слово «объект» для описание правило настоящий ооп многий объект владеть и управлять напрямую некий сторонний по отношение к он код на javascript но компонента должный инкапсулировать собственный состояние и контролировать он вот что такой настоящее ооп: программирование с использование компонент (алан кэй называть они «объектами») состояние компонент должный быть инкапсулировать для коммуникация между сущность использоваться передача сообщение компонента можно добавлять изменять и заменять в время выполнение программа большинство поведение объект можно задать в универсальный вид с использование алгебраический структура дать тут нет необходимость в наследование компонента мочь повторно использовать поведение из общедоступный функция и импортировать модуль при это у они нет необходимость делать общедоступный свой дать манипулирование объект в javascript или использование наследование основать на класс не означать что некто заниматься ооп-программирование а вот использование компонент такой способ — означать но от устояться представление о термин очень сложно отвязаться поэтому возможно мы надо оставить термин «ооп» и назвать то для что использоваться вышеописанный «компоненты» «программирование ориентировать на сообщения» (message oriented programming mop)? ниже мы быть пользоваться термин «mop» говорить о программирование ориентировать на сообщение по случайность английский слово «mop» переводиться как «швабра» а они как известно использовать для наведение порядок на что похоже хороший mop? в большинство современный программа иметься некий пользовательский интерфейс (user interface ui) ответственный за взаимодействие с пользователь некий код занятый управление состояние приложение (дать пользователя) и код работать с система или отвечать за обмен дать с сеть для обеспечение работа каждый из этот система мочь понадобиться долгоживовать процесс такой как прослушиватель событие тут понадобиться и состояние приложение — для хранение чего-то вроде сведение о сетевой соединение о положение дело с элемент управление интерфейс и о самый приложение хороший mop означать что вместо тот чтобы весь подобный система иметь бы доступ к состояние друг друг и мочь бы имя напрямую управлять они взаимодействовать друг с друг через сообщение когда пользователь щёлкать по кнопка «сохранить» мочь быть диспетчеризовать сообщение "save" компонент приложение отвечать за управление состояние мочь интерпретировать это сообщение и перенаправить он к обработчик ответственный за обновление с состояние (таком как чистый функция-редьюсер) возможно после обновление состояние компонент отвечать за управление состояние диспетчеризовать сообщение "state_updated" компонент пользовательский интерфейс который в свой очередь интерпретировать состояние решить какой часть интерфейс нужно обновить и передать обновить состояние подкомпонент который ответственный за работа с конкретный элемент интерфейс между тем компонент отвечать за сетевой соединение мочь наблюдать за подключение пользователь к другой компьютер в сеть прослушивать сообщение и диспетчеризовать обновить представление состояние для сохранение он на удалённый машина подобный компонент отвечать за работа с сетевой механизм знать о тот работать соединение или нет и так далее подобный система приложение не должный знать подробность о другой он часть они должный заботиться лишь о решение собственный задача компонента система можно разбирать и собирать как конструктор они реализовать стандартизировать интерфейс а это значит что они мочь взаимодействовать друг с друг до тот пора пока общеизвестный требование к интерфейс компонент выполняться такой компонента можно заменять другой с такой же интерфейс но делать то же самый по-другому или выполнять принимать тот же сообщение нечто совершенно иной менять один компонента на другой можно даже в время выполнение программа — это её работа не нарушить компонента некий программный система даже не должный находиться на один и тот же компьютер система мочь быть децентрализованный сетевой хранилище мочь разместить дать в децентрализованный система хранение дать вроде ipfs в результат пользователь оказываться независимый от исправность некий конкретный машина который обеспечивать сохранность он дать при такой подход дать оказываться надёжно сохранить и защитить от злоумышленник ооп отчасти появиться под воздействие идея arpanet а один из цель это проект быть создание децентрализованный сеть который быть устойчивый к атака наподобие ядерный удар хороший mop-система мочь характеризоваться похожий уровень устойчивость использовать компонента который поддерживать «горячий замену» в время работа приложение она смочь продолжить функционирование в тот случай если пользователь работать с она с сотовый телефон и оказаться вне зона действие сеть из-за тот что въехать в туннель если ураган нарушить электропитание один из дата-центр в который расположить её сервер она тоже продолжить функционировать настать время чтобы мир программный обеспечение освободиться бы от неудачный эксперимент с наследование основать на класс и принять бы математический и научный принцип который стоять у исток ооп пришлый время чтобы мы разработчик создавать бы более гибкий устойчивый красивый программа использовать гармоничный сочетание mop и функциональный программирование кстати акроним «mop» уже использоваться описывать «программирование ориентировать на мониторинг» (monitoring oriented programming) но этот концепция в отличие от ооп просто тихо исчезнуть поэтому не расстраиваться если термин «mop» не выглядеть слово из жаргон программист просто привести свой ооп в порядок с помощь рассмотреть выше принцип mop 
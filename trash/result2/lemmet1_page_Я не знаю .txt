я не знать ооп я не уметь программировать на объектно-ориентированный язык не научиться после 5 год промышленный программирование на java я весь ещё не знать как создать хороший система в объектно-ориентированный стиль просто не понимать я пытаться научиться честно я изучать паттерн читать код open source проект пытаться строить в голов стройный концепция но так и не понять принцип создание качественный объектно-ориентированный программа возможно кто-то другой они понять но не я и вот несколько вещий который вызывать у я непонимание я не знать что такой ооп серьёзно я сложно сформулировать основной идея ооп в функциональный программирование один из основный идея являться отсутствие состояние в структурный — декомпозиция в модульный — разделение функционал в закончить блок в люба из этот парадигма доминировать принцип распространяться на 95% код а язык спроектировать так чтобы поощрять они использование для ооп я такой правило не знать принять считать что объектно-ориентированный программирование строиться на 4 основный принцип (когда я быть маленький они быть всего 3 но ведь тогда и дерево быть большими) этот принципы: абстракция инкапсуляция наследование полиморфизм смахивать на свод правило не так ли? значит вот оно тот самый правило который нужно следовать в 95% случаев? хмм давать посмотреть близкий абстракция абстракция — это мощный средство программирование именно то что позволять мы строить большой система и поддерживать контроль над они вряд ли мы когда-либо подойти бы хотя бы близко к сегодняшний уровень программа если бы не быть вооружённый такой инструмент однако как абстракция соотноситься с ооп? во-первых абстрагирование не являться атрибут исключительно ооп да и вообще программирование процесс создание уровень абстракция распространяться практически на весь область знание человек так мы мочь делать суждение о материал не вдаваться в подробность они молекулярный структура или говорить о предмет не упоминать материал из который они сделать или рассуждать о сложный механизм такой как компьютер турбин самолёт или человеческий тело не вспоминать отдельный деталь этот сущность во-вторых абстракция в программирование быть всегда начинать с запись ады лавлейс который принять считать один в история программист с тот пора человек бесперерывно создавать в свой программа абстракция зачастую иметь для это лишь простейшее средство так абельсон и сассман в свой небезызвестный книга описывать как создать система решение уравнение с поддержка комплексный число и даже полином иметь на вооружение только процедура и связной список так какой же дополнительный средство абстрагирование нести в себя ооп? понятие не иметь выделение код в подпрограммы? это уметь люба высокоуровневый язык объединение подпрограмма в один месте? для это достаточно модуль типизация? она быть задолго до ооп пример с система решение уравнение хорошо показывать что построение уровень абстракция не столько зависеть от средство язык сколько от способность программист инкапсуляция главный козырь инкапсуляция в сокрытие реализация клиентский код видеть только интерфейс и только на он мочь рассчитывать это развязывать рука разработчик который мочь решить изменить реализация и это действительно круто но вопрос опять же в тот причём тут ооп? весь вышеперечисленный парадигма подразумевать сокрытие реализация программировать на c вы выделять интерфейс в header-файл oberon позволять делать поль и метод локальный для модуль наконец абстракция в многий язык строиться просто посредство подпрограмма который также инкапсулировать реализация более тот объектно-ориентированный язык сам зачастую нарушать правило инкапсуляция предоставлять доступ к данные через специальный метод — getters и setters в java properties в c# и тд (в комментарий выяснить что некоторый объект в язык программирование не являться объект с точка зрение ооп: data transfer objects отвечать исключительно за перенос дать и поэтому не являться полноценный сущность ооп и следовательно для они нет необходимость сохранять инкапсуляция с другой сторона метод доступ хороший сохранять для поддержание гибкость архитектура вот так весь непросто) более тот некоторый объектно-ориентированный язык такой как python вообще не пытаться что-то скрыть а расчитывать исключительно на разумность разработчик использовать этот код наследование наследование — это один из немногий новый вещий который действительно выйти на сцена благодаря ооп нет объектно-ориентированный язык не создать новый идея — наследование вполне можно реализовать и в люба другой парадигма — однако ооп впервые вывести этот концепция на уровень самый язык очевидный и плюс наследования: когда вы почти устраивать какой-то класс вы мочь создать потомок и переопределить какой-то часть он функциональность в язык поддерживать множественный наследование такой как c++ или scala (в последний — за счёт traits) появляться ещё один вариант использование — mixins небольшой класс позволять «примешивать» функциональность к новый класс не копировать код значит вот оно — то что выделять ооп как парадигма среди других? хмм… если так то почему мы так редко использовать он в реальный коде? помнить я говорить про 95% код подчиняться правило доминировать парадигмы? я ведь не шутить в функцинальный программирование не маленький 95% код использовать неизменяемый дать и функция без side-эффект в модульный практически весь код логично расфасовать по модуль преверженец структурный программирование следовать завет дейкстра стараться разбивать весь часть программа на небольшой часть наследование использоваться гораздо реж мочь быть в 10% код мочь быть в 50% в отдельный случай (например при наследование от класс фреймворка) — в 70% но не большой потому что в большинство ситуация это просто не нужно более тот наследование опасный для хороший дизайн настолько опасный что банда четыре (казаться бы проповедник ооп) в свой книга рекомендовать при возможность заменять он на делегирование наследование в тот вид в который оно существовать в популярный ныне язык вести к хрупкий дизайн унаследоваться от один предок класс уже не мочь наследоваться от другой изменение предок так же становиться опасный существовать конечно модификатор private/protected но и они требовать неслабый экстрасенсорный способность для угадывание как класс мочь измениться и как он мочь использовать клиентский код наследование настолько опасный и неудобно что крупный фреймворка (такий как spring и ejb в java) отказываться от они переходить на другой не объектно-ориентированный средство (например метапрограммирование) последствие настолько непредсказуемый что некоторый библиотека (такий как guava) прописывать свой класс модификатор запрещать наследование а в новый язык go быть решить вообще отказаться от иерархия наследование полиморфизм пожалуй полиморфизм — это хороший что есть в объектно-ориентированный программирование благодаря полиморфизм объект тип person при вывод выглядеть как «шандоркин адам имполитович» а объект тип point — как "[8423 1261]" именно он позволять написать «mat1 * mat2» и получить произведение матрица аналогично произведение обычный число без он не получиться бы и считывать дать из входной поток не заботиться о тот приходить они из сеть файл или строка в память везде где есть интерфейс подразумеваться и полиморфизм я правда нравиться полиморфизм поэтому я даже не стать говорить о он проблема в мейнстримов язык я также промолчать про узость подход диспетчеризация только по тип и про то как это мочь бы быть сделать в большинство случай он работать как надо а это уже неплохо вопрос в другом: являться ли полиморфизм тем самый принцип отличать ооп от другой парадигм? если бы вы спросить я (а раз уж вы читать этот текст значит можно считать что спросили) я бы ответить «нет» и причина весь в тот же процент использование в код возможно интерфейс и полиморфный метод встречаться немного чаща наследование но сравнить количество строка код занимать они с количество строка написать в обычный процедурный стиль — последний всегда большой глядеть на язык поощрять такой стиль программирование я не мочь назвать они полиморфный язык с поддержка полиморфизм — да так нормальный но не полиморфный язык (впроч это мой мнение вы всегда мочь не согласиться) итак абстракция инкапсуляция наследование и полиморфизм — весь это есть в ооп но ничто из это не являться он неотъемлемый атрибут тогда что такой ооп? есть мнение что быть объектно-ориентированный программирование лежать в собственно объект (звучать вполне логично) и класс именно идея объединение код и дать а также мысль о тот что объект в программа отражать сущность реальный мир к это мнение мы ещё вернуться но для начало расставить некоторый точка над i чей ооп круче? из предыдущий часть видно что язык программирование мочь сильно отличаться по способ реализация объектно-ориентированный программирование если взять совокупность весь реализация ооп в весь язык то вероятный всего вы не найти вообще ни один общий для весь черта чтобы как-то ограничить этот зоопарк и внести ясность в рассуждение я остановиться только один группа — чисто объекто-ориентировать язык а именно java и c# термин «чисто объектно-ориентированный» в дать случай означать что язык не поддерживать другой парадигма или реализовать они через весь то же ооп python или ruby например не быть являться чистый тк вы вполне мочь написать полноценный программа на они без единый объявление класс чтобы хороший понять быть ооп в java и c# пробежаться по пример реализация этот парадигма в другой язык smalltalk в отличие от свой современный коллега этот язык иметь динамический типизация и использовать message-passing style для реализация ооп вместо вызов метод объект посылать друг друг сообщение а если получатель не мочь обработать то что пришлый он просто пересылать сообщение кто-то ещё common lisp изначально cl придерживаться такой же парадигма затем разработчик решить что писать `(send obj 'some-message)` — это слишком долго и преобразовать нотация в вызов метод — `(some-method obj)` на сегодняшний день common lisp иметь развитый система объектно-ориентированный программирование (clos) с поддержка множественный наследование мультиметод и метакласс отличительный черта являться то что ооп в cl крутиться не вокруг объект а вокруг обобщённый функция clojure clojure иметь целое 2 система объектно-ориентированный программирование — один унаследовать от java и два основать на мультиметод и более похожий на clos r этот язык для статистический анализ дать также иметь 2 система объектно-ориентированный программирование — s3 и s4 оба унаследовать от язык s (что не удивительно учитывать что r — это open source реализация коммерческий s) s4 по больший часть соотвествовать реализация ооп в современный мейнстримов язык s3 являться более легковесный вариант элементарный реализовать средство самый языка: создаваться один общий функция диспетчеризировать запрос по атрибут «class» получить объект javascript по идеология похожий на smalltalk хотя и использовать другой синтаксис вместо наследование использовать прототипирование: если искомое свойство или вызвать метод в самый объект нет то запрос передаваться объект-прототип (свойство prototype весь объект javascript) интересный являться факт что поведение весь объект класс можно поменять заменить один из метод прототип (очень красиво например выглядеть добавление метод `tobase64` для класс строки) python в целое придерживаться тот же концепция что и мейнcтримовый язык но кроме это поддерживать передача поиск атрибут другой объект как в javascript или smalltalk haskell в haskell вообще нет состояние а значит и объект в обычный понимание тем не менее своеобразный ооп там всё-таки есть: тип дать (types) мочь принадлежать один или более класс тип (type classes) например практически весь тип в haskell состоять в класс eq (отвечать за операция сравнение 2-х объектов) а весь число дополнительно в класс num (операция над числами) и ord (операция < <= >= >) в менстримов язык тип соответствовать класс (данных) а класс тип — интерфейс stateful или stateless? но вернуться к более распространить система объектно-ориентированный программирование что я никогда не мочь понять так это отношение объект с внутренний состояние до изучение ооп весь быть просто и прозрачно: есть структура хранить несколько связанный дать есть процедура (функции) они обрабатывать выгулять(собаку) снятьс(аккаунт сумма) потом прислать объект и это быть тоже ничто (хотеть читать программа стать гораздо сложный — мой собака выгуливать [кого?] а аккаунт снимать деньга [откуда?]) затем я узнать про сокрытие дать я весь ещё мочь выгулять собака но вот посмотреть состав её пища уже не мочь пища не выполнять никакой действие (наверное можно быть написать что пищасъесть(собака) но я всё-таки предпочитать чтобы мой собака есть пища а не наоборот) пища — это просто дать а я (и мой собаке) нужно быть просто получить к он доступ весь просто но в рамка парадигма влезть быть уже невозможно как в старое джинса конец 90-ха ну ладный у мы есть метод доступ к данные пойти на этот маленький самообман и притвориться что дать у мы действительно скрытый зато я теперь знать что объект — это в один очередь дать а потом уже возможно метод они обрабатывать я понять как писать программа к что нужно стремиться при проектирование не успеть я насладиться просветление как увидить в интернет слово stateless (готовый поклясться оно быть окружить сияние а над буква t и l висеть нимб) короткий изучение литература открыть чудесный мир прозрачный поток управление и простой многопоточность без необходимость отслеживать согласованность объект конечно я сразу захотеться прикоснуться к это чудесный мир однако это означать полный отказ от любой правило — теперь быть непонятно следовать ли собака самый себя выгуливать или для это нужный специальный выгулменеджер; нужный ли аккаунт или с весь работа справиться банк а если так то должный он списывать деньга статически или динамически и тд количество вариант использование возрасти экспоненциально и весь вариант в будущее мочь привести к необходимость серьёзный рефакторинг я до сей пора не знать когда объект следовать сделать stateless когда stateful а когда просто контейнер дать иногда это очевидно но чаща всего нет типизация: статический или динамическая? еща один вещь с который я не мочь определиться относительно такой язык как c# и java это являться они статически или динамически типизировать наверное большинство человек воскликнуть «что за глупость! конечно статически типизированными! тип проверяться в время компиляции!» но действительно ли весь так просто? правда ли что программист прописывать в параметр метод тип x мочь быть уверенный что в он всегда быть передаваться объект именно тип x? верно — не мочь тк в метод x можно быть передать параметр тип x или он наследник казалось бы ну и что? наследник класс x весь равно быть иметь тот же метод что и x метод метод а вот логика работа мочь оказаться совершенно другой самый распространить случай это когда дочерний класс оказываться соптимизировать под другой нужда чем x а наш метод мочь рассчитывать именно на тот оптимизация (ести вы такой сценарий кажется нереалистичный попробовать написать плагин к какой-нибудь развитый open source библиотека — либо вы потратить несколько неделя на разбор архитектура и алгоритм библиотека либо быть просто наугад вызывать метод с подходящий сигнатурой) в итог программа работать однако скорость работа падать на порядок хотя с точка зрение компилятор весь корректно показательно что scala который называть наследница java в многий место по умолчание разрешать передавать только аргумент именно указанный тип хотя это поведение и можно изменить другой проблема — это значение null который мочь быть передать практически вместо любой объект в java и вместо любой nullable объект в c# null принадлежать сразу весь тип и в то же время не принадлежать ни один null не иметь ни полый ни метод поэтому любой обращение к он (кром проверка на null) приводить к ошибка вроде бы весь к это привыкнуть но для сравнение haskell (да и тот же scala) заставлютый использовать специальный тип (maybe в haskell option в scala) для обёртка функция который в другой язык мочь бы вернуть null в итог про haskell часто говорят «скомпилировать программа на он сложно но если всё-таки получиться значит скорее всего она работать корректно» с другой сторона мейнстримовый язык очевидно не являться динамически типизировать а значит не обладать такой свойство как простота интерфейс и гибкость процедура в итог писать в стиль python или lisp также становиться невозможный какой разница как называться такой типизация если весь правило весь равно известны? разница в тот с какой сторона подходить к проектирование архитектура существовать давний спорый как строить систему: делать много тип и мало функция или мало тип и много функций? один подход активно использоваться в haskell два в lisp в современный объектно-ориентированный язык использоваться что-то средний я не хотеть сказать что это плохо — наверное у он есть свой плюс (в конец конец не стоить забывать что за java и c# стоять мультиязыковой платформы) но каждый раз приступать к новый проект я задумываться с что начать проектирование — с тип или с функционал и ещё я не знать как моделировать задача считаться что ооп позволять отображать в программа объект реальный мир однако в реальность у я есть собака (с два ухо четырмить лапа и ошейником) и счёт в банка (с менеджер клерк и обеденный перерывом) а в программа — выгулменеджер счётфабрика… ну вы понять и дело не в тот что в программа есть вспомогательный класс не отражать объект реальный мир дело в тот что поток управление изменяться выгулменеджер лишать я удовольствие от прогулка с собака а деньга я получать от бездушный банксчёт (эй где тот милый девушка у который я менять деньга на прошлый неделе?) мочь быть я сноб но я быть гораздо приятный когда дать в компьютер быть просто дать даже если описывать мой собака или счёт в банка с дать я мочь сделать то что удобно без оглядка на реальный мир я также не знать как правильно декомпозировать функционал в python или c++ если я нужный быть маленький функция для преобразование строка в число я просто писать её в конец файл в java или c# я вынужденный выносить её в отдельный класс stringutils в недо-оо-язык я мочь объявить ad hoc обёртка для возврат два значение из функция (снятой сумма и остаток на счету) в ооп язык я прийтись создать полноценный класс результаттранзакция и для новое человек на проект (ить даже я самый через неделю) этот класс быть выглядеть точно такой же важный и фундаментальный в архитектура система 150 файл и весь одинаково важный и фундаментальный — о да прозрачный архитектура прекрасный уровень абстракция я не уметь писать эффективный программа эффективный программа использовать мало память — иначе сборщик мусор быть постоянно тормозить выполнение но чтобы совершить простой операция в объектно-ориентированный язык приходиться создавать дюжина объект чтобы сделать один http запрос я нужно создать объект тип url затем объект тип httpconnection затем объект тип request… ну вы понять в процедурный программирование я бы просто вызвать несколько процедура передать имя создать на стек структура скорее всего в память быть бы создать всего один объект — для хранение результат в ооп я приходиться засорять память постоянно возможно ооп — это действительно красивый и элегантный парадигма возможно я просто недостаточно умный чтобы понять её наверное есть кто-то кто мочь создать действительно красивый программа на объектно-ориентированный язык ну что ж я оставаться только позавидовать имя 
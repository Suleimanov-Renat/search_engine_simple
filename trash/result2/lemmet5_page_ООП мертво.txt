ооп мертво да здравствовать ооп источник вдохновение этот пост возникнуть благодаря недавний публикация арас пранцкевичус о доклад предназначить для программист-джуниор в он рассказываться о тот как адаптироваться к новый ecs-архитектура арас следовать привычный схема (объяснение ниже): показывать пример ужасный ооп-код а затем демонстрировать что отличный альтернативный решение являться реляционный модель (но называть её «ecs» а не реляционной) я ни в кой случай не критиковать арас — я большой фанат он работа и хвалить он за отличный презентацию! я выбрать именно он презентация вместо сотня другой пост про ecs из интернет потому что он приложить дополнительный усилие и опубликовать git-репозиторий для изучение параллельно с презентация в он содержаться небольшой простой «игра» использовать в качество пример выбор разный архитектурный решение этот небольшой проект позволить я на конкретный материал продемонстрировать свой замечание так что спасибо арас! слайд арас выложить здесь: http://aras-pinfo/texts/files/2018academy — ecs-dodpdf а код находиться на github: https://githubcom/aras-p/dod-playground я не быть (пока?) анализировать получиться ecs-архитектура из это доклад но сосредоточиться на код «плохой ооп» (похожий на уловка «чучело») из он начало я показать как бы он выглядеть на самый дело если бы правильно исправить весь нарушение принцип ood (object-oriented design объектно-ориентированный проектирования) спойлер: устранение весь нарушение ood приводить к улучшение производительность аналогичный преобразование арас в ecs к тот же использовать маленький озу и требовать маленький строка код чем ecs-версия! tl;dr: прежде чем прийти к вывод что ооп отстой а ecs рулить сделать пауза и изучить ood (чтоба знать как правильно использовать ооп) а также разобраться в реляционный модель (чтоба знать как правильно применять ecs) я уже долгий время принимать участие в множество дискуссия про ecs на форум частично потому что не думать что этот модель заслуживать существовать в качество отдельный термин (спойлер: это просто ad-hoc-версия реляционный модели) но ещё и потому что почти каждый пост презентация или статья рекламировать паттерн ecs повторять следующий структуру: показать пример ужасный ооп-код реализация который иметь ужасный изъян из-за излишний использование наследование (а значит этот реализация нарушать многие принцип ood) показать что композиция — это хороший решение чем наследование (и не упоминать о тот что ood на самый дело давать мы тот же урок) показать что реляционный модель отлично подходить для игра (но назвать её «ecs») такой структура бесить я потому что: (a) это уловка «чучело»… сравниваться мягкий с тёплый (плохой код и хороший код)… и это нечестно даже если сделать ненамеренно и не требоваться для демонстрация тот что новый архитектура хороша; и что более важно: (b) это иметь побочный эффект — такой подход подавлять знание и непреднамеренный демотивировать читатель от знакомство с исследование проводиться в течение полвека о реляционный модель впервые начать писать в 1960-ха на протяжение 70-ха и 80-ха этот модель значительно улучшаться у новичок часто возникать вопрос тип "в какой класс нужно поместить этот данные?" и в ответ имя часто говорят нечто расплывчатый наподобие "во просто нужно набраться опыт и тогда вы просто научиться понимать нутром"… но в 70-ха этот вопрос активно изучаться и на он в общий случай быть вывести формальный ответ; это называться нормализация база дать отбрасывать уже иметься исследование и называть ecs совершенно новый и современный решение вы скрывать это знание от новичок основа объектно-ориентированный программирование быть заложить столь же давно если не ранний (этота стиль начать исследоваться в работа 1950-ха годов)! однако именно в 1990-ха год объектно-ориентированность стать модный виральна и очень быстро превратиться в доминировать парадигма программирование произойти взрыв популярность многий новый оо-язык в тот число java и (стандартизировать версии) c++ однако так как это быть связать с ажиотаж то весь нужно быть знать это громкий понятие чтобы записать в свой резюме но лишь немногий по-настоящему в он углубляться этот новое язык создать из многий особенность оо ключевой слово — class virtual extends implements — и я считать что именно поэтому в тот момент оо разделиться на два отдельный сущность жить собственный жизнь я быть называть применение этот вдохновить оо языковой особенность "ооп" а применение вдохновить оо техника создание дизайна/архитектура "ood" весь очень быстро подхватить ооп в учебный заведение есть курс оо выпекать новый ооп-программистов… однако знание ood плестись позади я считать что код использовать языковой особенность ооп но не следующий принцип проектирование ood не являться оо-код в большинство критический отзыв направить против ооп использоваться для пример выпотрошить код на самый дело не являться оо-код ооп-код иметь очень плохой репутация и в частность потому что большой часть ооп-код не следовать принцип ood а потому не являться «истинным» оо-код предпосылка как сказать выше 1990-е стать пик «мода на оо» и именно в то время «плохой ооп» вероятно быть худой всего если вы изучать ооп в то время то скорее всего узнать о «четырёх столп ооп»: абстрагирование инкапсуляция полиморфизм наследование я предпочитать называть они не четыре столп а «четырьмить инструмент ооп» это инструмент который можно использовать для решение задача однако недостаточно просто узнать как работать инструмент необходимый знать когда нужно он использовать… с сторона преподаватель безответственно обучать человек новый инструмент не говорить имя когда каждый из они стоить применять в начало 2000-ха оказываться сопротивление активный неверный использование этот инструмент свой род «два волна» ood-мышление результат это стать появление мнемоник solid предоставлять быстрый способ оценка сильный сторона архитектура надо заметить что этот мудрость на самый дело быть широко распространить в 90-ха но не получить ещё крутой акроним позволить закрепить они в качество пять базовый принципов… принцип единственный ответственность (single responsibility principle) каждый класс должный иметь только один причина изменение если у класс «a» есть два обязанность то нужно создать класс «b» и «c» для обработка каждый из они по отдельность а затем создать «a» из «b» и «c» принцип открытости/закрытость (open/closed principle) по с время изменяться (те важный он поддержка) стремиться помещать часть который скорее всего быть изменяться в реализация (implementations) (те в конкретный классы) и создавать интерфейс (interfaces) на основа тот часть который скорее всего не измениться (например абстрактный базовый классы) принцип подстановка барбара лиск (liskov substitution principle) каждый реализация интерфейс должный на 100% соответствовать требование это интерфейс тот люба алгоритм работать с интерфейс должный работать с люба реализация принцип разделение интерфейс (interface segregation principle) делать интерфейс как можно более малое чтобы каждый часть код «знала» о наименьший объём кодовый база например избегать ненужный зависимость этот совет хороший и для c++ где время компиляция становиться огромный если он не следовать принцип инверсия зависимость (dependency inversion principle) вместо два конкретный реализация обмениваться дать напрямую (и зависеть друг от друга) они обычно можно разделить формализовать они интерфейс связь в качество третье класс использовать как интерфейс между они это мочь быть абстрактный базовый класс определять вызов метод использовать между они или даже просто структура псд (pod) определять передаваемый между они дать ещё один принцип не включить в акроним solid но я уверенный что он очень важен: «предпочитать композиция наследованию» (composite reuse principle) композиция это правильный выбор по умолчание наследование стоить оставить для случай когда она абсолютно необходимый так мы получать solid-c(++) ниже я быть ссылаться на этот принцип называть они по акроним — srp ocp lsp isp dip crp… ещё несколько замечаний: в ood понятие интерфейс и реализация не возможно привязать к какой-то конкретный ключевой слово ооп в c++ мы часто создавать интерфейс с абстрактный базовый класс и виртуальный функция а затем реализация наследовать от этот базовый классов… но это только один конкретный способ воплощение принцип интерфейс в c++ мы также мочь использовать pimpl непрозрачный указатель утиный типизация typedef и тд… можно создать ood-структура а затем реализовать её на c в который вообще нет ключевой слово ооп-языка! поэтому когда я говорить о интерфейс я необязательно иметь в вид виртуальный функция — я говорить о принцип сокрытие реализация интерфейс мочь быть полиморфный но чаща всего такой не являются! полиморфизм правильно использоваться очень редко но интерфейс — фундаментальный понятие для всего по как я дать понять выше если вы создавать pod-структура который просто хранить какой-то дать для передача от один класс другой тогда этот структура использоваться как интерфейс — это формальный описание дать даже если вы просто создавать один отдельный класс с общий и частный часть то весь что находиться в общий часть являться интерфейс а весь в частный часть — реализация наследование на самый дело иметь (по крайний мере) два тип — наследование интерфейс и наследование реализация в c++ наследование интерфейс включать в себя абстрактный базовый класс с чисто виртуальный функция pimpl условный typedef в java наследование интерфейс выражаться через ключевой слово implements в c++ наследование реализация происходить каждый раз когда базовый класс содержимый что-то кроме чисто виртуальный функция в java наследование реализация выражаться с помощь ключевой слово extends в ood есть много правило наследование интерфейс но наследование реализация обычно стоить рассматривать как «код с душком»! и наконец я стоить показать несколько пример ужасный обучение ооп и тот как оно приводить к плохой код в реальный жизнь (и плохой репутация oop) когда вы учить иерархиям/наследование то возможно давать подобный задачу: допустить у вы есть приложение университет в который содержаться каталог студент и персонал можно создать базовый класс person а затем класс student и класс staff наследовать от person нет-нет-нуть здесь я вы остановить негласный подтекст принцип lsp гласить что иерархия класс и алгоритм который они обрабатывать являться симбиотический это два половина целый программа ооп — это расширение процедурный программирование и оно по-прежнему в основное связать с этот процедура если мы не знать какой тип алгоритм быть работать с students и staff (и какой алгоритм быть упростить благодаря полиморфизму) то быть полностью безответственно приступать к создание структура иерархия класс сначала вы нужно узнать алгоритм и дать когда вы обучать иерархиям/наследование то вероятно давать подобный задачу: допустить у вы есть класс фигура также у мы есть в качество подкласс квадрат и прямоугольник квадрат должный быть прямоугольник или прямоугольник квадратом? на самый дело это хороший пример для демонстрациия разница между наследование реализация и наследование интерфейс если вы использовать подход с наследование реализация то совершенно не учитывать lsp и думать с практический точка зрение о возможность многократный использование код пользоваться наследование как инструмент с этот точка зрение совершенно логично следующее: struct square { int width; }; struct rectangle : square { int height; }; у квадрат есть только ширина а у прямоугольник есть ширина + высота то есть расширить квадрат компонент высота мы получить прямоугольник! как вы мочь догадаться ood гласить что делать так (вероятно) неправильно я сказать «вероятно» потому что здесь можно поспорить о подразумевать характеристика интерфейса… ну да ладный квадрат всегда иметь одинаковый высота и ширина поэтому из интерфейс квадрат совершенно верно предположить что площадь равный «ширина * ширина» наследоваться от квадрат класс прямоугольник (в соответствие с lsp) должный подчиниться правило интерфейс квадрат люба алгоритм правильно работать для квадрат должный также правильно работать и для прямоугольник взять другой алгоритм: std::vector<square*> shapes; int area = 0; for(auto s : shapes) area += s->width * s->width; он корректно быть работать для квадрат (вычислять сумма они площадей) но не сработать для прямоугольник следовательно прямоугольник нарушать принцип lsp если вы использовать подход с наследование интерфейс то ни square ни rectangle не быть наследоваться друг от друг интерфейс для квадрат и прямоугольник на самый дело отличаться и один не являться надмножество другой поэтому ood препятствовать использование наследование реализация как сказать выше если вы хотеть многократно использовать код то ood говорить что правильный выбор являться композиция! так что правильный версия привести выше (плохого) код иерархия наследование реализация на c++ выглядеть так: struct shape { virtual int area() const = 0; }; struct square : public virtual shape { virtual int area() const { return width * width; }; int width; }; struct rectangle : private square public virtual shape { virtual int area() const { return width * height; }; int height; }; «public virtual» в java означать «implements» использоваться при реализация интерфейс «private» позволять расширить базовый класс не наследовать при это он интерфейс — в это случай прямоугольник не являться квадрат хотя и наследоваться от он я не рекомендовать писать подобный код но если вы хотеться использовать наследование реализация то это нужно делать именно так! tl;dr — ваш ооп-класс говорить вы какой быть наследование ваш отсутствовать ood-класс должный быть сказать вы не использовать он 99% времени! концепция «сущность/компонент» (entity / component) разобраться с предпосылка давать перейти к тот с что начинать арас — к так называть начальный точка «типичный ооп» но для начало ещё один дополнение — арас называть этот код «традиционный ооп» и на это я хотеть возразить этот код мочь быть типичный для ооп в реальный мир но как и привести выше пример он нарушать всевозможный базовый принцип оо поэтому он вообще не стоить рассматривать как традиционный я начать с первое коммит прежде чем он начать переделывать структура в сторона ecs: «make it work on windows again» 3529f232510c95f53112bbfff87df6bbc6aa1fae // ------------------------------------------------------------------------------------------------- // super simple "component system" class gameobject; class component; typedef std::vector<component*> componentvector; typedef std::vector<gameobject*> gameobjectvector; // component base class knows about the parent game object and has some virtual methods class component { public: component() : m_gameobject(nullptr) {} virtual ~component() {} virtual void start() {} virtual void update(double time float deltatime) {} const gameobject& getgameobject() const { return *m_gameobject; } gameobject& getgameobject() { return *m_gameobject; } void setgameobject(gameobject& go) { m_gameobject = &go; } bool hasgameobject() const { return m_gameobject != nullptr; } private: gameobject* m_gameobject; }; // game object class has an array of components class gameobject { public: gameobject(const std::string&& name) : m_name(name) { } ~gameobject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_components) delete c; } // get a component of type t or null if it does not exist on this game object template<typename t> t* getcomponent() { for (auto i : m_components) { t* c = dynamic_cast<t*>(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void addcomponent(component* c) { assert(!c->hasgameobject()); c->setgameobject(*this); m_componentsemplace_back(c); } void start() { for (auto c : m_components) c->start(); } void update(double time float deltatime) { for (auto c : m_components) c->update(time deltatime); } private: std::string m_name; componentvector m_components; }; // the "scene": array of game objects static gameobjectvector s_objects; // finds all components of given type in the whole scene template<typename t> static componentvector findallcomponentsoftype() { componentvector res; for (auto go : s_objects) { t* c = go->getcomponent<t>(); if (c != nullptr) resemplace_back(c); } return res; } // find one component of given type in the scene (returns first found one) template<typename t> static t* findoftype() { for (auto go : s_objects) { t* c = go->getcomponent<t>(); if (c != nullptr) return c; } return nullptr; } да в сто строка код сложно разобраться сразу поэтому давать начать постепенно… мы нужный ещё один аспект предпосылка — в игра 90-ха популярно быть использовать наследование для решение весь проблема многократный использование код у вы быть entity расширять character расширять player и monster и так далее… это наследование реализация как мы описывать он ранее («код с душком») и кажется что правильно начинать с он но в результат это приводить к очень негибкий кодовый база потому что в ood есть описать выше принцип «composition over inheritance» итак в 2000-ха стать популярный принцип «composition over inheritance» и разработчик игра начать писать подобный код что делать этот код? ну ничто хороший если говорить вкратце то этот код заново реализовать уже существующий особенность язык — композиция как библиотека время выполнение а не как особенность язык можно представить это так как будто код на самый дело создавать новый метаязык поверх c++ и виртуальный машина (vm) для выполнение это метаязык в демо-игра арас этот код не требоваться (скоро мы он полностью удалим!) и служить только для тот чтобы примерно в 10 раз снизить производительность игра однако что же он на самый дело выполняет? это концепция "entity/component" («сущность/компонент») (иногда по непонятный причина называть "entity/component system" («система сущность/компонент»)) но она полностью отличаться от концепция "entity component system" («сущность-компонент-система») (который по очевидный причина никогда не называться "entity component system systems) он формализовать несколько принцип «ec»: игра быть строиться из не иметь особенность «сущностей» («entity») (в это пример называть gameobjects) который состоять из «компонентов» («component») gameobjects реализовать шаблон «локатор служб» — они дочерний компонента быть запрашиваться по тип компонента знать какой gameobject они принадлежать — они мочь находить компонента находиться с они на один уровень с помощь запрос к родительский gameobject композиция мочь быть глубина только в один уровень (компонент не мочь иметь собственный дочерний компонент gameobjects не мочь иметь дочерний gameobjects) gameobject мочь иметь только один компонент каждый тип (в некоторый фреймворка это обязательный требование в другой нет) каждый компонент (вероятно) с время изменяться некий неуказанный образ поэтому интерфейс содержимый «virtual void update» gameobjects принадлежать сцена который мочь выполнять запрос к весь gameobjects (а значит и к весь компонентам) подобный концепция быть очень популярный в 2000-ха год и несмотря на свой ограничительность оказаться достаточно гибкий для создание бесчисленный количество игра и тогда и сегодня однако это не требоваться в ваш язык программирование уже есть поддержка композиция как особенность язык — для доступ к она нет необходимость в раздутый концепции… зачем же тогда существовать этот концепции? ну если быть честной то они позволять выполнять динамический композиция в время выполнение вместо жёсткий задание тип gameobject в код они можно загружать из файл дать и это очень удобно потому что позволять дизайнер игр/уровень создавать свой тип объектов… однако в большинство игровой проект бывать очень мало дизайнер и в буквальный смысл целый армия программист поэтому я бы поспорить что это важный возможность худой тот — это ведь не единственный способ который можно реализовать композиция в время выполнения! например unity использовать в качество «язык скриптов» c# и в многий другой игра использоваться он альтернатива например lua — удобный для дизайнер инструмент мочь генерировать код c#/lua для задание новый игровой объект без необходимость использование подобный раздутый концепции! мы заново добавить этот «функцию» в следующий пост и сделать это так чтобы он не стоить мы десятикратное снижение производительности… давать оценить этот код в соответствие с ood: gameobject::getcomponent использовать dynamic_cast большинство человек сказать вы что dynamic_cast — это «код с душком» большой намёк на то что где-то у вы ошибка я бы сказать так — это свидетельство тот что вы нарушить lsp — у вы есть какой-то алгоритм работать с базовый интерфейс но он требоваться знать разный подробность реализация по конкретно этот причина код и «дурно пахнет» gameobject в принцип неплохой если представить что он реализовать шаблон «локатор служб»… но если пойти далёкий чем критика с точка зрение ood то этот шаблон создавать неявный связь между часть проект а я считать (без ссылка на википедия способный поддержать я знание из computer science) что неявный канал связь — это антипаттерн и имя следовать предпочесть явный канал связь тот же аргумент применимый к раздутый «концепция событий» который иногда использоваться в играх… я хотеть заявить что компонент — это нарушение srp потому что он интерфейс (virtual void update(time)) слишком широкий использование «virtual void update» в разработка игра распространить повсеместно но я бы тоже сказать что это антипаттерн хороший по должный позволять вы легко размышлять о поток управление и поток дать размещение каждый элемент код геймплей за вызов «virtual void update» полностью и совершенно обфусцировать поток управление и поток дать imho невидимый побочный эффект также называть дальнодействие — один из самый распространить источник баг а «virtual void update» гарантировать что почти весь быть являться невидимый побочный эффект хотя цель класс component — обеспечение возможность композиция он выполнять её через наследование что являться нарушение crp единственный хороший сторона это пример в тот что код игра лезть из кожа вон лишь бы соблюсти принцип srp и isp — он разбитый на множество простой компонент с очень малое обязанность что отлично подходить для многократный применение код однако он не так хороший в соблюдение dip — многие компонента иметь непосредственный знание друг о друг итак весь показать выше код на самый дело можно удалить весь этот структура удалить gameobject (в другой фреймворка называть также entity) удалить component удалить findoftype это часть бесполезный vm нарушать принцип ood и ужасно замедлять наш игра композиция без фреймворок (то есть использование особенность самый язык программирования) если мы удалить фреймворк композиция и у мы не быть базовый класс component то как наш gameobjects удаться использовать композиция и состоять из компонентов? как сказать в заголовок вместо написание этот раздутый vm и создание поверх она gameobjects на странный метаязык давать просто написать они на c++ потому что мы программист игра и это в буквальный смысл наш работа вот коммит в который удалённый фреймворк entity/component: https://githubcom/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c вот первоначальный версия исходный кода: https://githubcom/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/gamecpp вот изменить версия исходный кода: https://githubcom/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/gamecpp вкратце о изменениях: удалить ": public component" из каждый тип компонент добавить конструктор к каждый тип компонент ood — это в один очередь про инкапсуляция состояние класс но поскольку этот класс так малы/простой скрывать особо нечего: интерфейс — это описание дать однако один из главный причина тот что инкапсуляция являться основный столп заключаться в тот что она позволять мы гарантировать постоянный истинность инвариант класса… или в случай если инвариант нарушить то вы достаточно исследовать инкапсулированный код реализация чтобы найти ошибка в это пример код стоить добавить конструктор чтобы воплотить простой инвариант — весь значение должный быть инициализировать я переименовать слишком общий метод «update» чтобы они название отражать то что делать на самый дело — updateposition для movecomponent и resolvecollisions для avoidcomponent я удалить три жёстко задать блок код напоминать шаблон/префаб — код который создавать gameobject содержимый конкретный тип component и заменить он три класс c++ устранить антипаттерн «virtual void update» вместо тот чтобы компонента искать друг друг через шаблон «локатор служб» игра явный образ связывать они вместе при конструирование объект поэтому вместо это код «виртуальный машины»: // create regular objects that move for (auto i = 0; i < kobjectcount; ++i) { gameobject* go = new gameobject("object"); // position it within world bounds positioncomponent* pos = new positioncomponent(); pos->x = randomfloat(bounds->xmin bounds->xmax); pos->y = randomfloat(bounds->ymin bounds->ymax); go->addcomponent(pos); // setup a sprite for it (random sprite index from first 5) and initial white color spritecomponent* sprite = new spritecomponent(); sprite->colorr = 10f; sprite->colorg = 10f; sprite->colorb = 10f; sprite->spriteindex = rand() % 5; sprite->scale = 10f; go->addcomponent(sprite); // make it move movecomponent* move = new movecomponent(05f 07f); go->addcomponent(move); // make it avoid the bubble things avoidcomponent* avoid = new avoidcomponent(); go->addcomponent(avoid); s_objectsemplace_back(go); } у мы теперь есть обычный код c++: struct regularobject { positioncomponent pos; spritecomponent sprite; movecomponent move; avoidcomponent avoid; regularobject(const worldboundscomponent& bounds) : move(05f 07f) // position it within world bounds  pos(randomfloat(boundsxmin boundsxmax) randomfloat(boundsymin boundsymax)) // setup a sprite for it (random sprite index from first 5) and initial white color  sprite(10f 10f 10f rand() % 5 10f) { } };  // create regular objects that move regularobjectreserve(kobjectcount); for (auto i = 0; i < kobjectcount; ++i) regularobjectemplace_back(bounds); алгоритм ещё один серьёзный изменение внести в алгоритм помнить в начало я сказать что интерфейс и алгоритм работать в симбиоз и должный влиять на структура друг друга? так вот антипаттерн "virtual void update" стать враг и здесь первоначальный код содержимый алгоритм основный цикл состоять всего лишь из этого: // go through all objects for (auto go : s_objects) { // update all their components go->update(time deltatime); вы мочь возразить что это красиво и просто но имхо это очень очень плохо это полностью обфусцировать и поток управление и поток дать внутри игра если мы хотеть иметь возможность понимать свой по если мы хотеть поддерживать он если мы хотеть добавлять в он новое вещий оптимизировать он выполнять он эффективно на несколько процессорный ядро то мы нужно понимать и поток управление и поток дать поэтому «virtual void update» нужно предать огонь вместо он мы создать более явный основной цикл который сильно упрощать понимание поток управление (поток дать в он по-прежнему обфусцировать но мы исправимый это в следующий коммитах) // update all positions for (auto& go : s_game->regularobject) { updateposition(deltatime go s_game->boundswb); } for (auto& go : s_game->avoidthis) { updateposition(deltatime go s_game->boundswb); } // resolve all collisions for (auto& go : s_game->regularobject) { resolvecollisions(deltatime go s_game->avoidthis); } недостаток такой стиль в тот что для каждый новое тип объект добавлять в игра мы прийтись добавлять в основной цикл несколько строка я вернуться к это в последующий пост из этот серия производительность здесь множество огромный нарушение ood сделать несколько плохой решение при выбор структура и оставаться много возможность для оптимизация но я добраться до они в следующий пост серия однако на уже на это этап понятно что версия с «исправить ood» почти полностью соответствовать или побеждать финальный «ecs»-код из конец презентации… и весь что мы сделать — просто взять плохой код псевдо-ооп и заставить он соблюдать принцип ооп (а также удалить сто строка кода)! следующий шаг здесь я хотеть рассмотреть гораздо больший спектр вопрос в тот число решение остаться проблема ood неизменяемый объект (программирование в функциональный стиле) и преимущество который они мочь привнести в рассуждение о поток дать передача сообщение применение логика dod к наш ood-код применение относиться к дело мудрость в ood-код удаление этот класс «сущностей» который в результат у мы получиться и использование только чистый компонент использование разный стиль соединение компонент (сравнение указатель и обработчиков) контейнер компонент из реальный мир доработка ecs-версия для улучшение оптимизация а также дальнейший оптимизация не упомянуть в доклад арас (например многопоточность/simd) порядок не обязательно быть такой и возможно я рассмотреть не весь перечисленное… дополнение ссылка на статья распространиться за предел круг разработчик игра поэтому добавлю: "ecs" (эта статья википедия плохой кстати она объединять концепция ec и ecs а это не один и то же) — это фальшивый шаблон циркулировать внутри сообщество разработчик игра по суть он являться версия реляционный модель в который «сущности» — это просто id обозначать бесформенный объект «компоненты» — это строка в конкретный таблица ссылаться на id а «системы» — это процедурный код который мочь модифицировать компонента этот «шаблон» всегда позиционироваться как решение проблема избыточный применение наследование но при это не упоминаться что избыточный применение наследование на самый дело нарушать рекомендация ооп отсюда мой возмущение это не «единственно верный способ» написание по пост предназначить для тот чтобы человек на самый дело изучать существующий принцип проектирование 
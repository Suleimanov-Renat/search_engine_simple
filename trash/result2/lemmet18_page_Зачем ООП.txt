зачем ооп продолжать про ооп налицо поверхностный понимание я попробовать сжато ответить на вопрос «зачем» (осознавать грандиозность замысла) давать так задуматься над вопрос «зачем ооп» ответ дать в несколько слово выразить максимально емко весь польза ооп не нажимать «читать дальше» пока не ответить для себя разумеется правильный ответ никто не знать но два самый главное польза следующие: 1 упрощение понимание человек 2 локализация влияние код 1 упрощение понимание — человек ведь наш человеческий язык так и устроенный помнить шутка про «утку»? что такой «стул»? «вота это стул на немой сидят» это одновременно и поведение и предмет человек привыкнуть обозначать _класс предмет схожий поведения_ один слово который определять он поведение что же удивительный в тот что этот практика перекочевать в программирование? ведь гораздо простой рассуждать о стек чем о «этом набор дать и код который отдавать один последний занести объект» 2 локализация влияние давать представимый себя неправильный разработка приложение например есть структура с дать пользователь и есть структура запись журнал при сохранение на диск с они нужно работать одинаково — рассматривать они как непрерывный блок дать однако этот работа не быть проделать не быть выявить поведение значит в любой место у мы дублироваться код запись в файл системный вызов и тд начинать расширять — хотеть транзакционный запись как быть? она нужно прикрутить она _ко весь местам_ где есть запись на диск и тд через какой-то время расширение приложение становиться слишком дорогостоящий получать то что называть «монолитный приложение» это плохо вроде бы весь это понимать внимание — вопрос а что являться «антимонолитным» приложением? остановиться подумать какой она — идеальный архитектура? весь просто — она легко расширяться в рамка поставить задача как это достичь? правильный ответ такой — нужно выделить одинаковый поведение и запрограммировать он в один место следующий вопрос — одинаковый поведение «чего»? компонент класс объекта? а это важно? неважно как назвать что такой бд? объект класс модуль компонент? это неважно важный то что мы разрешить иметь собственный состояние для реализация поведение по управление внешний хранение дать и «освободили» свой код от это поведение вы уже наверное догадаться к что я клонить к тот что принцип который я называть «принцип ооп» (разделение поведение и разрешение иметь свой состояние) естественный образ возникать при решение _любой_ мало-мальски сложный задача это важный и я повторю: только разделение (специализация) поведение позволять создавать архитектура который легко расширяться разделение поведение означать появление собственный (локального) состояние и следовательно возникать какой-то сущность хранить состояние «локальность» состояние означать что влияние код ограничить рамка сущность назвать сущность объект (в смысл экземпляр классов) а поведение — класс это и есть ооп механизм реализация оставаться на совесть (ить бессовестности) создатель язык и компилятор где-то есть автоматический деструктор где-то — нет где-то есть приватный дать класс где-то нет где-то есть наследование а где-то он надо сооружать где-то есть явный класс а где-то объект мочь быть какой угодный где-то есть интерфейс где-то нет это не ооп это _механизм реализации_ ооп — это архитектура приложение главный принцип ооп — расширяться класс выявить (локализуй) поведение и создать для это класс и ещё это не для новичок _использование объектов_ не являться ооп если программист мочь вызвать mathrandom() он не становиться ооп-программист но разработка в стиль ооп — это не аз не начало программирование чтобы выявить поведение — нужно иметь опыт нужно понимать что такой «специализация поведения» как быть новичку? изучать хорошо спроектировать приложение в тот область который интересный 
как запустить java-приложение с несколько версия один библиотека в 2017 год как запустить java-приложение с несколько версия один библиотека в 2017 год хотеть поделиться решение один проблема с который я прийтись столкнуться плюс исследование данный вопрос в контекст java 9 дисклеймерписатель из я ещё тот (писать в один раз) поэтому закидывание вкусный помидор с указание причина только приветствоваться сразу договориться что статья не годиться в качество руководство по: java 9 elasticsearch maven если по последний имя информация в сеть полно то по первому… с время появиться по крайний мера здесь есть необходимый информация представимый себя простой ситуацию: разворачивать кластер elasticsearch и загружать в он дать мы писать приложение который заниматься поиск в это кластер поскольку постоянно выходить новое версия elasticsearch мы привносить в кластер новое проблема фич с помощь rolling upgrade но вот незадача — в какой-то момент у мы смениться формат хранить дать (например чтобы максимально эффективно использовать какой-то из новый фич) и делать reindex нецелесообразный мы подойти такой вариант: ставить новый кластер на этот же машина — один кластер с старый схема дать оставаться на место только для поиск а поступать дать загружать в два с новый схема тогда наш поисковый компонент потребоваться держать на связь уже 2 кластер наш приложение использовать java api для общение с кластер а это значит что оно тянуть в зависимость сам elasticsearch стоить отметить что вместе с 5-ой версия выйти и rest client избавлять мы от такой проблема (а также от удобный api самый elasticsearch) но мы переместиться в время на момент релиз 2-ой версия рассмотреть возможный решение на пример простой приложения: поиск документ в 2-х кластер elasticsearch 17 и 24 код доступный на гитхаб и повторять структура дать статья (отсутствовать только osgi) перейти к дело создать maven-проект следующий структуры: +---pomxml +---core/ | +---pomxml | +---src/ | +---main/ | | +---java/ | | | +---elasticsearch/ | | | +---client/ | | | +---searchclientjava | | | +---searcherjava | | +---resources/ | +---test/ | +---java/ +---es-v1/ | +---pomxml | +---src/ | +---main/ | | +---java/ | | | +---elasticsearch/ | | | +---client/ | | | +---v1/ | | | +---searchclientimpljava | | +---resources/ | +---test/ | +---java/ +---es-v2/ +---pomxml +---src/ +---main/ | +---java/ | | +---elasticsearch/ | | +---client/ | | +---v2/ | | +---searchclientimpljava | +---resources/ +---test/ +---java/ очевидно что в один модула подключить несколько версия один библиотека не получиться поэтому проект должный быть многомодульным: core — здесь находиться весь логика приложения; можно (и нужно) вынести интерфейс для взаимодействие с elasticsearch в отдельный модуль; es-v1 — реализация интерфейс для elasticsearch 175; es-v2 — реализация интерфейс для elasticsearch 245 модуль core содержимый класс searcher который являться "испытателем" наш модуль es-v1 и es-v2: public class searcher { public static void main(string[] args) throws exception { list<searchclient> clients = arraysaslist( getclient("1") getclient("2") ); for (searchclient client : clients) { systemoutprintf("client for version: %s%n" clientgetversion()); map doc = clientsearch("test"); systemoutprintln("found doc:"); systemoutprintln(doc); systemoutprintln(); } clientsforeach(searchclient::close); } private static searchclient getclient(string desiredversion) throws exception { return null; // сантиметр далее } } ничто сверхестественного: выводиться версия elasticsearch использовать модуль и проводиться тестовый поиск через он — это быть достаточно для демонстрация взглянуть на один из реализация два почти идентична: public class searchclientimpl implements searchclient { private final settings settings = immutablesettingsbuilder() put("clustername" "es1") put("nodename" "es1") build(); private final client searchclient = new transportclient(settings) addtransportaddress(getaddress()); private inetsockettransportaddress getaddress() { return new inetsockettransportaddress("127001" 9301); } @override public string getversion() { return versioncurrentnumber(); } @override public map search(string term) { searchresponse response = searchclientpreparesearch("*") setquery(querybuilderstermquery("field" term)) execute() actionget(); if (responsegethits()gettotalhits() > 0) { return responsegethits()getat(0)getsource(); } else { return null; } } @override public void close() { searchclientclose(); } } тоже весь просто: текущий версия зашить в elasticsearch и поиск по поль field в весь индекс (*) возвращать один найти документ если есть проблема здесь крыться в тот как именно вызвать реализация интерфейс searchclient в метод searcher#getclient и получить желаемый результат мочь быть classforname? даже если вы не знаток java наверняка слышать что там властвовать classloader он не позволить мы совершить задумать если оставить по умолчание поэтому такой решение влоб не сработает: private static searchclient getclient(string desiredversion) throws exception { string classname = stringformat("elasticsearchclientv%ssearchclientimpl" desiredversion); return (searchclient) classforname(classname)newinstance(); } собрать запустить и увидеть результат… вполне неопределённый например такой: exception in thread "main" javalangincompatibleclasschangeerror: implementing class at javalangclassloaderdefineclass1(native method) at javalangclassloaderdefineclass(classloaderjava:763) at javasecuritysecureclassloaderdefineclass(secureclassloaderjava:142) at javaneturlclassloaderdefineclass(urlclassloaderjava:467) at javaneturlclassloaderaccess$100(urlclassloaderjava:73) at javaneturlclassloader$1run(urlclassloaderjava:368) at javaneturlclassloader$1run(urlclassloaderjava:362) at javasecurityaccesscontrollerdoprivileged(native method) at javaneturlclassloaderfindclass(urlclassloaderjava:361) at javalangclassloaderloadclass(classloaderjava:424) at sunmisclauncher$appclassloaderloadclass(launcherjava:331) at javalangclassloaderloadclass(classloaderjava:357) at javalangclassforname0(native method) at javalangclassforname(classjava:348) at elasticsearchclientsearchergetclient(searcherjava:28) at elasticsearchclientsearchermain(searcherjava:10) хотя мочь и classnotfoundexception бросить… или ещё что так как urlclassloader найти и загрузить один попасться класс с задать имя из задать набор jar-файл и директория это быть необязательно требовать класс в дать случай этот ошибка возникать из-за тот что в список class-path библиотека elasticsearch-245jar идти до elasticsearch-175jar поэтому весь класс (которое совпадать по имени) быть загрузить для 245 поскольку наш searcher сначала пытаться загрузить модуль для elasticsearch 175 (getclient("1")) urlclassloader загрузить он совсем не тот класс когда загрузчик класс иметь в свой распоряжение пересекаться по имя (а значит и по имя файлов) класс такой он состояние называть jar hell (ить class-path hell) свой classloader становиться очевидный что модуль и они зависимость нужно разнести по разный загрузчик класс просто создавать urlclassloader на каждый модуль es-v* и указывать каждый свой директория с jar-файлами: private static searchclient getclient(string desiredversion) throws exception { string classname = stringformat("elasticsearchclientv%ssearchclientimpl" desiredversion); path moduledependencies = pathsget("modules" "es-v" + desiredversion); url[] jars = fileslist(moduledependencies) map(path::touri) map(searcher::tourl) toarray(url[]::new); classloader classloader = new urlclassloader(jars); // parent = app's class loader return (searchclient) classloaderloadclass(classname)newinstance(); } мы нужно собрать и скопировать весь модуль в соответствующий директория modules/es-v*/ для это использовать плагин maven-dependency-plugin в модуль es-v1 и es-v2 собрать проект: mvn package и запустим: сента 29 2017 10:37:08 дп orgelasticsearchpluginspluginsservice <init> info: [es1] loaded [] sites [] сента 29 2017 10:37:12 дп orgelasticsearchpluginspluginsservice <init> info: [es2] modules [] plugins [] sites [] client for version: 175 found doc: {field=test 1} client for version: 245 found doc: {field=test 2} бинго! (17 не сработать под jre 9)ести не пропатчить jvminfo о что упоминаться ниже в пересборка elasticsearch 17 совсем хардкорный случай предполагать что модуль core тоже использовать какой-нибудь утилитный метод из библиотека elasticsearch наш текущий решение уже не сработать из-за порядок загрузка классов: invoke findloadedclass(string) to check if the class has already been loaded invoke the loadclass method on the parent class loader if the parent is null the class loader built-in to the virtual machine is used instead invoke the findclass(string) method to find the class то есть в это случай быть загрузить класс elasticsearch из core а не es-v* присмотреться к порядок загрузка видеть обходный вариант: написать свой загрузчик класс который нарушать этот порядок поменять местами шаг 2 и 3 такой загрузчик смочь загрузить не только отдельно свой модуль es-v* но и увидеть класс из core написать свой urlclassloader назвать он например parentlasturlclassloader: public class parentlasturlclassloader extends urlclassloader {  } и переопределить loadclass(stringboolean) скопировать код из classloader и убрать весь лишнее: @override protected class<?> loadclass(string name boolean resolve) throws classnotfoundexception { synchronized (getclassloadinglock(name)) { class<?> c = findloadedclass(name); if (c == null) { try { if (getparent() != null) { c = getparent()loadclass(name); } } catch (classnotfoundexception e) { } if (c == null) { c = findclass(name); } } if (resolve) { resolveclass(c); } return c; } } менять местами вызов getparent()loadclass(string) и findclass(string) и получаем: @override protected class<?> loadclass(string name boolean resolve) throws classnotfoundexception { synchronized (getclassloadinglock(name)) { class<?> c = findloadedclass(name); if (c == null) { try { c = findclass(name); } catch (classnotfoundexception ignored) { } if (c == null) { c = getparent()loadclass(name); if(c == null) { throw new classnotfoundexception(name); } } } if (resolve) { resolveclass(c); } return c; } } поскольку наш приложение вручную быть загружать класс модуль загрузчик должный бросить classnotfoundexception если класс нигде не найти загрузчик написать теперь использовать он заменить urlclassloader в метод getclient(string): classloader classloader = new urlclassloader(jars); на parentlasturlclassloader: classloader classloader = new parentlastclassloader(jars); и запустить приложение снова видеть тот же результат: сента 29 2017 10:42:41 дп orgelasticsearchpluginspluginsservice <init> info: [es1] loaded [] sites [] сента 29 2017 10:42:44 дп orgelasticsearchpluginspluginsservice <init> info: [es2] modules [] plugins [] sites [] client for version: 175 found doc: {field=test 1} client for version: 245 found doc: {field=test 2} serviceloader api в java 6 добавить класс javautilserviceloader который предоставлять механизм загрузка реализация по интерфейсу/абстрактный класс этот класс тоже решать наш проблему: private static searchclient getclient(string desiredversion) throws exception { path moduledependencies = pathsget("modules" "es-v" + desiredversion); url[] jars = fileslist(moduledependencies) map(path::touri) map(searcher::tourl) toarray(url[]::new); serviceloader<searchclient> serviceloader = serviceloaderload(searchclientclass new urlclassloader(jars)); return serviceloaderiterator()next(); } весь очень просто: искать в директория модуль весь jar-файл складывать они в загрузчик пытаться загрузить хоть один реализация наш интерфейс использовать создать загрузчик чтобы serviceloader увидеть реализация интерфейс нужно создать файл с полный имя интерфейс в директория meta-inf/services: +---es-v1/ | +---src/ | +---main/ | +---resources/ | +---meta-inf/ | +---services/ | +---elasticsearchclientspisearchclient +---es-v2/ +---src/ +---main/ +---resources/ +---meta-inf/ +---services/ +---elasticsearchclientspisearchclient и написать полный имя класс реализовать этот интерфейс на каждый строке: в наш случай по один searchclientimpl на каждый модуль для es-v1 в файл быть строка: elasticsearchclientv1searchclientimpl и для es-v2: elasticsearchclientv2searchclientimpl также использовать плагин maven-dependency-plugin для копирование модуль es-v* в modules/es-v*/ пересобрать проект: mvn clean package и запустим: сента 29 2017 10:50:17 дп orgelasticsearchpluginspluginsservice <init> info: [es1] loaded [] sites [] сента 29 2017 10:50:20 дп orgelasticsearchpluginspluginsservice <init> info: [es2] modules [] plugins [] sites [] client for version: 175 found doc: {field=test 1} client for version: 245 found doc: {field=test 2} отлично требовать результат снова получить для упомянуть хардкорный случай прийтись выносить интерфейс searchclient в отдельный модуль spi и использовать следующий цепочка загрузчиков: core: bootstrap -> system spi: bootstrap -> spi es-v1: bootstrap -> spi -> es-v1 es-v2: bootstrap -> spi -> es-v2 тот создавать отдельный загрузчик для spi (в parent кидать null — быть использовать bootstrap-загрузчик) загружать имя spi (интерфейс searchclient) затем создавать по загрузчик на каждый модуль es-v* у который родительский быть загрузчик для spi  profit! модуль osgi признаться сразу и честно — я не доводиться сталкиваться с фреймворка osgi (мочь оно и к лучшему?) взглянуть на мана для начинающий у apache felix и eclipse equinox они большой походить на контейнер в который (вручную?) загружать бандлый даже если есть реализация для встраивание это слишком громоздко для наш простой приложение если я не право высказать обратный точка зрение в комментарий (да и вообще хотеться увидеть что он кто-то использовать и как) я не стать углубляться в это вопрос тк в java 9 модуль теперь из коробка который мы сейчас и рассмотреть нативный модуль в java? на прошлый неделя релизнуться 9-ая версия платформа в который главное нововведение стать модуляризация рантайм и исходник самый платформа как раз то что мы надо! hint: для тот чтобы использовать модуль нужно сначала скачать и установить jdk 9 если вы ещё это не делать здесь дело осложнять только способность использовать библиотека запускаться под девятка в качество модуль (на самый дело я просто не найти способ в intellij idea указать class-path вместе с module-path поэтому далее мы весь делать в контекст module-path) как работать модульный система прежде чем переходить к модификация код наш приложение под модульный система сначала узнать как она работать (я мочь ошибаться поскольку сам только начать разбираться в это вопросе) кроме упомянуть модуль есть ещё слоить содержимый они при старт приложение создаваться слой boot в который загружаться весь указанный в --module-path модуль из который состоять приложение и они зависимость (от модуль javabase автоматически зависеть весь модули) другой слоить мочь быть создать программно каждый слой иметь свой загрузчик класс (ить иерархию) как и у загрузчик модульный слоить также мочь быть построить иерархически в такой иерархия модуль один слой мочь видеть другой модуль находиться в родительский слой сам модуль изолировать друг от друг и по умолчание они пакет и класс в они не видный другой модуль дескриптор модуль (им являться module-infojava) позволять указать какой пакет мочь открыть каждый модуль и от какой модуль и они пакет зависеть они сам дополнительно модуль мочь объявлять о тот что они использовать некоторый интерфейс в свой работа и мочь объявлять о доступный реализация этот интерфейс этот информация использоваться serviceloader api для загрузка реализация интефрейс из модуль модуль бывать явный и автоматический (тип большой но мы ограничиться этими): явный модуль описываться явно файл-дескриптор module-infoclass в корн jar-архиа (модуль или модуляризовать jar) автоматический модуль — это библиотека без дескриптор поместить в module-path; в качество модуль такой тип предполагаться использовать существующий немодуляризовать библиотека использовать в старый добром class-path теперь этот информация быть достаточно чтобы применить её на наш проекте: в boot-слой у мы быть только модуль core если в он быть находиться модуль es-v* то приложение не запуститься из-за конфликтовать транзитивный модуль elasticsearchshaded класс searcher быть вручную загружать модуль es-v* в отдельный дочерний слоить с свой загрузчик класс использовать serviceloader api весь так просто? package hell модуль не разрешить иметь пересекаться имя пакет (по крайний мера в один слое) например есть некий библиотека который предоставлять какой-то api в публичный класс functions в этот библиотека есть класс helpers с пакетный область видимость вот они: comfoobar public class functions class helpers на сцена выходить два библиотека который предоставлять который дополнять функционал первой: comfoobaz public class additional и она требоваться некоторый функционал из закрытый класс helpers выходить из положение поместить какой-нибудь класс в этот же пакет: comfoobaz public class additional comfoobar public class accessortohelpers поздравить себя — мы только что создать себя проблема разделение пакет (split package) с точка зрение модульный система что можно сделать с такой библиотеками? мы предлагать оставить такой библиотека в class-path и дотянуться до они из модуль использовать автоматический модуль в качество мост но мы не искать лёгкое путь поэтому использовать другой вариант: докласть в библиотека весь он зависимость и получить один единственный jar-архив (известный под название fat jar и uber jar) он-то и можно использовать в module-path как автоматический модуль миновать class-path проблема мочь стать сборка такой all-in-one jar инструкция по пересборка elasticsearchelasticsearch активно использовать доступ к package-private методам/поль для доступ к некоторый функционал lucene чтобы использовать он в вид автоматический модуль сделать из он uber jar и установить в локальный репозиторий под имя elasticsaerch-shaded для дальнейший использование в наш проект собирать elasticsearch 17 в один версия проект приложение представлять из себя единственный maven-модуль поэтому здесь проблема особо не возникнет: нужно поправить pomxml и некоторый класс если собирать 8-кой клонировать репозиторий в какой-нибудь директория чекаутим тег v175 и начинать править: в проект уже использоваться maven-shade-plugin поэтоу для сборка uberjar потребоваться закомментировать включение некоторый пакет чтобы включаться все: <!-- <includes> <include>comgoogleguava:guava</include> <include>comcarrotsearch:hppc</include> <include>comfasterxmljacksoncore:jackson-core</include>  </includes> --> и желательно в оригинал без перемещений: <!-- <relocations> <relocation> <pattern>comgooglecommon</pattern> <shadedpattern>orgelasticsearchcommon</shadedpattern> </relocation> <relocation> <pattern>comcarrotsearchhppc</pattern> <shadedpattern>orgelasticsearchcommonhppc</shadedpattern> </relocation>  </relocations> --> прийтись убрать groovy (ломать загрузка из-за такой неоднозначности) а также логгера (длить они нет конфиговый jul быть работать прекрасно по умолчанию) добавить <excludes> сразу за закоментировать узел <includes>: <excludes> <exclude>orgcodehausgroovy:groovy-all</exclude> <exclude>orgslf4j:*</exclude> <exclude>log4j:*</exclude> </excludes> выключить вырезание неиспользуемый класс — плагин не знать о serviceloader/reflection api: <!--<minimizejar>true</minimizejar>--> и добавить склеивание сервис-файл с класс реализация для serviceloader api в узел <configuration> плагина: <transformers> <transformer implementation="orgapachemavenpluginsshaderesourceservicesresourcetransformer"/> </transformers> с pomxml закончить остаться устранить unsupportedoperationexception который кидать javalangmanagementruntimemxbean#getbootclasspath для это найти такой строка в класс jvminfo: infobootclasspath = runtimemxbeangetbootclasspath(); и оборнуть её в "правильные": if (runtimemxbeanisbootclasspathsupported()) { infobootclasspath = runtimemxbeangetbootclasspath(); } else { infobootclasspath = ""; } этот информация использоваться всего лишь для статистика готовый теперь можно собрать jar: $ mvn package и после компиляция и сборка получить требовать elasticsearch-175jar в директория target теперь он нужно установить в локальный репозиторий например под имя elasticsearch-shaded: $ mvn install:install-file \ > -dfile=elasticsearch-175jar \ > -dgroupid=orgelasticsearch \ > -dartifactid=elasticsearch-shaded \ > -dversion=175 \ > -dpackaging=jar \ > -dgeneratepom=true теперь этот артефакт можно использовать как автоматический модуль в наш maven-модула es-v1: <dependencies> <dependency> <groupid>orgelasticsearch</groupid> <artifactid>elasticsearch-shaded</artifactid> <version>175</version> </dependency>  </dependencies> собирать elasticsearch 24 откатить локальный изменение и зачекаутим тег v245 начинать с 2-ой версия проект разбитый на модуль нужный мы модуль выдавать elasticsearch-245jar — модуль core один дело убрать снапшота мы нужный релиз: $ mvn versions:set -dnewversion=245 теперь поискать настроить ли где shade-плагин… и натыкаться на такой доку: shading and package relocation removed elasticsearch used to shade its dependencies and to relocate packages we no longer use shading or relocation you might need to change your imports to the original package names: comgooglecommon was orgelasticsearchcommon comcarrotsearchhppc was orgelasticsearchcommonhppc jsr166e was orgelasticsearchcommonutilconcurrentjsr166e  мы прийтись добавить shade-плагин заново в модуль core добавить в настройка трансформера сервис-файл и исключение логгеров: <plugin> <groupid>orgapachemavenplugins</groupid> <artifactid>maven-shade-plugin</artifactid> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> </execution> </executions> <configuration> <transformers> <transformer implementation="orgapachemavenpluginsshaderesourceservicesresourcetransformer"/> </transformers> <artifactset> <excludes> <exclude>orgslf4j:*</exclude> <exclude>log4j:*</exclude> </excludes> </artifactset> </configuration> </plugin> убрать зависимость comtwitter:jsr166e (там использоваться sunmiscunsafe который в 9-ка "нет") у модуль core: <!-- <dependency> <groupid>comtwitter</groupid> <artifactid>jsr166e</artifactid> <version>110</version> </dependency> --> и сменить импорт comtwitterjsr166e на javautilconcurrentatomic плагин animal-sniffer-maven-plugin задетектит изменение на предыдущий шаг (в 7-ка нет jsr166e) убираем: <!-- <plugin> <groupid>orgcodehausmojo</groupid> <artifactid>animal-sniffer-maven-plugin</artifactid> </plugin> --> готовый теперь проделывать тот же шаг по сборка и установка что и для es-v1 с небольшой отличиями: поменять версия на 245 достаточно собрать только модуль core: $ mvn clean package -pl orgelasticsearch:parentorgelasticsearch:elasticsearch -dskiptests=true модуль в наш проект после тот как мы выяснить что использовать мы библиотека способный работать в модульный система java сделать из наш maven-модуль явный java-модуль для это мы потребоваться в каждый директория с исходник (src/main/java) создать файл module-infojava и в они описать взаимоотношение между модуль модуль core не зависеть ни от какой другой модуль а только содержимый интерфейс который должный реализовать другой модуль поэтому описание быть выглядеть так: // имя модуль - elasticsearchclientcore module elasticsearchclientcore { // очевидно нужно открыть пакет с интерфейс // чтобы он быть доступный для модуль exports elasticsearchclientspi; // и это модуль скажем что мы использовать интерфейс searchclient // для динамический загрузка serviceloader' uses elasticsearchclientspisearchclient; } для модуль es-v1 и es-v2 быть похожий описание: они использовать модуль elasticsearchclientcore тк в он находиться интерфейс каждый использовать автоматический модуль elasticsearch требовать версия и каждый модуль говорить что он предоставлять реализация для интерфейс searchclient итого иметь для es-v1: // имя модуль - elasticsearchclientv1 module elasticsearchclientv1 { // в core лежать searchclient requires elasticsearchclientcore; // этот автоматический requires elasticsearchshaded; // говорить модуль core что у мы есть реализация он интерфейс provides elasticsearchclientspisearchclient with elasticsearchclientv1searchclientimpl; } для es-v2 почти весь тоже самый только в имя должный фигурировать версия v2 теперь как загрузить такой модули? ответ на этот вопрос есть в описание класс modulelayer который содержимый небольшой пример загрузка модуль с фс предположить что модуль es-v* находиться каждый весь в тот же директория modules/es-v*/ можно написать примерно такой реализацию: private static searchclient getclient(string desiredversion) throws exception { path modpath = pathsget("modules" "es-v" + desiredversion); modulefinder modulefinder = modulefinderof(modpath); modulelayer parent = modulelayerboot(); configuration config = parentconfiguration()resolve(modulefinder modulefinderof() setof("elasticsearchclientv" + desiredversion)); modulelayer modulelayer = parentdefinemoduleswithoneloader(config threadcurrentthread()getcontextclassloader()); serviceloader<searchclient> serviceloader = serviceloaderload(modulelayer searchclientclass); optional<searchclient> searchclient = serviceloaderfindfirst(); if (searchclientispresent()) { return searchclientget(); } throw new exception("module 'elasticsearchclientv" + desiredversion + "' not found on " + modpath); } modulelayer#definemoduleswithmanyloaders мы здесь не подойти так как у мы получиться совсем изолировать модуль и наш es-v* не смочь увидеть свой зависимость итак теперь нужно собрать весь модуль для компиляция потребоваться плагин maven-compiler-plugin новый на данный момент последний версия — 370: <plugin> <groupid>orgapachemavenplugins</groupid> <artifactid>maven-compiler-plugin</artifactid> <version>370</version> </plugin> указать java 9 для исходников: <properties> <mavencompilersource>19</mavencompilersource> <mavencompilertarget>19</mavencompilertarget> </properties> и не забывать про maven-dependency-plugin поэтому пересобрать модули: $ mvn clean package теперь можно запустить и видеть такой же вывод: сента 29 2017 10:59:01 дп orgelasticsearchpluginspluginsservice <init> info: [es1] loaded [] sites [] сента 29 2017 10:59:04 дп orgelasticsearchpluginspluginsservice <init> info: [es2] modules [] plugins [] sites [] client for version: 175 found doc: {field=test 1} client for version: 245 found doc: {field=test 2} мочь показаться что решение с загрузчик класс — простой но решение из коробка просто глупо игнорировать если только вы не собираться остаться на java 8 или более ранний конец загрузка библиотека разный версия выливаться в механизм очень напоминать система плагинов/модуль для это можно: построить свой велосипед с classloader — мочь подойти там где сильно хотеться проблема не хотеться тащить библиотека и разбивать на модуль (можный извернуться и сделать весь в одном) использовать serviceloader api — если не мешать meta-inf/services использовать готовый сторонний библиотека который мы не рассматривать (например) — весь удобство готовый и протестировать код и подрасти бандло использовать мощный система модуль java 9 — если переход позволительный или вообще проект начинаться с чистый лист ps желать весь джавист удачный переход на java 9! 
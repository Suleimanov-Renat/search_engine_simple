определять весь класс который использовать приложение на java без сомнение каждый кто в свой резюме указывать опыт разработка на java хоть раз в жизнь писать строка public static void main(string[] args) компилировать они и запускать на выполнение команда наподобие java helloworld но многие ли знать что происходить внутри jvm от момент выполнение этот команда до тот как управление передаваться метод main как java находить и загружать необходимый пользователь классы? возникнуть однажды производственный задача заставить автор разобраться в это вопрос результат изыскание под кат сразу стоить оговориться что статья не претендовать на полнота охват весь существующий jvm тестирование проводиться только на sun hotspot jvm постановка задача в один прекрасный день заказчик потребоваться выяснить какой класс использовать он приложение приложение быть уже хорошо знакомый автор и представлять себя гремучий смесь из код различный расовый принадлежность реализовать (к честь разработчик система по больший часть грамотно и к месту) механизм наследование поздний связывание и динамический компиляция поэтому информация о действительно использовать класс мочь существенно помочь в рефакторинг приложение задача поставить следующий образом: в процесс работа приложение должный формироваться файл содержимый имя весь класс непосредственно использовать приложение оно к слово состоять из два основный частей: сервер приложение на который разместить веб-интерфейс приложение и сервер обработка (отдельный сервер на который различный периодический задача запускаться с помощь скрипт ant) разумеется информация о класс необходимый собирать с оба часть приложение приступить к поиск решение поставить задача и заодно разобраться с механизм загрузка класс в java переопределение системный загрузчик класс один направление который пришлый в голова при решение дать задача быть воспользоваться возможность расширение механизм загрузка класс в java на данный тема написать достаточно много стать тот число и на русский язык (ссылка в конец статьи) быть данный механизм в следующем: наследник абстрактный класс javalangclassloader использоваться для непосредственный загрузка класс о чем красноречивый свидетельствовать сигнатура метод class loadclass(string name) данный метод должный найти массив байт являться байт-код искомое класс и передать он метод protected class defineclass(string name byte[] b int off int len) который превратить он в экземпляр класс javalangclass такой образ реализовать свой загрузчик разработчик мочь загружать из любой место откуда можно получить массив байт; разработчик фреймворка декларироваться хитрый механизм иерархия и наследование загрузчик при это наследование здесь следовать понимать не в термин наследование класс в ооп а как отдельный иерархия организовать с помощь метод getparent класс classloader при старт jvm создаваться вершина этот иерархия из три основный загрузчиков: базовый (bootstrap classloader отвечать за загрузка базовый класс фреймворка) загрузчик расширение (extension classloader отвечать за загрузка класс из lib/ext) и системный загрузчик (system classloader отвечать за загрузка пользовательский классов) далее разработчик вольный продолжать этот иерархия от системный загрузчик и ниже по умолчание в hotspot jvm в качество системный загрузчик использоваться класс sunmisclauncher$appclassloader однако он можно легко переопределить с помощь системный свойство javasystemclassloader ключ командный строка java -djavasystemclassloader=имяклассазагрузчика; декларироваться правило делегирование загрузки: люба загрузчик прежде чем пытаться загрузить люба класс сначала должный обратиться к свой родитель и только если тот не смочь загрузить искомый класс попытаться загрузить он сам к сожаление красота и удобство данный правило компенсироваться необязательность он исполнение с последствие неисполнение это правило автор ещё предстоять столкнуться однако на дать этап уже появиться один концепция решение поставить задачи: реализовать собственный загрузчик класс заменять системный который при вызов метод loadclass быть просто записывать имя класс в файл и передавать запрос на загрузка класс настоящий системный загрузчик при условие соблюдение описать выше правило делегирование это должный позволить отловить весь загружать пользовательский класс даже если они загружаться другой загрузчиками; заставить весь jvm запускать на машина использовать данный загрузчик класс как системный для реализация два пункт необходимый решить следующий задачи: сделать класс видимый для весь запускать jvm включать класс в весь classpath множество компонент приложение неудобно трудоёмкий и нерационально с точка зрение расширение система тем более что существовать более красивый решение — поместить класс загрузчик в папка lib/ext jre класс в этот папка становиться доступный автоматически без внесение они в classpath (как отмечаться выше они загружаться загрузчик расширение при старт jvm); задать для весь jvm системный свойство javasystemclassloader — из командный строка это можно сделать так: java -djavasystemclassloader=имяклассазагрузчик hellowolrd непосредственно заставить весь jvm запускаться с необходимый параметр -djavasystemclassloader как оказаться для это тоже существовать изящный решение — нужно использовать специальный переменный окружение значение который автоматически добавляться к параметр запуск люба jvm в процесс поиск быть найти два переменный который мочь бы отвечать за данный возможность: java_opts и java_tool_options однако ни один из стать не давать чёткий ответ на вопрос в чем же отличие этот два переменных? ответ на данный вопрос быть решить найти опытный путём в ход эксперимент быть установить что по настоящий «волшебной» являться переменный java_tool_options значение который автоматически добавляться к параметр запуск люба запускать hotspot jvm а java_opts — это результат негласный соглашение разработчик различный java приложение данный переменный в явный вид использовать многие скрипт (например startupsh/startupbat для запуск apache tomcat) однако никто не гарантировать что данный переменный быть использовать весь разработчик скрипт итак дело сделать загрузчик скомпилировать и поместить в lib/ext значение переменный окружение java_tool_options задать запускать приложение работать открывать лог и видим… скудный список из десятка класс включая системный и ещё несколько сторонний класс вот тут-то и прийтись вспомнить о необязательность выполнение правило делегирование загрузка а так же заглянуть в исходный код apache ant и tomcat как оказаться в этот приложение использоваться собственный загрузчик класс это с один сторона отчасти и позволить имя обрести свой мощный функционал однако по тем или иной причина разработчик этот продукт решить не придерживаться рекомендовать правило делегирование загрузка и написать они загрузчик далеко не всегда обращаться к свой родитель перед тем как загрузить очередной класс именно поэтому наш системный загрузчик почти ничто не знать о класс загружать tomcat-ом и ant-ом такой образ описать способ не позволять отловить весь требовать класс особенно учитывать разнообразие использовать сервер приложение — кто знать как отнестись к правило делегирование загрузка разработчик использовать заказчик сервер приложение попытка номер два применять инструментация класс порой для решение задача не достаточно один знание или умение иногда для достижение цель необходимый интуиция и чуточку везение сейчас автор уже и не вспомнить в ответ на какой поисковый запрос о загрузчик класс поисковый гигант выдать ссылка на статья о механизм инструментация класс как оказаться данный инструмент предназначить для изменение байт код java класс в время они загрузка (к пример jprofiler с помощь данный механизм встраиваться в класс для замер производительности) стоп что значит в время они загрузки? то есть данный механизм знать о каждый загрузить классе? да знать и как оказаться даже хороший чем загрузчик класс — метод byte[] transform(classloader loader string classname class<?> classbeingredefined protectiondomain protectiondomain byte[] classfilebuffer) интерфейс classfiletransformer вызываться у реализовать он класс-трансформатор при загрузка любой класс этот метод и оказаться тем бутылочный горлышко через который проходить люба загружать класс за исключение совсем небольшой количество системный теперь задача сводиться к следующему: написать свой класс-трансформатор реализовать метод classfiletransformertransform который правда не быть осуществлять никакой трансформация а быть всего лишь записывать имя загрузить класс в файл и снова нужно сделать так чтобы написать мы класс подключаться к любой запускать java приложение исходный код класс-трансформатор представить ниже: package comtest; import javaiofile; import javalanginstrumentinstrumentation; import javalanginstrumentclassfiletransformer; import javasecurityprotectiondomain; import javalanginstrumentillegalclassformatexception; public class loggingclassfiletransformer implements classfiletransformer { public static void premain(string agentarguments instrumentation instrumentation) { instrumentationaddtransformer(new loggingclassfiletransformer()); } /** * данный метод вызываться для любой загрузить класс * @param classname имя загружать класс для запись в лог * @return неизмененный classfilebuffer содержимый байт-код класс */ public byte[] transform(classloader loader string classname class<?> classbeingredefined protectiondomain protectiondomain byte[] classfilebuffer) throws illegalclassformatexception { log(classname); return classfilebuffer; } // сохранять лог в папка lib/ext private static final file logfile = new file(systemgetproperty("javaextdirs")split(filepathseparator)[0]+"/loggingclassfiletransformerlog"); public static synchronized void log(string text) { // запись в файл //  } } здесь необходимый пояснить механизм использование класс-трансформатор чтобы подключить такой класс к приложение мы понадобиться так называть premain класс тот класс содержимый метод public static void premain(string paramstring instrumentation paraminstrumentation) из название метод понятно что он вызываться до вызов метод main в этот момент можно подключить к приложение класс-трансформатор с помощь метод addtransformer интерфейс javalanginstrumentinstrumentation такой образ привести выше класс одновременно являться и класс-трансформатор и premain-класс чтобы данный класс можно быть использовать он необходимый поместить в jar файл манифест который (файл meta-inf/manifestmf) содержимый параметр premain-class указывать на полный имя premain-класс в наш случай premain-class: comtestloggingclassfiletransformer затем необходимый указать полный путь к дать архив с помощь параметр -javaagent при запуск jvm тут мы на помощь снова приходить переменный java_tool_options итак класс написать скомпилировать упаковать вместе с манифест в jar переменный окружение java_tool_options=-javaagent:"путь к loggingclassfiletransformerjar" задать приложение запустить лог собранный profit! upd3 хабраюзер grossws предложить ещё один способ использовать инструментация — aspectj: «актуальный если надо дёшево инструментировать весь класс в свой часть приложение не затрагивать окружение но это немного другой задача» upd путь три простой как лом спасибо хабраюзер spiff и apangin который в личка напомнить про ещё один способ который быть я испробовать но быть незаслуженно забытый тк в конечный итог не подойти данный способ основать на запуск jvm с параметр -verbose:class или --xx:+traceclassloading при использование любой из этот параметр в стандартный поток вывод jvm сыпаться сообщение вид [loaded javautildate from shared objects file] однако у данный способ несмотря на он простота есть один существенный недостаток — сложно контролировать формат выводить сообщение а так же направление вывод а рассматривать приложение и без тот выводить достаточно отладочный информация в stdout и возможность отфильтровать из это поток нужный сообщение и перенаправить они в отдельный файл для весь экземпляр jvm запускать на сервер представляться весьма проблематичный upd2 хабраюзер apangin данный способ быть допилить до следующий вариант запуск jvm: java -xx:+traceclassloading -xx:+unlockdiagnosticvmoptions -xx:+logvmoutput -xx:logfile=java_*log -xx:-displayvmoutput helloworld вместо * автоматически подставиться pid после запуск такой команда сформироваться файл с имя например java_580log примерно следующий содержания: <?xml version='10' encoding='utf-8'?> <hotspot_log version='160 1' process='580' time_ms='1334248301214'> <vm_version> <name> java hotspot(tm) client vm </name> <release> 206-b01 </release> <info> java hotspot(tm) client vm (206-b01) for windows-x86 jre (160_31-b05) built on feb 3 2012 18:44:09 by "java_re" with ms vc++ 71 (vs2003) </info> </vm_version> <vm_arguments> <args> -xx:+traceclassloading -xx:+unlockdiagnosticvmoptions -xx:+logvmoutput -xx:logfile=java_*log -xx:-displayvmoutput </args> <command> test </command> <launcher> sun_standard </launcher> <properties> javavmspecificationname=java virtual machine specification javavmversion=206-b01 javavmname=java hotspot(tm) client vm javavminfo=mixed mode sharing javaextdirs=c:\program files\java\jre6\lib\ext;c:\windows\sun\java\lib\ext javaendorseddirs=c:\program files\java\jre6\lib\endorsed sunbootlibrarypath=c:\program files\java\jre6\bin javalibrarypath=c:\windows\system32;c:\windows\sun\java\bin;c:\windows\system32;c:\windows;c:\program files\pc connectivity solution\;c:\program files\rockwell software\rscommon;c:\windows\system32;c:\windows;c:\windows\system32\wbem;c:\program files\java\jdk160_06\bin;c:\hibernate;c:\windows\system32\windowspowershell\v10;c:\program files\tortoisesvn\bin;c:\program files\nmap;;c:\progra~1\common~1\muveet~1\030625;c:\progra~1\common~1\muveet~1\030625; javahome=c:\program files\java\jre6 javaclasspath= sunbootclasspath=c:\program files\java\jre6\lib\resourcesjar;c:\program files\java\jre6\lib\rtjar;c:\program files\java\jre6\lib\sunrsasignjar;c:\program files\java\jre6\lib\jssejar;c:\program files\java\jre6\lib\jcejar;c:\program files\java\jre6\lib\charsetsjar;c:\program files\java\jre6\lib\modules\jdkbootjar;c:\program files\java\jre6\classes javavmspecificationvendor=sun microsystems inc javavmspecificationversion=10 javavmvendor=sun microsystems inc sunjavacommand=test sunjavalauncher=sun_standard </properties> </vm_arguments> <tty> <writer thread='1504'/> [loaded javalangobject from shared objects file]  <writer thread='3092'/> <destroy_vm stamp='0281'/> <tty_done stamp='0283'/> </tty> <hotspot_log_done stamp='0283'/> </hotspot_log> в стандартный поток вывод при это ничто новое не писаться благодаря опция -xx:-displayvmoutput главное достоинство данный способ являться он простота не факт что такой формат файл подойти бы заказчик но это уже вопрос дискуссионный и он не входить в рамка дать статья заключение итак какой вывод можно сделать после окончание работа над проектом: механизм загрузка класс в java — интересный и весьма полезный возможность фреймворка который мочь пригодиться для решение определённый круг задача однако стоить помнить что основный задача который можно решить с помощь данный механизм это именно найти и загрузить класс из место откуда он не мочь загрузить другой для сбор информация о загрузить класс данный механизм мочь быть малопригоден; инструментация класс в java — другой мощный механизм по работа с класс и как раз таки он задача — произвольный работа с класс как с подопытный кролик нужно ли вы получить информация о время работа метод или просто узнать имя только что загрузить класс — данный механизм прийти на помощь; java в целое — открытый и способствовать творчество платформа приложение с открытый исходный код на это (как и на любой друг языке) — полезный не только свой функциональность но и ценный идея который можно почерпнуть изучать на они исходный код да и отсутствие исходный код зачастую не являться проблема для приложение на java существовать много средство позволять отобразить исходный код практически любой скомпилировать java класс с они помощь вы мочь с лёгкость проанализировать код практически любой класс и метод даже из ядро фреймворка (например из файл rtjar) разумеется за исключение нативный метод в работа над это и многий другой проект автор пригодиться бесплатный утилит java decompiler позволять увидеть исходный код практически любой скомпилировать класс java особенно завораживать возможность увидеть тот часть исходный код ядро java который сам написать на java если например открыть файл rtjar лежать в папка lib jre список использовать источник статья о загрузчик класс в java: habrahabrru/post/103830 voitukkievua/2008/01/14/java-plugins blogsoraclecom/vmrobot/entry/%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b_%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b9_%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b8_%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%be%d0%b2_%d0%b2 другой полезный ссылки: stackoverflowcom/questions/3933300/difference-between-java-opts-and-java-tool-options — вопрос о переменный java_opts и java_tool_options; docsoraclecom/javase/142/docs/api/java/lang/classloaderhtml#getsystemclassloader — как переопределить системный загрузчик; wwwsqlru/forum/actualthreadaspx?tid=858652 — именно дать тема натолкнуть на идея о использование instrumentation вместо загрузчик классов; wwwexampledepotcom/egs/javalang/propcmdlinehtml — как установить значение системный свойство java из командный строки; docsoraclecom/javase/142/docs/guide/extensions/spechtml — как получить путь к папка lib/ext; wwwjavalobbyorg/java/forums/t19309html — в статья привести пример простейшее класса-трансформатора; todayjavanet/pub/a/today/2008/04/24/add-logging-at-class-load-time-with-instrumentationhtml — в статья решаться похожий задача по принудительный ведение логово в весь загружать классах; javadecompilerfreefr — домашний страница проект java decompiler wwworaclecom/technetwork/java/javase/tech/vmoptions-jsp-140102html — описание некоторый параметр запуск hotspot jvm q-reduxblogspotcom/2011/01/inspecting-hotspot-jvm-optionshtml — ещё один статья про редко использовать параметр запуск hotspot jvm habrahabrru/post/140133 — статья про особенность загрузчик класс в некоторый сервер приложение 
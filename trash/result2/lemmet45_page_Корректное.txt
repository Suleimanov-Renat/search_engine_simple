корректный получение доступ к default метод интерфейс через рефлексия в java 8 9 10 примечание переводчика: развитие фреймворка cuba порождать большой количество r&d проект в ход один такой проект выясниться что мы нужно вызывать default метод интерфейс из проксить класс наткнуться на очень полезный статья я кажется что опыт изложить в она быть как минимум интересный как максимум — полезный широкий круг разработчик когда дело касаться доступ к default метод интерфейс в java через рефлексия гугление не очень помогать например решение на stackoverflow работать только в определённый ситуация и не на весь версия java в этот статья быть рассмотреть различный подход к вызов default метод интерфейс через рефлексия это мочь быть нужно например при создание прокси-класс tl;dr если вы не терпеться то весь способ вызов default метод описать в этот статья доступный по этот ссылка а также этот проблема уже решить в наш библиотека joor проксирование интерфейс с default метод полезный api javalangreflectproxy существовать достаточно давно с он помощь мы мочь делать клевый штука например: import javalangreflectproxy; public class proxydemo { interface duck { void quack(); } public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { systemoutprintln("quack"); return null; } ); duckquack(); } } этот код просто выводит: quack в это пример мы создать экземпляр проксить который реализовать api интерфейс duck с использование invocationhandler который по суть просто лямбда вызывать для каждый метод интерфейс duck интересный начаться когда мы захотеть добавить реализация метод в интерфейс и делегировать вызов в этот метод: interface duck { default void quack() { systemoutprintln("quack"); } } скорее всего захотеться написать такой код: import javalangreflectproxy; public class proxydemo { interface duck { default void quack() { systemoutprintln("quack"); } } public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { methodinvoke(proxy); return null; } ); duckquack(); } } но это всего лишь сгенерировать длиннющий стек вложить исключение (и это не связать с вызов реализация метод в интерфейс так просто запретить делать): exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source) at proxydemomain(proxydemojava:20) caused by: javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0(native method) at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62) at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) at javalangreflectmethodinvoke(methodjava:498) at proxydemolambda$0(proxydemojava:15)  2 more caused by: javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source)  7 more caused by: javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0(native method) at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62) at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) at javalangreflectmethodinvoke(methodjava:498) at proxydemolambda$0(proxydemojava:15)  8 more caused by: javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source)  13 more caused by: javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0(native method) at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62) at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) at javalangreflectmethodinvoke(methodjava:498) at proxydemolambda$0(proxydemojava:15)  14 more caused by: javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source)  19 more    goes on forever не очень-то полезно использование method handles api так поиск в гугл выдавать мы что нужно использовать methodhandles api ну что давать попробуем! import javalanginvokemethodhandles; import javalangreflectproxy; public class proxydemo { interface duck { default void quack() { systemoutprintln("quack"); } } public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { methodhandles lookup() in(duckclass) unreflectspecial(method duckclass) bindto(proxy) invokewitharguments(); return null; } ); duckquack(); } } круто похоже что заработало! quack … но нет вызов метод интерфейс с не приватный доступ интерфейс из пример выше быть аккуратно сделать так чтобы у вызывающий код к он быть приватный доступ тот интерфейс быть вложить в вызывающий класс а что если у мы есть не вложить интерфейс? import javalanginvokemethodhandles; import javalangreflectproxy; interface duck { default void quack() { systemoutprintln("quack"); } } public class proxydemo { public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { methodhandles lookup() in(duckclass) unreflectspecial(method duckclass) bindto(proxy) invokewitharguments(); return null; } ); duckquack(); } } почти такой же код большой не работать получать исключение illegalaccessexception: exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source) at proxydemomain(proxydemojava:26) caused by: javalangillegalaccessexception: no private access for invokespecial: interface duck from duck/package at javalanginvokemembernamemakeaccessexception(membernamejava:850) at javalanginvokemethodhandles$lookupcheckspecialcaller(methodhandlesjava:1572) at javalanginvokemethodhandles$lookupunreflectspecial(methodhandlesjava:1231) at proxydemolambda$0(proxydemojava:19)  2 more фигня выйти если погуглить ещё можно найти следующий решение который получать доступ к внутренность methodhandleslookup через рефлексия import javalanginvokemethodhandleslookup; import javalangreflectconstructor; import javalangreflectproxy; interface duck { default void quack() { systemoutprintln("quack"); } } public class proxydemo { public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { constructor<lookup> constructor = lookupclass getdeclaredconstructor(classclass); constructorsetaccessible(true); constructornewinstance(duckclass) in(duckclass) unreflectspecial(method duckclass) bindto(proxy) invokewitharguments(); return null; } ); duckquack(); } } и ура мы получаем: quack у мы получиться сделать это на jdk 8 как насчёт jdk 9 или 10? warning: an illegal reflective access operation has occurred warning: illegal reflective access by proxydemo (file:/c:/users/lukas/workspace/playground/target/classes/) to constructor javalanginvokemethodhandles$lookup(javalangclass) warning: please consider reporting this to the maintainers of proxydemo warning: use --illegal-access=warn to enable warnings of further illegal reflective access operations warning: all illegal access operations will be denied in a future release quack опачка это то что происходить по умолчание если мы запустить программа с флаг --illegal-access=deny: java --illegal-access=deny proxydemo ну тогда мы получать (и правильно!): exception in thread "main" javalangreflectinaccessibleobjectexception: unable to make javalanginvokemethodhandles$lookup(javalangclass) accessible: module javabase does not "opens javalanginvoke" to unnamed module @357246de at javabase/javalangreflectaccessibleobjectcheckcansetaccessible(accessibleobjectjava:337) at javabase/javalangreflectaccessibleobjectcheckcansetaccessible(accessibleobjectjava:281) at javabase/javalangreflectconstructorcheckcansetaccessible(constructorjava:192) at javabase/javalangreflectconstructorsetaccessible(constructorjava:185) at proxydemolambda$0(proxydemojava:18) at $proxy0quack(unknown source) at proxydemomain(proxydemojava:28) один из цель проект jigsaw быть как раз именно в тот чтобы не допускать подобный хаковы так а какой решение лучше? это? import javalanginvokemethodhandles; import javalanginvokemethodtype; import javalangreflectproxy; interface duck { default void quack() { systemoutprintln("quack"); } } public class proxydemo { public static void main(string[] a) { duck duck = (duck) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { duckclass } (proxy method args) -> { methodhandleslookup() findspecial( duckclass "quack" methodtypemethodtype( voidclass new class[0]) duckclass) bindto(proxy) invokewitharguments(); return null; } ); duckquack(); } } quack отлично это работать в java 9 и 10 а как насчёт java 8? exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quack(unknown source) at proxydemomain(proxydemojava:25) caused by: javalangillegalaccessexception: no private access for invokespecial: interface duck from proxydemo at javalanginvokemembernamemakeaccessexception(membernamejava:850) at javalanginvokemethodhandles$lookupcheckspecialcaller(methodhandlesjava:1572) at javalanginvokemethodhandles$lookupfindspecial(methodhandlesjava:1002) at proxydemolambda$0(proxydemojava:18)  2 more вы издеваться да? итак у мы есть решение (хак) который работать в java 8 но не в 9 и 10 и есть решение который работать в 9 и 10 но не в 8 более глубокий исследование ну что я только что попробовать запустить разный код на разный jdk следующий класс пробовать весь вышеперечисленный комбинация он также доступный в вид gist здесь компилировать код с использование jdk 9 или 10 (потому что требоваться jdk 9+ api: methodhandlesprivatelookupin()) но компилировать нужно команда указанный ниже чтобы можно быть запустить класс на jdk 8: javac -source 18 -target 18 calldefaultmethodthroughreflectionjava import javalanginvokemethodhandles; import javalanginvokemethodhandleslookup; import javalanginvokemethodtype; import javalangreflectconstructor; import javalangreflectmethod; import javalangreflectproxy; interface privateinaccessible { default void quack() { systemoutprintln(" -> privateinaccessiblequack()"); } } public class calldefaultmethodthroughreflection { interface privateaccessible { default void quack() { systemoutprintln(" -> privateaccessiblequack()"); } } public static void main(string[] args) { systemoutprintln("privateaccessible"); systemoutprintln("-----------------"); systemoutprintln(); proxy(privateaccessibleclass)quack(); systemoutprintln(); systemoutprintln("privateinaccessible"); systemoutprintln("-------------------"); systemoutprintln(); proxy(privateinaccessibleclass)quack(); } private static void quack(lookup lookup class<?> type object proxy) { systemoutprintln("lookupin(type)unreflectspecial()"); try { lookupin(type) unreflectspecial(typegetmethod("quack") type) bindto(proxy) invokewitharguments(); } catch (throwable e) { systemoutprintln(" -> " + egetclass() + ": " + egetmessage()); } systemoutprintln("lookupfindspecial()"); try { lookupfindspecial(type "quack" methodtypemethodtype(voidclass new class[0]) type) bindto(proxy) invokewitharguments(); } catch (throwable e) { systemoutprintln(" -> " + egetclass() + ": " + egetmessage()); } } @suppresswarnings("unchecked") private static <t> t proxy(class<t> type) { return (t) proxynewproxyinstance( threadcurrentthread()getcontextclassloader() new class[] { type } (object proxy method method object[] arguments) -> { systemoutprintln("methodhandleslookup()"); quack(methodhandleslookup() type proxy); try { systemoutprintln(); systemoutprintln("lookup(class)"); constructor<lookup> constructor = lookupclassgetdeclaredconstructor(classclass); constructorsetaccessible(true); constructornewinstance(type); quack(constructornewinstance(type) type proxy); } catch (exception e) { systemoutprintln(" -> " + egetclass() + ": " + egetmessage()); } try { systemoutprintln(); systemoutprintln("methodhandlesprivatelookupin()"); quack(methodhandlesprivatelookupin(type methodhandleslookup()) type proxy); } catch (error e) { systemoutprintln(" -> " + egetclass() + ": " + egetmessage()); } return null; } ); } } вывод вышеприведённый программы: java 8 $ java -version java version "180_141" java(tm) se runtime environment (build 180_141-b15) java hotspot(tm) 64-bit server vm (build 25141-b15 mixed mode) $ java calldefaultmethodthroughreflection privateaccessible ----------------- methodhandleslookup() lookupin(type)unreflectspecial() -> privateaccessiblequack() lookupfindspecial() -> class javalangillegalaccessexception: no private access for invokespecial: interface calldefaultmethodthroughreflection$privateaccessible from calldefaultmethodthroughreflection lookup(class) lookupin(type)unreflectspecial() -> privateaccessiblequack() lookupfindspecial() -> privateaccessiblequack() methodhandlesprivatelookupin() -> class javalangnosuchmethoderror: javalanginvokemethodhandlesprivatelookupin(ljava/lang/class;ljava/lang/invoke/methodhandles$lookup;)ljava/lang/invoke/methodhandles$lookup; privateinaccessible ------------------- methodhandleslookup() lookupin(type)unreflectspecial() -> class javalangillegalaccessexception: no private access for invokespecial: interface privateinaccessible from privateinaccessible/package lookupfindspecial() -> class javalangillegalaccessexception: no private access for invokespecial: interface privateinaccessible from calldefaultmethodthroughreflection lookup(class) lookupin(type)unreflectspecial() -> privateinaccessiblequack() lookupfindspecial() -> privateinaccessiblequack() methodhandlesprivatelookupin() -> class javalangnosuchmethoderror: javalanginvokemethodhandlesprivatelookupin(ljava/lang/class;ljava/lang/invoke/methodhandles$lookup;)ljava/lang/invoke/methodhandles$lookup; java 9 $ java -version java version "904" java(tm) se runtime environment (build 904+11) java hotspot(tm) 64-bit server vm (build 904+11 mixed mode) $ java --illegal-access=deny calldefaultmethodthroughreflection privateaccessible ----------------- methodhandleslookup() lookupin(type)unreflectspecial() -> privateaccessiblequack() lookupfindspecial() -> privateaccessiblequack() lookup(class) -> class javalangreflectinaccessibleobjectexception: unable to make javalanginvokemethodhandles$lookup(javalangclass) accessible: module javabase does not "opens javalanginvoke" to unnamed module @30c7da1e methodhandlesprivatelookupin() lookupin(type)unreflectspecial() -> privateaccessiblequack() lookupfindspecial() -> privateaccessiblequack() privateinaccessible ------------------- methodhandleslookup() lookupin(type)unreflectspecial() -> class javalangillegalaccessexception: no private access for invokespecial: interface privateinaccessible from privateinaccessible/package (unnamed module @30c7da1e) lookupfindspecial() -> privateinaccessiblequack() lookup(class) -> class javalangreflectinaccessibleobjectexception: unable to make javalanginvokemethodhandles$lookup(javalangclass) accessible: module javabase does not "opens javalanginvoke" to unnamed module @30c7da1e methodhandlesprivatelookupin() lookupin(type)unreflectspecial() -> privateinaccessiblequack() lookupfindspecial() -> privateinaccessiblequack() java 10 $ java -version java version "10" 2018-03-20 java(tm) se runtime environment 183 (build 10+46) java hotspot(tm) 64-bit server vm 183 (build 10+46 mixed mode) $ java --illegal-access=deny calldefaultmethodthroughreflection  такой же результат как в java 9 заключение понять весь это немного сложноватый в java 8 хороший рабочий подход – хак который влезать в внутренность jdk через доступ к package-private конструктор класс lookup это единственный способ единообразный вызывать метод интерфейс как с приватный доступ так и с не приватный доступ из любой класс в java 9 и 10 хороший способ — использовать lookupfindspecial() (не работать в java 8) или methodhandlesprivatelookupin() (метод не существовать в java 8) последний подход нужно использовать если интерфейс находиться в друг модула этот модуль должный предоставлять интерфейс для вызов извне честно сказать это немного запутанно подходящий мем для этого: rafael winterhalter (автор bytebuddy) сказать что “настоящий” фикс быть в переработать версия proxy api: переводlukas eder: «ты не знаешь причина тот почему решить большой не разрешать так делать? или просто пропустить это (скорый всего нет)?» rafael winterhalter:«нуть причина это побочный эффект модель безопасность java для класс lookup из methodhandle в идеал в проксить интерфейс должный быть такой lookup предоставлять в вид аргумент (конструктор — прима пер) но это не рассмотреть я безуспешно предлагать похожий расширение для api трансформация файл классов» я не уверенный что это решить весь проблема но нужно действительно сделать так чтобы разработчик не беспокоиться о весь вышесказанный и ясно что этот статья не полный например не тестироваться быть ли этот подход работать если duck импортировать из другой модуля: переводjooq:название и ссылка на статья rafael winterhalter:« ты пробовать поместить duck в модуль который экспортировать но не открывать пакет интерфейса? готовый поспорить что твой решение для java 9+ не заработать если быть использоваться module path» … и это быть тема следующий статья использование joor если вы использовать joor (нашу библиотека для reflection api она тут) то версия 098 быть включать фикс для этого: githubcom/jooq/joor/issues/49 фикс просто использовать подход с хаком reflection api в java 8 или methodhandlesprivatelookupin() для java 9+ можно писать: reflecton(new object())as(privateaccessibleclass)quack(); reflecton(new object())as(privateinaccessibleclass)quack(); 
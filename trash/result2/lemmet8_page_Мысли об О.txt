мысль о ооп очередной статья про «аз программирование на c++» я подтолкнуть к мысль что многие программист не понимать суть объектно-ориентированный программирование (ооп) в частность в этот статья утверждаться что "с++ очень простой в тот смысл что класс с++ повторять описание объект реальный мир " довольно давно на один из форум я наткнуться на рассуждение ещё один программист который хотеть запрограммировать система хранение «универсальных» объект и рассуждать о тот «являться ли стул — объектом» оба этот человек так или иначе заблуждаться насчёт ооп объект в ооп как правило никакой отношение к объект в реальный мир не иметь более тот даже если мы собрать в один место (в записи) набор некоторый характеристика что угодный то это весь равно не быть объект в понимание ооп путаница часто возникать ещё и из-за затаскать слово «объект» да ещё и понятие «класс» и «объект» часто смешивать итак простой правило который позволить легко понять где ооп а где — нет фара и ремень поведение и состояние более развернуть класс объект (в понимание ооп) использовать если… … у некоторый сущность есть поведение зависеть от внутренний состояние этот сущность что значит «у сущность есть состояние»? давать разобраться у экземпляр сущность есть набор собственный дать — это очевидно в чем отличие от обычный запись (структуры)? прежде всего состояние подразумевать что часть дать в сущность использоваться «длить себя» для реализация собственный поведение если сущность «нечего скрывать» то она вырождаться в обыкновенный запись дать более тот понятие «состояния» являться более строгий чем просто «дополнительный набор данных» оно предполагать некоторый связанность взаимозависимость этот внутренний дать состояние мочь быть корректный и некорректный а кто мочь это понять? внешний наблюдатель? нет только сам сущность такой образ состояние скрытый не просто так оно защитить от повреждение некомпетентный пользователь сущность теперь уже проясняться что такой «поведение» сущность это когда сущность реализовать какой-то функционал сохранять корректность состояние давать какой-нибудь простой пример взять есть товар: наименование цена за единица остаток на склад это объект ооп? подумать прежде чем читать далёкий если не накладывать никакой ограничение на он характеристика — нет состояние не возникать мы мочь заносить любой значение скрывать нечего давать ввести ограничение — остаток не мочь быть отрицательный а цена обязать быть положительный а теперь? мочь теперь внешний пользователь произвольно менять дать в товаре? очевидно нет у наш товар появиться поведение — уменьшение остаток означать «забрать товар в определённый количестве» и забрать большой чем остаток — нельзя заметить что произошло? мы ввести ограничение то есть внести некий смысл в природа свойство сущность и сразу же появиться осмыслить поведение — «внести товар» «забрать товар» другой пример предположим в программа требоваться динамический загрузка модуль есть состояние — набор уже загрузить модуль и поведение легко просматриваться — «загрузить модуль» «выгрузить модуль» к что этот пример? к тот что никакой связь с объект в реальный мир здесь и в помин нет связывать природа класс в ооп с природа объект реальный мир — довольно абсурдный и бессмысленный затея природа сущность быть определяться не реальный мир а система и зависеть от окружение сущность от она использование от взаимосвязь компонент вот и весь можно называть это инкапсуляция а можно и не называть можно долго рассуждать на тема наследование а можно просто понять что «наследование» — это способ расширение поведение объект главный — понять что ооп нужно программист чтобы контролировать сложность разработка а не для тот чтобы «отражать объект реальный мира» upd ладный продолжить кидаться умный слово абстракция и полиморфизм не иметь прямой отношение к ооп как ни странно любой процедура или функция являться абстракция любой вот объявление: void sort(int* array int size); этот функция являться абстракция она реализовать сортировка абстрактно мы не знать как но на выход быть отсортировать массив абстракция есть а где тут ооп? нету ооп ни объект ни класс теперь я объявить указатель sort и мочь он присвоить такой функцию: void quick_sort(int* array int size) или такую: void bubble_sort(int* array int size) возникнуть полиморфизм указатель на функция остаться прежний но теперь за один и тем же указатель на функция стоять разный алгоритм а где ооп? ооп нету потому что это даже не c++ это c в который нету класс а абстракция и полиморфизм достигнуть угу? upd2 хм: для ооп не обязательно иметь какой-то там класс ;) брать обычный c делать структура с указатель на функция договариваться один аргумент всегда передавать указатель на this и не обращаться к член структура не являться указатель на функция иначе чем через этот this чем не ооп? в python например нельзя спрятать дать (по крайний мера без особый ухищрений) - он не являться ооп языком? вот именно я как раз о это :-) я же нигде вообще ни строчка ни написать о тот что c++ — это обязательно ооп а весь остальной — якобы нет ооп — это не возможность язык нет! это архитектура приложение способ моделирование предметный область при который использоваться разделение на сущность по принцип описать в статья возможность язык мочь облегчать применение принцип ооп мочь не мешать а мочь усложнять применение этот принцип но принцип от это не меняться я мочь на c++ сделать «плохой» класс который нарушать принцип согласовать изменение состояние а мочь на c или на питон реализовать «правильный» ооп или даже на ассемблер я выделить сущность и не позволить изменять они состояние извне основный мысль мой статья не о возможность компилятор а о ситуация когда программист использовать ооп размышлять — «нужный тут класс (объектов) или не нужен» если есть состояние с поведение — нужный иначе — не нужный как он быть реализовывать это на свой инструмент программирование — я не важный 
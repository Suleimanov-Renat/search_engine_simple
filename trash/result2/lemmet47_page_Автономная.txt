автономный кроссплатформенный монолитный программа на java я любить desktop-приложение признаваться в это нынче похоже стыдный чем в связь с иностранный разведка но это так нет это не значит что я не любить интернетом-технология более тот некоторый я не только уважать а даже более-менее знать но тем не менее я скучать по тем время когда программа писаться на один компьютер потом компилироваться и запускаться на другой разный компьютер тогда везде (почти) быть один система — windows с один и тот же api почти не быть проблема совместимость на уровень приложение никто не материть разработчик браузер — весь беречь нерв на разработчик winapi который умудряться создавать конфликт даже внутри нея один но это я конечно иронизировать а если серьёзно — иногда и сейчас хотеться написать просто desktop-приложение да так чтобы работать оно на весь популярный система трудно? если подумать и покопать то не очень ещё я любить язык высокий уровень с аккуратный архитектура и строгий типизация мой фаворит — java и c# оба они предоставлять разработчик множество преимущество по сравнение с c++ оба избавлять от ряд забота чем приходиться платить? тем что таскать за себя тяжёлый колода который называться oracle jvm net или mono весь три колода весить сотня мегабайт и лицензия иметь такой что каждый пользователь вынужденный качать этот штука сам не путать при это разрядность свой компьютер а главный — программа на java не мочь быть совместимый с весь версия jvm разом не так ли? и вот — мы приходить к тот что просто скинуть программка друг (ить миллион друзей) и не заботиться о тот что она у он не запуститься не выходить приходиться делать хитрый сетапа вбивать костыль и это я ещё не упомянуть net — однажды я видеть у друг сразу 3 установленный версия причём весь три быть нужный разный приложениям… стоп! а давать написать программа на java но так чтобы она не требовать установка на машина какой-либо jvm чтобы один касание собираться под windows linux и os x и чтобы при это занимать совсем чуть-чуть; так чтобы никто даже не понять что она написать скажем не на c невозможно? совсем наоборот! (и нет я иметь в вид не gcj который лишать java весь она прелесть рефлексия быть работать и даже сторонний jar вы смочь запускать) разумеется я не волшебник я только найти один волшебный артефакт называться он avian лежать по адрес ossreadytalkcom/avian и представлять себя легковесный но полноценный сторонний реализация jvm о который oracle возможно даже не слышать он поддерживать куча платформа и архитектура иметь лицензия «брать и делать что хочешь» и — нет я не иметь ни маленький отношение к это проект я даже не контрибьютор я только научиться имя пользоваться и хотеть поделиться это могучий знание с уважаемый обитатель хабра стоить также отметить что он являться jit-компилятор то есть иметь конкурентно-высокий производительность (хотеть я пока что не измерять ее) avian можно встроить в ваш приложение вместе с он весьма урезанный но терпимый по функционал стандартный библиотека класс причём «потяжелеет» программа всего только на мегабайт с гак давать собрать такой программа вместе 0 среда для построение мы прежде всего понадобиться утилит командный строка unix-разработчик в частность — компилятор g++ тут сложный всего прийтись windows-пользователь ранний я под windows использовать mingw32 с она замечательный среда msys эмулировать unix-терминал компилятор входящая в mingw32 32-битный что в некоторый род ограничивать получить программа в комментарий я подсказать что уже давно существовать удобный mingw-w64 который регулярно обновляться и в который есть не только msys но даже и git здесь и далее я спрятать платформозависить инструкция под спойлер для удобство windowsчтоба скачать mingw идти на sourceforgenet/projects/mingwbuilds и там скачивать два архива: x64-xxx-release-posix-seh-revx7z и external-binary-packages/msys+7za+wget+svn+git+mercurial+cvs-revx7z после тот как они скачать распаковывать оба из они в удобный мы директория далее необходимый указать среда msys где находиться mingw для это идти в msys/etc и там в файл fstab прописывать путь к /mingw так как это показать в файл fstabsample у я получиться вот так: c:/mingw64 /mingw после установка всего перечисленный вы открывать терминал msys для это необходимый запустить файл msys\msysbat (ряд с он лежать два иконки) весь дальнейший действие мы быть делать из это терминал так как он во-первых поддерживать формат unix-команда и unix-путь а во-вторых в немой прописать весь необходимый параметр окружение os xпод os x вы прийтись скачать xcode 4 и в он настройка в раздел downloads установить command line tools затем вы просто открывать окно терминал через launcher linuxть linux основать на debian просто открыть терминал и пишем: > sudo apt-get install build-essential после это необходимый закрыть окно терминал и открыть он снова чтобы загрузиться новое параметр среда итог в каждый операционный система должный быть то что вы вводить в командный строка > g++ и в ответ видеть что-то вроде g++: fatal error: no input files такой сообщение означать что компилятор готовый к бой и жаждать получить исходный файл 1 avian для начало предложить наш g++ собрать avian открываем: ossreadytalkcom/avian выбирать ссылка status на открыться страница скачивать avian 06 несмотря на скромный номер версия программа совершенно стабильный (во всякий случай я ни раз не удаться уронить она а в они багтрекер значиться весьма заковыристый баг означать высокий стабильность тот что есть) распаковать исходник avian скачать мы в некоторый папка (пусть это быть ~/projects) > cd ~/projects под windows папка "~" в среда msys присоединяться не к домашний папка пользователь а к папка c:\mingw64\msys\home\username в наш случай раз мы хотеть максимально дистанцироваться от платформа это даже преимущество допустить скачать архив называться avian-06tarbz2 и лежать в ~/downloads тогда распаковывать он в текущий папка набрать > tar -xjf ~/downloads/avian-06tarbz2 в windows путь необходимый указывать в формат mingw с прямая слёша в вид /c/users/username/downloads/avian-06tarbz2 разумеется вы мочь воспользоваться один из сто альтернативный способ распаковать архив — главный чтобы он попасть в текущий папка в итог в она появиться распаковать из архив подпапка avian зайти в нее: > cd avian теперь можно попробовать запустить команда make но если запустить сборка прямо сейчас скорее всего мы получить сообщение о тот что не найти zlib что-нибудь вроде zlibh: no such file or directory windowsпод windows прийтись слегка попотеть и воспользоваться метод предложить автор avian а именно — подсунуть библиотека zlib из они специальный вспомогательный репозитарий win64 для это вы потребоваться установленный в система git к счастие git входить в установленный мы сборка msys к сожаление на момент написание этот статья сборка сделать кривой — в она не хватать файл msys-crypto-098dll который прийтись найти в google и положить ряд с он бесполезный брат msys-crypto-100dll который этот сборка укомплектовать далее необходимый из папка avian выполнить команда > git clone git://ossreadytalkcom/win64git /win64 который положить ряд с папка avian папка win64 с весь библиотека который мочь понадобиться avian-у в частность с zlib os xпод os x насколько я помнить этот библиотека устанавливаться автоматически (возможный с инструментарий разработчик который мы уже поставили) linuxпод linux этот проблема решаться простой > sudo apt-get install zlib1g-dev однако установить zlib и снова набрать make мы получить ещё один ошибка — сборщик avian не находить программа /bin/javac java-разработчик вероятно узнать этот программа — это компилятор java так как avian — только виртуальный машина компилятор мы по-прежнему использовать официальный — от oracle при сборка самый vm он нужный для тот чтобы собрать из исходный java-файл класс маленькая стандартный библиотека avian такой например как system arraylist или hashmap соответственно на машина разработчик весь равно должный стоять jdk — как при сборка avian так и при сборка приложение который быть он использовать причём ставить желательно jdk7 с который совместимый avian 06 пользователь ваш приложение она как и jre быть уже не нужный (собственно ради это и стараемся) windowsть windows идти на сайт oracle и качать нужный дистрибутив а затем устанавливать os xв os x как и в windows идти на сайт oracle и качать нужный дистрибутив а затем устанавливать linuxть linux обходиться привычный мантра > sudo apt-get install openjdk-7-jdk (возможный в ваш дистрибутив не быть openjdk или пакет быть называться как-то иначе но linux есть linux — искать и обрящете) для тот чтобы увидеть куда вы только что положить ваш java-окружение для разработчик make читать переменный среда java_home который мы сейчас надо правильно задать этот же самый переменный с тем же значение потребоваться мы впоследствии для тот чтобы собирать наш собственный проект windowsваш путь в mingw под windows скорее всего быть что-то вроде /c/program\ files/java/jdk170_07/ (вы он указывать при установка jdk7) os xпод os x ваш jdk7 установиться в /library/java/javavirtualmachines/jdk170_17jdk/contents/home linux я в linux это выглядеть так: > update-java-alternatives -l java-170-openjdk-amd64 1071 /usr/lib/jvm/java-170-openjdk-amd64 > export java_home=/usr/lib/jvm/java-170-openjdk-amd64 и вот наконец звёздный час — мы собирать avian: > make если вы весь проделать правильно вы увидеть последовательность строчка вид compiling build/<имя_вашей_платформы>/<кака-то файл> а затем linking build/<имя_вашей_платформы>/<кака-то файл> по окончание сборочный процесс мы получить много файл в папка build/<имя_вашей_платформы> но заинтересовать мы отсюда только: classpathjar — тот самый маленький библиотека базовый класс который вы быть использовать в свой программа существовать возможность собрать avian с использование библиотека openjdk но во-первых как я понимать у нея менее добрый лицензия а во-вторых она существенно тяжёлый binarytoobject(exe) — необходимый для встраивание avian в ваш приложение утилит назначение который быть раскрытый поздний libaviana — самый главный файл это и есть собственно встраивать виртуальный машина у я он занимать аж 23 мегабайт но не пугаться он заметно похудеть после некоторый несложный и что важный совершенно безвредный и автоматический манипуляция быть который также быть раскрытый поздний 2 кроссплатформенный независимый монолитный привет на java мы скомпилировать весь необходимый сторонний код теперь заняться создание свой собственный задача в тот чтобы сделать программа который быть написать на java который при это быть содержимый как можно маленький платформозависить закладка и который быть собираться в один exe-файл не требовать специальный установка сам по себя и работать на люба «чистой» система без установка какой-либо зависимость 21 немного про jni начать пожалуй с теория обсудить как jvm взаимодействовать с система любой виртуальный машина создаваться в один очередь для тот чтобы абстрагироваться от внешний среда поэтому неудивительно что самый узкий место в реализация vm являться как раз вызов системный функция современный программа не мочь даже «чихнуть» без участие ос читать/писать на диск — системный функция вывод текст в консоль — системный функция нарисовать окошко на экран — а вы сам как думаете? фактически единственный что приложение мочь делать «внутри себя» — это расчёт и принятие решение именно этот действие — арифметика и логика — являться функция vm как только надо сделать что-то ещё она звать внешний среда но как? в случай java для это существовать jni (java native interface) быть он весьма простой программа написать на java содержимый в себя заголовок функция пометить модификатор native например package packagename; { class classname { void native foo(); } } такой функция пониматься компилятор java как функция вызывать из загрузить библиотека обычный (не виртуального) код в один из этот библиотека должный быть что-то тип extern "c" jniexport void jnicall java_packagename_classname_foo(jnienv * env jobject caller) { … } при вызов в java-код функция foo() мы фактически вызывать функция из native-библиотека передать она указатель на среда jnienv — объект позволять «общаться» с дать и код внутри vm и указатель на объект из который вызвать функция — jobject caller (ести бы функция быть статический вместо дескриптор объект здесь бы быть дескриптор класс jclass caller_class) человек хорошо знакомый с java но не изучать jni можно объяснить этот принцип взаимодействие так: jni позволять внешний native-код выполнять рефлексия над программа на java если хотеть изучить этот технология дробный милость просить в специальный раздел на официальный сайт oracle 22 jni «наборот» зачем быть весь этот ликбез? затем что в данный момент перед мы стоить весьма занятный почти обратный задача мы надо запустить native-исполняемый файл который быть статически слинкованый с библиотека libaviana быть содержимый jvm прямо внутри себя помимо это он быть содержимый внутри себя весь необходимый java-класс включая и «точка входа» — класс вид class application { public static void main(string args) { … } } звучать это весь довольно пугающе однако задача этот вполне простой необходимый написать довольно несложный код на c который вытащить библиотека класс avian (с добавить в нея наш класс application) изнутри собственный бинарный файл и скормить она jvm вместе с параметр командный строка с помощь весь тот же jni затем мы линковать этот c-файл специальный образ чтобы весь оказаться на свой место и наслаждаться результат 23 новый проект и библиотека сейчас мы притащить и разложить по полочка весь нужный мы для дальнейший работа компонента то что я быть описывать здесь — это мой собственный подход разумеется вы вольный сделать весь иначе так как вы заблагорассудиться но если вы хотеть в итог получить в точность то что я выложить на github (ссылка быть в конце) постараться делать весь в точность создавать папка crossbase где захотеть (я создать она в projects ряд с avian и win32) > mkdir crossbase && cd crossbase внутри создавать подпапка libs > mkdir lib && cd lib внутри создавать подпапка с имя ваш текущий os имя должный быть «linux» «win32» или «osx» > mkdir win-x86_64 && cd win-x86_64 в этот папка необходимый скопировать libaviana который мы собрать ранее у я это выглядеть так: > cp ///avian/build/windows-i386/libaviana / кроме тот в система windows где нет zlib в этот же папка прийтись скопировать ещё и libza: > cp ///win-x86_64/lib/libza / такой образ мы собрать минимум необходимый мы библиотека это хватить для простой программа помимо библиотека мы понадобиться classpathjar который также быть собранный вместе с avian > cd  > mkdir java && cd java > cp ///avian/build/windows-i386/classpathjar / и теперь пришлый время раскрыть назначение таинственный binarytoobject он нужный мы чтобы преобразовать наш jar-файл в специальный объектный файл который затем быть передать линковщик и добавить имя в наш программа так как этот процедура должный выполняться при каждый сборка он тоже надо утащить в наш новый проект > cd / (мы снова в папка crossbase где мы создать lib) > mkdir -p tools/win-x86_64 && cd tools/win-x86_64 имя win-x86_64 назначить внутренний папка по тот же принцип что и в прошлый раз кидать сюда binarytoobject (в windows он разумеется иметь расширение exe) > cp ///avian/build/windows-i386/binarytoobject/binarytoobjectexe / можно запустить он и увидеть usage: usage: c:\users\imizus\projects\crossbase\crossbase\tools\win32\binarytoobjectexe <input file> <output file> <start name> <end name> <platform> <architecture> [<alignment> [{writable|executable}]] 24 код программа а теперь приступить к написание код создать новый исходный файл на c++ (вы мочь воспользоваться любой текстовый редактор какой вы нравиться я использовать eclipse в который можно редактировать и c++ и java в рамка один проект хотя для это он прийтись немного настроить) > mkdir -p src/cpp && cd src/cpp внутри создавать файл maincpp с следующий содержание (привести он целиком а потом объяснить что там к чему): #include <stdinth> #include <stringh> #ifdef __mingw32__ #include <windowsh> #endif #include <jnih> #if (defined __mingw32__) # define export __declspec(dllexport) #else # define export __attribute__ ((visibility("default"))) \ __attribute__ ((used)) #endif #if (! defined __x86_64__) && (defined __mingw32__) # define symbol(x) binary_boot_jar_##x #else # define symbol(x) _binary_boot_jar_##x #endif extern "c" { extern const uint8_t symbol(start)[]; extern const uint8_t symbol(end)[]; export const uint8_t* bootjar(unsigned* size) { *size = symbol(end) - symbol(start); return symbol(start); } } // extern "c" int main(int argc const char** argv) { #ifdef __mingw32__ // for windows: getting command line as a wide string int wac = 0; wchar_t** wav; wav = commandlinetoargvw(getcommandlinew() &wac); #else // for other os: getting command line as a plain string (encoded in utf8) int wac = argc; const char** wav = argv; #endif javavminitargs vmargs; vmargsversion = jni_version_1_2; vmargsnoptions = 1; vmargsignoreunrecognized = jni_true; javavmoption options[vmargsnoptions]; vmargsoptions = options; options[0]optionstring = const_cast<char*>("-xbootclasspath:[bootjar]"); javavm* vm; void* env; jni_createjavavm(&vm &env &vmargs); jnienv* e = static_cast<jnienv*>(env); jclass c = e->findclass("crossbase/application"); if (not e->exceptioncheck()) { jmethodid m = e->getstaticmethodid(c "main" "([ljava/lang/string;)v"); if (not e->exceptioncheck()) { jclass stringclass = e->findclass("java/lang/string"); if (not e->exceptioncheck()) { jobjectarray a = e->newobjectarray(wac - 1 stringclass 0); if (not e->exceptioncheck()) { for (int i = 1; i < wac; ++i) { #ifdef __mingw32__ // for windows: sending wide string to java int arglen = wcslen(wav[i]); jstring arg = e->newstring((jchar*) (wav[i]) arglen); #else // for other os: sending utf8-encoded string to java int arglen = strlen(wav[i]); jstring arg = e->newstringutf((char*) (wav[i])); #endif e->setobjectarrayelement(a i - 1 arg); } e->callstaticvoidmethod(c m a); } } } } int exitcode = 0; if (e->exceptioncheck()) { exitcode = -1; e->exceptiondescribe(); } vm->destroyjavavm(); return exitcode; } __mingw32__ — символ препроцессор который (как неожиданно!) автоматически задаваться внутри среда mingw32 он позволять мы отличить windows который как вы думать уже успеть заметить сильно непохожий на весь прочий система в частность только под windows мы понадобиться специальный системный api который мы подключать строка #include <windowsh> на остальной платформа мы обходиться стандартный библиотека posix и ansi c++ зачем понадобится? стать ясно чуть поздний быть просматривать код по порядок #if (defined __mingw32__) # define export __declspec(dllexport) #else # define export __attribute__ ((visibility("default"))) \ __attribute__ ((used)) #endif этот код знак и понятный весь кто писать кроссплатформенный динамический библиотека с использование gcc быть он в тот что в разный операционный система по-разному описываться функция который должный быть экспортировать из библиотека «прич тут динамический библиотека ведь мы же исполняемый файл собираем?» — спросить вы в ответ я напомнить что взаимодействие avian с платформозависить код осуществляться через механизм jni подразумевать вызов функция из библиотека иной слово для ваш java-код исполняемый файл это не только пусковой программа а ещё и динамический библиотека функция следующий часть — это странноватый магия: #if (! defined __x86_64__) && (defined __mingw32__) # define symbol(x) binary_boot_jar_##x #else # define symbol(x) _binary_boot_jar_##x #endif extern "c" { extern const uint8_t symbol(start)[]; extern const uint8_t symbol(end)[]; export const uint8_t* bootjar(unsigned* size) { *size = symbol(end) - symbol(start); return symbol(start); } } // extern "c" давать разобраться мы декларировать некий экспортный функция (посмотреть на extern "c" и директива export который мы только что ввести имя функция — bootjar запомнить это имя и посмотреть что она делать если мысленно разобрать директива препроцессор то увидеть что она вычислять расстояние между некий _binary_boot_jar_start и _binary_boot_jar_end (в mingw32 они не быть иметь подчерк вначале) сам этот символ декларировать как extern то есть они должный подставить линковщик загадочный деятельность не правда ли? на самый дело как мы увидеть ниже весь довольно просто если знаешь что делать так как avian разрабатываться для встраивание он в приложение автор предусмотреть возможность добавление библиотека класс непосредственно в исполняемый файл с последующий она загрузка оттуда для это надо всего лишь преобразовать библиотека в объектный файл да-да я тоже поначалу удивиться но это очень элегантный идея в объектный файл содержимый наш jar когда мы он создать быть декларировать 2 символ указывать на начать (_binary_boot_jar_start) и конец (_binary_boot_jar_end) это jar-файл а функция bootjar быть использовать avian-ом чтобы узнать где он начинаться и какой длина иметь забегать вперёд сказать что имя этот функция передаваться строка options[0]optionstring = const_cast<char*>("-xbootclasspath:[bootjar]"); наконец-то мы дойти до точка вход — функция main в она задача входит: считать строка параметр загрузить avian передать он библиотека класс вызвать функция main из класс crossbaseapplication передать она параметр командный строка красиво вылететь с ошибка если что-либо из вышеперечисленный не удаться поехать с начало фцнкции: #ifdef __mingw32__ // for windows: getting command line as a wide string int wac = 0; wchar_t** wav; wav = commandlinetoargvw(getcommandlinew() &wac); #else // for other os: getting command line as a plain string (encoded in utf8) int wac = argc; const char** wav = argv; #endif здесь как всегда отличиться windows когда повсеместно быть принять решение переходить от старое неудобный однобайтный кодировка к более сложный весь ос переслать к удобный utf-8 а любимый детище microsoft перейти на фиксировать двухбайтный при это они вообще не позаботиться о тот какой кодировка использоваться например в имя файл но кодировка мы сейчас тоже не очень заботить мы надо передать строка параметр в java (в который тоже принять двухбайтный char) поэтому для windows мы вызывать api-функция (ради который мы и тащить windowsh) который выдать мы строка параметр в правильный двухбайтный кодировка так мы получить возможность например открывать файл с кириллица в название в весь прочий система мы просто читаемый параметр из аргумент функция main далее следовать создание виртуальный машина java: javavminitargs vmargs; vmargsversion = jni_version_1_2; vmargsnoptions = 1; vmargsignoreunrecognized = jni_true; javavmoption options[vmargsnoptions]; vmargsoptions = options; options[0]optionstring = const_cast<char*>("-xbootclasspath:[bootjar]"); javavm* vm; void* env; jni_createjavavm(&vm &env &vmargs); jnienv* e = static_cast<jnienv*>(env); ещё мы вытаскивать указатель на объект jnienv который быть использовать чтобы командовать только что создать java-машина дальнейший код читаться как стихнуть маяковский если только немного знать jni jclass c = e->findclass("crossbase/application"); if (not e->exceptioncheck()) { jmethodid m = e->getstaticmethodid(c "main" "([ljava/lang/string;)v"); if (not e->exceptioncheck()) { jclass stringclass = e->findclass("java/lang/string"); if (not e->exceptioncheck()) { jobjectarray a = e->newobjectarray(wac - 1 stringclass 0); if (not e->exceptioncheck()) { for (int i = 1; i < wac; ++i) { #ifdef __mingw32__ // for windows: sending wide string to java int arglen = wcslen(wav[i]); jstring arg = e->newstring((jchar*) (wav[i]) arglen); #else // for other os: sending utf8-encoded string to java int arglen = strlen(wav[i]); jstring arg = e->newstringutf((char*) (wav[i])); #endif e->setobjectarrayelement(a i - 1 arg); } e->callstaticvoidmethod(c m a); } } } } int exitcode = 0; if (e->exceptioncheck()) { exitcode = -1; e->exceptiondescribe(); } взять класс crossbase/application если смочь найти в немой статический метод main с сигнатура ([ljava/lang/string;)v если смочь достать из стандартный библиотека класс java/lang/string если смочь создать массив объект это класс (онить и быть параметрами) если смочь то в весь операционный система создавать java-строка из каждый параметр задать в кодировка utf-8 а в windows создавать напрямую использовать двухбайтный представление если мы что-нибудь не смочь выдавать ошибка пользователь вот собственно и весь «пусковой механизм» теперь мы надо создать наш программа на java она как минимум должный содержимый класс crossbaseapplication с метод public static void main(string args) создать в наш папка crossbase/src подпапка java в она — подпапка crossbase (этый — имя пакета) а внутри создать файл applicationjava следующий содержания: package crossbase; public class application { public static void main(string args) { systemoutprintln("this is a crossplatform monolith application with java code inside freedom to java apps!"); for (int i = 0; i < argslength; i++) { systemoutprintln("args[" + i + "] = " + args[i]); } } } если вы хоть немного знаете java то думать комментарий здесь излишний сказать только что в стандартный библиотека класс avian нету средство форматирование строка (которое никто не мешать тихонько утянуть к пример из openjdk) 25 сборка теперь перейти к задача сборка наш проект я использовать make потому что он есть всегда и везде где есть gcc а ещё он достаточно мощный чтобы написать на немой почти любой автоматизированный система сборка нет правда можно по палец перечислить что я не удаваться сделать на make и это едва ли быть жизненно важный вещий наш makefile быть лежать прямо в папка crossbase и выглядеть он быть вот так: uname := $(shell uname) arch := $(shell uname -m) src = src bin = bin obj = obj java_source_path = $(src)/java java_classpath = $(bin)/java cpp_source_path = $(src)/cpp objects = $(obj) debug_optimize = -o3 #-o0 -g ifeq ($(uname) darwin) # os x platform_arch = darwin x86_64 platform_libs = osx-x86_64 platform_general_includes = -i"$(java_home)/include" -i"$(java_home)/include/darwin" platform_general_linker_options = -framework carbon platform_console_option = exe_ext= strip_options=-s -x rdynamic=-rdynamic else ifeq ($(uname) $(arch) linux x86_64) # linux on pc platform_arch = linux x86_64 platform_libs = linux-x86_64 platform_general_includes = -i"$(java_home)/include" -i"$(java_home)/include/linux" platform_general_linker_options = -lpthread -ldl platform_console_option = exe_ext= strip_options=--strip-all rdynamic=-rdynamic else ifeq ($(os) windows_nt) # windows platform_arch = windows x86_64 platform_libs = win-x86_64 platform_general_includes = -i"$(java_home)/include" -i"$(java_home)/include/win32" platform_general_linker_options = -static -lmingw32 -lmingwthrd -lws2_32 -mwindows -static-libgcc -static-libstdc++ platform_console_option = -mconsole exe_ext=exe strip_options=--strip-all rdynamic= endif java_files = $(shell cd $(java_source_path); find  -name \*java | awk '{ sub(/\//"") }; 1') java_classes := $(addprefix $(java_classpath)/$(addsuffix class$(basename $(java_files)))) cpp_files = $(shell cd $(cpp_source_path); find  -name \*cpp | awk '{ sub(/\//"") }; 1') cpp_objects := $(addprefix $(objects)/$(addsuffix o$(basename $(cpp_files)))) all: $(bin)/crossbase $(java_classpath)/%class: $(java_source_path)/%java @echo $(platform_general_includes) if [ ! -d "$(dir $@)" ]; then mkdir -p "$(dir $@)"; fi "$(java_home)/bin/javac" -sourcepath "$(java_source_path)" -classpath "$(java_classpath)" -d "$(java_classpath)" $< $(obj)/%o: $(src)/cpp/%cpp @echo $(platform_general_includes) mkdir -p $(obj) g++ $(debug_optimize) -d_jni_implementation_ -c $(platform_general_includes) $< -o $@ $(bin)/crossbase: $(java_classes) $(cpp_objects) mkdir -p $(bin); @echo $(platform_general_includes) # extracting libavian objects ( \ cd $(obj); \ mkdir -p libavian; \ cd libavian; \ ar x //lib/$(platform_libs)/libaviana; \ ) # making the java class library cp lib/java/classpathjar $(bin)/bootjar; \ ( \ cd $(bin); \ "$(java_home)/bin/jar" u0f bootjar -c java ; \ ) # making an object file from the java class library tools/$(platform_libs)/binarytoobject $(bin)/bootjar $(obj)/bootjaro _binary_boot_jar_start _binary_boot_jar_end $(platform_arch); \ g++ $(rdynamic) $(debug_optimize) -llib/$(platform_libs) $(obj)/bootjaro $(cpp_objects) $(obj)/libavian/*o $(platform_general_linker_options) $(platform_console_option) -lm -lz -o $@ strip $(strip_options) $@$(exe_ext) clean: rm -rf $(obj) rm -rf $(bin) phony: all быть осторожны! не путать табуляция с пробел в make табуляция выделяться команда внутри правило сборка а пробел синтаксический элемент не являться присмотреться немного как он работать единственный более-менее мозгодробительный конструкция — назначение вот этот переменных: java_files = $(shell cd $(java_source_path); find  -name \*java | awk '{ sub(/\//"") }; 1') java_classes := $(addprefix $(java_classpath)/$(addsuffix class$(basename $(java_files)))) cpp_files = $(shell cd $(cpp_source_path); find  -name \*cpp | awk '{ sub(/\//"") }; 1') cpp_objects := $(addprefix $(objects)/$(addsuffix o$(basename $(cpp_files)))) здесь мы с помощь unix-команда find отыскивать весь файл java в папка $(java_source_path) этот файл мы предстоять компилировать далее мы откусывать от они расширение и заменять он на class а пусть заменять на $(java_classpath) получать такой образ имя файл класс который надо получить тот имя цель аналогично мы поступать с файл cpp и o далее в makefile мы видеть следующий правило сборки: $(java_classpath)/%class: $(java_source_path)/%java @echo $(platform_general_includes) if [ ! -d "$(dir $@)" ]; then mkdir -p "$(dir $@)"; fi "$(java_home)/bin/javac" -sourcepath "$(java_source_path)" -classpath "$(java_classpath)" -d "$(java_classpath)" $< $(obj)/%o: $(src)/cpp/%cpp @echo $(platform_general_includes) mkdir -p $(obj) g++ $(debug_optimize) -d_jni_implementation_ -c $(platform_general_includes) $< -o $@ этот правило объяснять как скомпилировать исходный файл в целевой и наконец взглянуть на цель $(bin)/crossbase: $(java_classes) $(cpp_objects)  здесь мы видеть зависимость от весь найти файл то есть makefile написать такой образ чтобы собирать весь java и cpp файл предложить он в правильный папка остальной существенный моменты: -static-libgcc и -static-libstdc++ необходимый в mingw чтобы собирать файл содержимый в себя стандартный библиотека c и c++ в противный случай он быть слинкованый с они динамически и потребовать таскать за себя пара dll -mconsole нужный в система windows чтобы система выдать программа консольный ввод-вывод при запуск этот параметр для gui-приложение надо убрать опция -rdynamic не поддерживаться gcc под windows в сила особенность платформа пробежаться вскользь по основный правило сборка — $(bin)/crossbase: $(java_classes) $(cpp_objects) сперва мы распаковывать весь объектный файл из libaviana чтобы впоследствии передать они линковщик поимённо поведение странный но не бессмысленный в windows это решать какой-то странный проблема с линковка (я не разобраться достаточно хорошо) далее мы брать наш classpathjar добавлять к он наш скомпилировать класс из bin/java и паковать весь вместе в bin/bootjar затем мы вызывать binarytoobject который создавать из наш bootjar объектный файл obj/bootjaro с символ _binary_boot_jar_start и _binary_boot_jar_end (которое мы импортировать в maino) и наконец мы линковать весь это безобразие вместе и наконец выполнять волшебный команда strip в параметр который на этот раз отличиться os x где они не такой как в mingw и в linux назначение команда — выкинуть из исполняемый файл всякий левый символ до она отработка crossbase весить более 9 мегабайт после — менее полтора 3 момент триумф зайти в папка crossbase/bin запускать из консоль наш crossbase передать он параметр > /crossbase привет хабр! this is a crossplatform monolith application with java code inside freedom to java apps! args[0] = привет args[1] = хабр! получиться у мы проект лежать на мой github-е 4 итог и смысл я трудно оценить польза от этот статья если я хотя бы получить за нея инвайта это быть значить что она по крайний мера не безынтересный сказать только что при кажущийся сложность этот метод прекрасно окупаться по сравнение с написание программа скажем на чистый c++ java становиться очень удобный при разрастание проект хотя бы до пара десяток класс даже если быть предельно аккуратный при написание код на c++ весь равно оставаться лазейка для чудовищно сложновылавливать ошибка поэтому управлять код (не требовать суперпроизводительности) я бы весь советовать писать на java код же требовать максимальный скорость можно написать на c++ а затем очень легко и аккуратно обернуть c++ класс java класс возможно я ещё написать как сделать это красиво и не напороться на грабли изначально я планировать сделать в статья глава посвятить добавление к это «бутерброду» кроссплатформенный пользовательский интерфейс swt (того который использоваться в eclipse) но потом решить что она быть слишком уж длинный и увесистый если господин читатель интересно написать о это отдельно благодарить за внимание! ps получить от хабровчанин много отзыв я доработать статья и программа спасибо весь за совет и поправка 
javascript: ооп прототип замыкание «класс» timerjs здравствовать программист начинающий закончить а также весь сочувствовать как известно ничто не познаваться так хорошо как на собственный опыт главный чтобы опыт быть полезный и в продолжение этот простой мысль я хотеть предложить заняться несколько полезный дело сразу: побеседовать на тема «ооп с человеческий лицом» разобраться с прототип в javascript коротко и сердито! вспомнить что «замыкание» это не только ценный мех… удар ток написать на javascript класс timer — этакий планировщик событие для запуск анимация событие любой функция весело провести время! предупреждение! если вы не ждать от статья ничто веселого… то ошибаться человек с пониженный чувство юмор читать… ещё более рекомендуется! ну-с приступим… заметить что на момент написание статья ( привет апокалиптично-гламурный 2012! )настоящий ооп в javascript нет но есть приём который можно реализовать основной принцип объектный ориентировать программирование для тот кто только открывать для себя этот безумно интересный тема я свой слово пояснить характерность данный метод часть 1 ооп с человеческий лицо кратенько: ооп это вовсе не священный мантра а по суть просто методика организация приложение структурирование код централизация метод и объединение сущность в единый иерархический семейство подобно тот как строиться субмарина и самолёт перенимать опыт плавучесть и летучесть из живой природа ооп приложение также использовать восприятие программный сущность как некий «живых» объект перенимать известный мы из реального(offline — помнить о таком?) мир характеристика и свойство другой слово создаваться некий сущность который не только иметь свой свойство и метод но уметь порождать потомок и эволюционировать! это называться расширение – extending словно бережный родитель объект передавать имущество по наследство либо получать опыт поколение быть потомок другой родительский сущность – parent такой образ создаваться единый древо поколение в который удобно ориентироваться и массово управлять в отличие от разрозненный библиотека — процедурный метод как видеть — весь как у людей! с тот разница что разработчик являть себя бог этот система и мочь переноситься по поколение вносить изменение в самый корн либо в отдельный ветвь развитие война и конфликт устраняем! новое знание — добавляем! или наоборот весь ломаем… трудно быть богом! однако сам принцип ооп обязывать разработчик структурировать приложение по правило а не как приспичить что облегчать и систематизировать он поддержка и что впрочем вовсе не мешать при желание запутать код даже в это случае… :) на мой взгляд освоение ооп очень помогать именно такой «человеческое» восприятие принцип например как и в жизнь существовать строгий родитель который заставлять ребёнок уметь что-либо что сам считать нужным! они называть абстрактный класс — abstract помнить как родитель заставлять вы играть на фортепиано или учить стихи? так вот абстрактный класс также как и многие родитель вовсе и знать не знать зачем ребенку-потомок это быть нужно и как он это быть использовать но уверить что так надо! тот такой класс содержимый абстрактный метод который являть себя объявление метод без самый реализация как фантик без конфетка тем самый обязывать потомок этот метод реализовать как и в жизнь где родитель нередко перекладывать на ребёнок свой нереализованный мечты… вот в такой шутливо-серьёзный форма мы затронуть тема абстрактный класс и семейный отношение как способ понять… и то и другое? а если серьёзно то разумеется в программирование не должный быть случайный метод и любой метод и свойство являться частью продумать иерархия класс который как генеалогический дерево мочь давать возможность расширять функционал от поколение к поколение а абстрактный класс и ещё более абстрактный – интерфейс ( interface — вообще не содержимый реализация ) помогать программист не потерять не забыть реализовать общий необходимый для весь потомок умение в жизнь без который особь умереть а с она и приложение кроме шутка с практический сторона при проектирование элемент приложение такой как например товар в магазин объектный представление позволять приблизить они к свойство реальный объект который как и в жизнь инкапсулировать (те содержимый в себе) весь необходимый аттрибуты: цена количество масса срок хранение и прочий необходимый качество но так как и товар мочь быть разный то они классовый модель мочь ветвиться и развиваться наследовать или переопределять общий свойство наследование — пожалуй важный особенность ооп если требоваться новый виток эволюция программист создавать новый класс расширять умение он родитель а иногда и реализовать по новый тот перекрывать метод родитель — override ведь у каждый поколение свой понятие в жизни… если же программист нужный «опыт и понятия» прежний поколение — он обращаться к он ничто не потерять в этот структура поэтому крайне важный уметь она пользоваться и хотя пока для javascript нет полноценный ооп спецификация возможность следовать принцип ооп есть и это удобство мы сейчас быть пользоваться конечно в рамка дать статья мы лишь коснуться основа понимание но как известно – лихо беда начать главный зацепиться… итак наш цель сейчас написать некий управляемый сущность который по таймер быть запускать нужный мы процесс «управляемую» – это значит такой сущность или условно класс быть заключать в себя – как говорят инкапсулировать метод для управление и свойство содержимый необходимый дать пример из жизни: • свойство – это то что объект знает( имя цвета глаз таблица умножение ) • метод – это то что объект умеет( спать есть строить синхрофазотрон ) важно! если читатель ещё не знать что из себя представлять объект в javascript — то рекомендовать предварительно почитать о это в любой справочник иначе быть возникать трудность понимание создание объект быть происходить через функция который вызываться с директива new именно директива new определять что функция этот не обычный вовсе а специальный функция – конструктор который создавать и возвращать некий объект до тот же как она он возвратить мы мочь это объект присвоить весь что душить пожелает: и знание и умение function timer() { /* тут быть кодить дальше… */ }; var timer = new timer(); итак мы создать объект timer класс timer но как творческий человек мы мочь захотеть уже при создание наделить свой объект некоторый свойство или не наделять… тот мы хотеть универсальность чтобы при желание можно быть задать «знание и умения» или нет но объект при это не умереть бы в мука не уметь например дышать… мы же не зверь но как это сделать? для это первое что мы поместить в наш класс — свойство по умолчание который объект принимать бы от природа и блок обработка function timer( options ) { //public var defaultoptions = { delay: 20 //время между вызов таймер в мс каждый вызов - новый кадр stopframe: 0 // конечный кадр loop: true // флаг цикличность процесс frameelementprefixid: 'timer_' // префикс аттрибут id элемент для подсветка-визуализация процесс } for(var option in defaultoptions) this[option] = options && options[option]!==undefined ? options[option] : defaultoptions[option]; /*тут быть кодить дальше… */ }; также в сигнатура функция у мы появиться параметр options это объект вы ведь знаете что такой объект? после комментарий //public у мы тоже объект defaultoptions который содержимый необходимый для жизнедеятельность свойство и за он блок код который перебирать весь свойство defaultoptions по имя проверять передать ли они через options и если нет — ставить значение из defaultoptions для присваивание объект значение мы пользоваться this который указывать на текущий создать внутри функция — конструктора( помнить про new ?) такой образ мы мочь создать наш объект так: var timer = new timer( {delay: 500 loop: false } ); … и указанный свойство быть записать а пропустить — взять из defaultoptions объект спасен! универсальность и гибкость получена! обратить внимание и на комментарий //public разумеется он иметь тут условный значение (как и весь ооп условность в javascript включая понятие класс) но быть он в пометка публичный свойство тот доступный из вне к такой свойство можно обратиться напрямую через объект: alert( timerdelay ); как пример из жизнь это очевидный свойство объект который не нуждаться в сокрытии: длина хвост у кот бывать также личный свойство — private и защитить — protected для доступ к личный если это позволительно вообще нужно использовать специальный метод в который программист определять что и как и кома можно возвращать защитить — protected это чуть менее личный тк доступный и для самый класс и для он наследник в круг «семьи» так сказать делаться это для стабильность приложение ведь не весь сор хороший выносить они избы… давать и мы добавить личный свойство — private делаться это создание внутренний переменный внутри функция такой образ область они видимость ограничиваться (ить иначе — замыкается) самый функция — «никома не сказать если не захочу»! о замыкание мы ещё поговорим… а пока вставлять далёкий в функция timer: //private var busy = false // флаг "занят" или "процесс идет!" currenttime = 0 // текущий время frame = 1 // текущий кадр task = {} // о! важно! в этот объект быть помещать список задача для выполнение по кадр keyframes=[] // массив индекс ключевой кадр тот тот в который поместить задача ; /*тут быть кодить дальше… */ к такой свойство если захотеть мы позволить обращаться через публичный метод как: thisgetkeyframes = function( ) { return keyframes; } обратить внимание что этот метод именно публичный тк через this присвоить свойство объект к который можно потом обратиться через точка (не забыть про скобка на конец если вызывать именно действие ): timergetkeyframes(); если же мы нужный приватный метод то он подобно приватный переменный также создаваться «обычным» объявление внутренний функции: function someprivatemethod() { /* some code */ } получиться служебный функция который конструктор мочь вызвать для личный цель но из создать конструктор объект этот функция быть недоступный тк не являться он свойство повториться в javascript весь это условность который помогать следовать принцип ооп но не всегда обеспечивать точный реализация например с реализация protected в javascript совсем туго! дело в тот что protected частично сочетать в себя свойство и private- для недоступность из объект и public- для доступ из другой класс что в javascript противоречить друг друг так как обеспечиваться область видимость — замыкание как вариант можно создать public метод и внутри он проверять являться ли вызывающий он объект наследник хозяин метод и тп идеальный решение тут нет весь в рамка условность ну вроде с организация доступ чуток разобраться а как насчёт наследование ведь это наиболее важный качество в ооп — способность перенимать и развивать умение и знание свой родителей? и тут мы подходить к важный особенность javascript — прототипный наследование этот тема часто вызывать трудность понимание и далее я сделать свой попытка «объяснить весь раз и навсегда» простой человечёкий язык часть 2 прототип в javascript итак в javascript существовать понятие прототип скрытый ссылка [[prototype]] объект она же __proto__ и свойство prototype функция чтобы перестать путаться в этот понятие разобрать они по одному: прототип текущий объект называть некий другой объект из который текущий объект черпать недоставать метод и свойство скрытый ссылка [[prototype]] указывать на прототип текущий объект и по спецификация недоступный для разработка но в некоторый браузер нарущать спецификация она открытый как свойство объект __proto__ что впрочем не давать смысл она пользоваться на прямая тк это не кроссбраузёрный и не корректно prototype — это свойство функции! повторять именно функция который использовать для передача значение ссылка [[prototype]] создавать объект люба уважать себя javascript-объект иметь скрытый ссылка [[prototype]] который связывать он с родительский по замысел объект который в свой очередь с свой и тд наверху весь этот цепочка заседать встроить объект javascript этакий верховный прародитель объектный адам иметь весь необходимый встроить метод такой как tostring valueof hasownproperty и тд благодаря это весь объект потомок тоже иметь этот минимально необходимый набор метод позволять выжить в непростой среда javascript объект_потомок2--[[prototype]]--> объект_потомок1--[[prototype]]-->… { tostring:  valueof:  hasownproperty: … } тот даже если просто создать пустой объект var obj = {} не иметь метод и свойство и обратиться к стандарный метод то по цепочка ссылка [[prototype]] ( в дать случай минимально короткий цепочка ) он взять этот метод из встроить объект javascript: var obj = {}; //пустой объект objtostring(); // вызывать метод и получать строка "[object object]" так реализоваться прототипный наследование в javascript — через цепочка ссылка [[prototype]] весь свойство доступный по цепочка прототип быть открытый потомок как кладезь знание и умение что позволять выстраивать настоящее эволюционировать древо классов! обратить внимание что прототипный свойство каждый объект храниться не в немой самый а как бы в промежуточный звено цепочка прототип между текущий объект и встроить объект javascript «в начало времен» этот корнев объект требовать уважение и нарушать он покоить не совсем прилично поэтому для создание собственный прототипный свойство хороший создавать и встраивать в цепочка собственный же объект с ссылка [[prototype]] но как мы помнить [[prototype]] — ссылка закрытый как же мы выстроить свой цепочка не иметь к она доступа? тут мы помогать уже знакомый функция-конструктор с ключевой слово new и свойство prototype который вполне себя открытый дело в тот что объект создавать через конструктор получать ссылка [[prototype]] с значение указанный в свойство prototype это конструктора! изначально любой функция иметь в свой свойство prototype ссылка на почти пустой объект(с единственный свойство constructor указывать обратно на сам функцию) сама_функцияprototype --> { constructor: --> сама_функция } но мы мочь заменить свойство prototype передавать свой родительский класс тот создавать функция-конструктор мы просто присвоить в она свойство prototype ссылка на объект с нужный мы свойство и новый создавать объект получить ссылка [[prototype]] на этот объект с нужный мы свойство // функция конструктор "класса" var foo = function() {}; //передавать свойство prototype объект с свойство и метод fooprototype = { hi: 'hello!' sayhi: function(){ alert( thishi ) } }; // создавать экземпляр "класса" var obj = new foo(); // вызывать метод наследовать из прототип objsayhi(); в пример выше скрытый ссылка [[prototype]] объект obj получать указатель на некий объект иметь свойство hi и метод sayhi такой образ объект obj наследовать это знание и умение для упрощение этот процедура придумать функция function extend(child parent) { var f = function() { } fprototype = parentprototype childprototype = new f() childprototypeconstructor = child childsuperclass = parentprototype } пример она использование смотреть на javascriptru javascriptru/tutorial/object/inheritance#svoystvo-prototype-i-prototip она принимать в агрумент два функция-конструктор — потомок и родитель и делать то что мы уже затронули: создавать служебный функция для передача прототип записывать в она prototype-свойство prototype функция родитель передавать свойство prototype потомок промежуточный объект новое звено цепочка с ссылка [[prototype]] на prototype родитель записывать в constructor функция child( вместо исходный конструктор служебный f ) записывать в свойство superclass ссылка на родитель на случай возможность обращение к он конструктор и другой исходный метод если они быть переопределить в потомок мочь возникнуть вопрос зачем нужный один три строка почему бы сразу не сделать присвоение childprototype = parentprototype без всякий new f() и дело с концом?! дело в тот что при такой присвоение не быть создать новое промежуточный звено в цепочка наследования! в childprototype записаться parentprototype а не промежуточный объект -хранилище с дальнейший ссылка на parentprototype и при попытка записать что либо в childprototype мы грубо ворваться на территория parent нарушать уважение к старший и приемственность поколение вызывать конструктор new f() мы создавать для child свой собственный область хранение прототипный знание который он смочь передать потомок добавлять отдельный свойство в прототип конструктор можно ещё и так: childprototypesomeproperty = "someproperty"; и кстати не нужно пытаться обращаться к prototype как к свойство объект — экземпляр класс у объект нет свойство prototype есть скрытый ссылка [[prototype]] а свойство prototype — нет! он конечно можно создать но толк от он в наследование никакой толк есть только от свойство prototype функция-конструктор благодаря она способность передавать указатель в ссылка [[prototype]] создавать объект вот и весь что касаться прототипный наследование правда просто? но прототипный наследование не единственно возможный схема хотеть упомянуть также и метод вызов конструктор суперкласс тот класс родитель не даром же мы позаботиться о он запись в свойство прототип ( сантиметр function extend ) в конструктор timer наш забытый пример мы присваивать объект некоторый свойство через this чтобы передать этот свойство последующий поколение надо в конструктор потомок сделать вызов родительский конструктор в контекст потомок те: function timerplayer() { timerplayersuperclassconstructorapply( this arguments ); } здесь важный помнить что нельзя вызывать через thissuperclassconstructorapply а именно через имя текущий конструктора( тут timerplayer) потому что иначе если родительский конструктор тоже использовать this и вызывать thissuperclassconstructorapply(this arguments) то это превратиться в замкнутый вызов apply в контекст this как потомок что вызвать ошибка вызов родительский конструктор в контекст потомок создать и присвоить потомок весь он свойство и метод причём приватный свойство родитель объявить через var а не через this мочь быть доступный только при наличие позволять они прочитать родительский публичный метод именно это путём мы и продолжать строить наш timer часть 3 javascript-класс timer и он наследие итак у мы уже есть класс что-то знающий но ничто не уметь так что пора добавить он умений! что мы желать научить наш класс? сделать что-то вроде плеера: • start • pause • stop • rewind • settoframe и некоторый менее важный метод представимый что мы они уже написали… итак вставлять далёкий в функция timer: thisstart = function(){ /* старт */ if( busy ) return; if( windowconsole ) consolelog ('start: currenttime='+currenttime+'; frame='+frame); busy = true; timercall( this ); } thispause = function() { /* пауза */ if( windowconsole ) consolelog ('pause: currenttime='+currenttime+'; frame='+frame); clearinterval( thisintervalid ); busy = false; } thisstop = function() { /* стоп */ if( windowconsole ) consolelog ('stop: currenttime='+currenttime+'; frame='+frame); clearinterval( thisintervalid ); busy = false; currenttime = 0; frame = 1; thisclearframeline(); } /* highlighting - визуализация таймер */ thisclearframeline = function() { /* очистка линия кадр */ for(var i=1 str=''; i<thisstopframe+1; i++) if( elfr = documentgetelementbyid( thisframeelementprefixid+i ) ) removeclass( elfr 'active'); } thissetactiveframeelement = function( framenumber ){ /* подсветка активный кадр */ if( elfr = documentgetelementbyid( thisframeelementprefixid+framenumber ) ) addclass(elfr 'active'); } thistostring = function() { /* строковый представление например для alert() использовать для отладка */ var str = ''; for(var option in this ) str+= option+': '+( (typeof this[option]=='function') ? 'function' : this[option] )+'\n'; return '{\n'+str+'}'; } thissettask = function( new_task ) { /* присвоение расписание действие объект с список задача по кадр */ task = new_task; thisstopframe = 0; keyframeslength = 0; for(var frind in task) { if( (+thisstopframe)< (+frind) ) thisstopframe=(+frind); keyframespush( +frind ); } } thisgetkeyframes = function( ) { /* получить приватный свойство keyframes */ return keyframes; } thisgettask = function() { /* получить приватный свойство task */ return task; } thissettoframe = function( toframe ) { /* установка в позиция кадр */ if(toframe>thisstopframe) return; frame=toframe; currenttime=(frame-1)*thisdelay; for(var frind in task) { if( (+frind)>(+toframe) ) break; var tasklist = task[ frind ]; for(var i=0; i<tasklistlength; i++ ){ var taskitem; if( taskitem = tasklist[i] )taskitemrun(); } } thisclearframeline(); thissetactiveframeelement( toframe ); } thisrewind = function( amount ) { /* перемотка! а какже! у мы считать плеер получаться :))))))))) */ if( amount<0 && thisintervalid ) amount--;/* поправка на работа setinterval */ var toframe = frame+amount; toframe = mathmax( mathmin( toframe thisstopframe) 1); thissettoframe(toframe); } function timer(){ /* приватный функция вызов setinterval который запускать задача из список */ var this_ = this; /* сохранять ссылка на контекст наш объект в переменный */ thisintervalid = setinterval( function() { /* функция который вызывать setinterval через промежуток время thisdelay */ //consolelog ('currenttime='+currenttime+'; frame='+frame+';'+task); if( task[ frame ] ) { /* проверять если ли задача для текущий кадр если есть */ var tasklist = task[ frame ] /*  забирать в задача-массив в переменный */ for(var i=0; i<tasklistlength; i++ ){ /* и перебирать элемент массив - сам объект иметь свойство-функция run */ var taskitem; if( taskitem = tasklist[i] ) taskitemrun(); /*  который мы и запускать */ } } /* highlighting */ this_setactiveframeelement( frame ); /* подсветка кадр */ currenttime+=this_delay; /* передвигать значение текущий время кадр */ frame++; if( this_stopframe && frame>this_stopframe ) { /* если stopframe не ноль и мы достигнуть он  */ if( this_loop ) this_settoframe( 1 ); /* если стоить свойство - цикличность то переходить в начать на один кадр и продожать */ else this_stop(); /* а иначе стоп! */ } } thisdelay ); } весь с конструктор покончить в целое думать весь понятно: нужный метод старт? писать публичный метод старт! где… thisstart = function(){ if( busy ) return; /* выходить если уже стартовать флаг стоит! */ /* это для отладка вывод информация в консоль */ if( windowconsole ) consolelog ('start: currenttime='+currenttime+'; frame='+frame); busy = true; /* ставить флаг что стартовать */ timercall( this ); /* вызывать приватный метод */ } сам функция timer я подробно прокомментировать в целое идея простая: function timer(){ var this_ = this; thisintervalid = setinterval(function() { /* тут весь и делать использовать this_ а не this! */ } thisdelay ); } сперва сохранять ссылка на контекст наш объект в переменный тк внутри функция вызывать в setinterval контекст быть потерянный а переменный остаться в замыкание тот в локальный область видимость возможно для понимание следовать повторить(ить узнать) про замыкание а мы о они ещё поговорить ниже… далее присваивать наш объект свойство intervalid который возвращаться метод setinterval этот идентификатор позволить мы останавливать выполнение setinterval при пауза или стоп смотреть этот метод отдельный разбор требовать свойство task ведь именно там мы в некий вид хранить задача для выполнение структура он такая: { 1:[ { run: function(){} } ] 5:[ {}{}{} /**/ ] /**/ } объект массив объект ой хороший бы не говорить а то сам запутался… но весь просто в объект task под нужный номер кадр содержаться массив заданья-объект с свойство run это свойство надо присвоить функция который и вызваться при нужный кадр при необходимость каждый заданий-объект можно добавить ещё свойство на то он и объект также по надобность можно в массив добавлять новый объект-задание пользоваться стандартный метод массив push unshift splice ну и разумеется самый объект task можно присваивать свойство по номер нужный кадра! такой образ заполнять task и присваивать наш класс метод settask мы определять что и когда он делать как это можно использовать? выполнять различный динамический сценарий на сайт или на клиент оffline создавать анимация создавать «живые» учебный пособие или тест завязать на время напоминать о важный событиях(чайник вкипел!) доставать пользователь всплывать рекламой( мерзкий и гадкий шутка!) или просто выводить часик в угол страницы! более тот у мы уже организоваться простой интерфейс некий маленький api для управление наш таймер и визуализация и сейчас мы он использовать построить панель управление на подобие плеера! вставлять на страница html код любимый и родной: <button onclick="timerrewind(-50);">rewind -50</button> <button onclick="timerstart();">start</button> <button onclick="timerpause();">pause</button> <button onclick="timerstop();">stop</button> <button onclick="timerrewind(+50);">rewind +50</button> на событие onclick кнопочка повесить метод объект timer разумеется перед вызов который объект следовать не забыть создать помнить как? — через функция конструктор: var timer = new timer(); однако не плохо бы теперь и сценарий создать чем управлять а иначе — за что боролись? попробовать создать простой анимация быть перемещать картинка по страница ну своеобразный «hello world» в мир анимация перемещать быть картинка <img id="ball" src="http://wwwsmayliru/data/smiles/transporta-854gif" > напомнить что задача наш таймер вызывать действие какой мы угодный действие при это сам он за это действие не в ответ поэтому что именно делать — это наш задача и мы она сейчас решить написать простенький функция перемещение элемент который передаваться сам элемент по id и два он координаты: function moveelem( elem top left ){ elemstylecsstext = 'position:relative;top:'+top+'px;left:'+left+'px'; } итак теперь этот функция нужно присвоить свойство run объект-задание в массив под номер нужный кадр объект task следить за мыслью? итак создавать объект-сценарий и один он кадр определять как массив в этот кадр мы положим начальный положение элемента-картинки: var frames = {}; /* начальный положение */ frames[1]=[]; frames[1]push( { run: function(){ moveelem( ball 600 600 ); } } ); почему нельзя написать run: moveelem( ball 600 600 )? это неправильно потому что синтаксис… moveelem(); … означать вызов функция а мы она не надо вызывать тут и сейчас а надо поместить в тело свойство-функция run который вызов и сделать а иначе мы бы в run запихать результат выполнить moveelem() — undefined поскольку она ничто не возвращать и картинка наш почём зря дёрнуть бы и вуаля! первое кадр мы добавить действие который помещать наш картинку(воздушный шарик) в некий нижний позиция страница теперь чтобы начать подниматься мы нужно покадровый изменять это состояние тот уменьшать координата top ну и left — с поправка на ветер :) для заполнение нужный кадр использовать цикл при желание кстати можно написать собственный метод класс timer — который бы добавлять кадр и действие и распределять бы изменяться параметр действие по кадрам… а пока для пример заполнить цикл кадр с 2 по 600-ть /* действие */ for(var i=2; i<601; i++) frames[i] = [ { run: function(i){ return function(){ moveelem( ball 600-i 600-i ); } }(i) } ]; здесь надо также обратить внимание на использование замыкание дело в тот что для передача динамический i тут использоваться обертывание в функциональный выражение который вызываться на месте: function(i){ /* сюда передаться текущий i как аргумент функция */ }(i) ; если бы мы просто использовали: run: function(){ moveelem( ball 600-i 600-i ); } то при вызов moveelem() i бы браться из глобальный область видимость тот тот который у мы объявить и отработать в цикл for(var i=2; i<601; i++) тот вызываться бы «отработанная» переменный i равный 600 а вовсе не динамический i который должный постепенно нарастать изменять координата взлетать шарик поэтому мы использовать замыкание на javascript который определять область видимость тот при выполнение функция function(i){ /* сюда передаться текущий i как аргумент функция */ }(i) ; … внутри он создаться свой переменный i как аргумент этот самый функция а вызов на месте( повторить если забыть ) выполнять тело функция где происходить возврат ( return ) уже наш функция и опять же: не return moveelem( ball 600-i 600-i ); а return function(){ moveelem( ball 600-i 600-i ); } потому что в первое случай вернуться не вызов функция а результат вызов moveelem( ball 600-i 600-i ) который выполниться тут же! и вот уже у мы есть сценарий теперь можно он присвоить и запустить: var timer = new timer( ); timersettask( frames ); timerstart(); /* или кнопочка start */ в целое покадровый управление давать обширный возможность для создание интересный и сложный сценарий на дть страница denis-or-lovenarodru/portf/timer я также реализовать пример покадровый линейка наподобие timeline в adobe flash :) — кнопочка drawframeline надо заметить что большой количество элемент на страница мочь сильно тормозить браузер при перерисовка они позиция это хорошо заметно в ненаглядный ie если нажать drawframeline с параметр 1 — каждый кадр при желание можно написать целый интерфейс для создание сценарий с расширять возможность и прочий приятность тут уж как говориться кто в что горазд… а теперь заняться наследованием! построить базовый класс timer мы расширить он создание более продвинуть класс timerplayer ограничить пример продвинутость простой пример — наш дочерний класс принимать навык родительский быть уметь создавать панель управление наш таймер наподобие плеер для это делать три вещи: вызов родительский конструктор добавление новый метод передача наследование через функция extend //дочерний класс function timerplayer( options ) { // вызов родительский конструктор timerplayersuperclassconstructorapply(this arguments); // новый метод thisdrawpanel = function( panelid objname ) { var objname = objname || 'timer'; var template ='<button onclick="'+objname+'rewind(-50);">rewind -50</button>'+ '<button onclick="'+objname+'start();">start</button>'+ '<button onclick="'+objname+'pause();">pause</button>'+ '<button onclick="'+objname+'stop();">stop</button>'+ '<button onclick="'+objname+'rewind(+50);">rewind +50</button>'; documentgetelementbyid( panelid )innerhtml = template; } } //вызов extend extend(timerplayer timer); и хотя здесь у мы не происходить прототипный наследование extend мы нужный для выстраивание цепочка на будущее( а вдруг захотеть добавить прототипный свойство родителю) и для запись superclass и constructor новый метод drawpanel принимать строка id элемент внутри который помещать кнопочка и строка имя объект для подстановка в шаблон html //использовать дочерний класс var timerplayer = new timerplayer(); timerplayersettask( frames2 ); timerplayerdrawpanel( 'controlpanel' 'timerplayer' ); вот мы и закончить а мочь только начать наш класс timer и он потомок я хотеть поблагодарить devote за терпеливый консультация и содействие в написание статья до новый встреча и приятный программирование 
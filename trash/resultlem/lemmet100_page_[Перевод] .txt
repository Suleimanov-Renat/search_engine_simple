[перевод] как работать graal — jit-компилятор jvm на java привет хабра представлять ваш внимание перевод статья "understanding how graal works — a java jit compiler written in java" введение один из причина по который я стать исследователь язык программирование являться то что в большой сообщество человек связанный с компьютерный технология почти весь использовать язык программирование и многие интересоваться тем как они работать когда я впервые столкнуться с программирование быть ребёнок и познакомиться с язык программирование один о чем я хотеть узнать быть то как это работать и самый один что я хотеться сделать быть создание собственный язык в это выступление я показать некоторый механизм работа использовать весь вы язык — java особенность являться то что я быть использовать проект под название graal который реализовать концепция java на java graal являться только один из составлять в работа java — это just-in-time компилятор это тот часть jvm который преобразовать байткод java в машинный код в ход работа программа и являться один из фактор обеспечивать высокий производительность платформа также это как я кажется то что большинство человек считать один из наиболее сложный и туманный часть jvm который находиться вне рамка они понимание изменить это мнение являться цель данный выступление если вы знаете что такой jvm в целое понимать что означать термин байткод и машинный код и способный читать код написать на java то я надеяться это быть достаточно чтобы понять излагать материал я начать с обсуждение тот почему мы мочь хотеть новый jit-компилятор для jvm написать на java а после показать что в это нет чего-то сверх особенный как вы мочь бы думать разбить задача на сборка компилятор использование и демонстрация тот что он код являться такой же как и в любой друг приложение я совсем немного затронуть теория и потом показать как она применяться в ход всего процесс компиляция от байткод до машинный код ещё я показать некоторый деталь и в конец мы поговорить о польза дать возможность помимо реализация java на java ради её самый я быть использовать скриншот код в eclipse вместо они запуск в ход презентация чтобы избежать неминуемый проблема live-кодинга что такой jit-компилятор я уверенный что многие из вы знать что такой jit-компилятор но всё-таки коснуться основа чтобы никто не сидеть тут бояться задать этот главный вопрос когда вы запускать команда javac или compile-on-save в ide ваш программа на java компилироваться из java-код в байткод jvm который являться бинарный представление программа он более компактный и простой чем исходный java-код однако обычный процессор ваш ноутбук или сервер не мочь просто так выполнить байткод jvm для работа ваш программа jvm интерпретировать этот байткод интерпретатор обычно значительно медленный чем машинный код запускать на процессор по этот причина jvm в время работа программа мочь запустить ещё один компилятор который преобразовать ваш байткод в машинный код выполнить который процессор уже в состояние этот компилятор обычно намного более изощрённый чем javac выполнять сложный оптимизация чтобы в результат выдать высококачественный машинный код зачем писать jit-компилятор на java на сегодняшний день реализация jvm под название openjdk включать два основный jit-компилятор клиентский компилятор известный как c1 спроектировать для более быстрый работа но при это выдавать менее оптимизировать код серверный компилятор известный как opto или c2 требовать несколько большой время на работа но выдавать более оптимизировать код идея заключаться в тот что клиентский компилятор хороший подходить для настольный приложение где нежелательный длительный пауза jit-компилятор а серверный — для долгоиграющий серверный приложение в который позволительно потратить большой время на компиляция на сегодня они мочь быть совместить чтобы код сперва компилироваться c1 и после если он продолжать интенсивно выполняться и иметь смысл затратить дополнительный время — c2 это называться ступенчатый компиляция tiered compilation давать остановиться на c2 — серверный компилятор который выполнять большой оптимизация мы мочь склонировать openjdk с зеркало на github или просто открыть дерево проект на сайт $ git clone https//githubcom/dmlloyd/openjdkgit код c2 находиться в openjdk/hotspot/src/share/vm/opto прежде всего стоить отметить что c2 написать на c++ конечно в это нет чего-то плохой но есть определённый недостаток с++ — небезопасный язык это означать что ошибка в c++ мочь привести к крах vm возможно что причина тот возраст код но код c2 на c++ стать очень трудно поддерживать и развивать один из ключевой фигура стоящий за компилятор c2 cliff click сказать что никогда бы большой не стать писать vm опять на c++ и мы слышать как jvm-команда twitter высказывать мнение о тот что c2 прийти в застойный состояние и требовать замена по причина трудность дальнейший разработка https//wwwyoutubecom/watchv=hqw57gjsrac итак возвращаться к вопрос что такой есть в java что мочь помочь решить этот проблема тоже самый что давать написание программа на java вместо c++ это вероятно безопасность исключение вместо крах отсутствие реальный утечка память или висячий указатель хороший вспомогательный средство отладчик профилировщик и инструмент вроде visualvm хороший поддержка ide и тд вы мочь бы подумать как можно написать что-то вроде jit-компилятор на java и что это возможно только на низкоуровневый язык системный программирование такой как c++ в это выступление я надеяться убедить вы что это совсем не так по существо jit-компилятор должный просто принять байткод jvm и выдать машинный код — вы давать он byte[] на вход и назад также хотеть получить byte[] требоваться выполнить много сложный работа чтобы это осуществить но она никак не затрагивать системный уровень и поэтому не требовать системный язык такой как c или c++ настройка graal первое что мы понадобиться — это java 9 использовать graal интерфейс под название jvmci быть добавить в java в рамка jep 243 java-level jvm compiler interface и один версия он включать являться java 9 я использовать 9+181 в случай какой-то особенный требование иметься порт backports для java 8 $ export javahome=`pwd`/jdk9 $ export path=$javahome/bin$path $ java -version java version "9" javatm se runtime environment build 9+181 java hotspottm 64-bit server vm build 9+181 mixed mode следующий что мы понадобиться это система сборка под название mx она немного похожий на maven или gradle но скорее всего вы бы не выбрать её для свой приложение она реализовать определённый функционал для поддержка некоторый сложный вариант использование но мы быть использовать её только для простой сборка склонировать mx можно с github я использовать коммит #7353064 теперь просто добавить исполняемый файл в путь $ git clone https//githubcom/graalvm/mxgit $ cd mx git checkout 7353064 $ export path=`pwd`/mx$path теперь мы надо склонировать сам graal я использовать дистрибутив под название graalvm версия 0282 $ git clone https//githubcom/graalvm/graalgit --branch vm-enterprise-0282 этот репозиторий содержимый и другой проект который мы сейчас не интересный поэтому мы просто перейти в подпроект compiler который и являться jit-компилятор graal и собрать он использовать mx $ cd graal/compiler $ mx build для работа с код graal я быть использовать eclipse ide я использовать eclipse 471 mx мочь сгенерировать для мы файл eclipse-проект $ mx eclipseinit чтобы открыть каталог graal как рабочий область workspace нужно выполнить file import… general existing projects и опять выбрать каталог graal если вы запустить eclipse не на java 9 то возможно также потребоваться прикрепить и исходник jdk хорошо теперь когда весь готовый давать посмотреть как это работать мы быть использовать этот очень простой код class demo { public static void mainstring[] args { while true { workload14 2 } } private static int workloadint a int b { return a + b } } сначала мы скомпилировать этот код javac а после запустить jvm сперва я показать работа стандартный jit-компилятор c2 для это указать несколько флаг -xx+printcompilation который нужный чтобы jvm писать лог при компиляция метод и -xxcompileonly=demoworkload чтобы компилироваться только данный метод если мы это не сделать то быть вывести слишком много информация и jvm быть умный чем мы надо и оптимизировать код который мы хотеть увидеть $ javac demojava $ java \ -xx+printcompilation \ -xxcompileonly=demoworkload \ demo  113 1 3 demoworkload 4 bytes  я не быть подробно это пояснять а сказать лишь что это вывод лог который показывать что метод workload быть скомпилировать теперь в качество jit-компилятор наш java 9 jvm мы использовать только что скомпилировать graal для это необходимый добавить ещё несколько флаг --module-path= и --upgrade-module-path= добавлять graal в module path напомнить что module path появиться в java 9 как часть система модуль jigsaw и для наш цель мы мочь рассматривать он по аналогия с classpath мы нужный флаг -xx+unlockexperimentalvmoptions из-за тот что jvmci интерфейс использовать graal в дать версия являться экспериментальный возможность флаг -xx+enablejvmci нужный чтобы сказать что мы хотеть использовать jvmci а -xx+usejvmcicompiler — для включение и установка новое jit-компилятор чтобы не усложнять пример и вместо использование c1 совместно с jvmci иметь только jvmci-компилятор указать флаг -xx-tieredcompilation который отключить ступенчатый компиляция как и ранее указать флаг -xx+printcompilation и -xxcompileonly=demoworkload как и в предыдущий пример мы видеть что быть скомпилировать один метод но в этот раз для компиляция мы использовать только что собранный graal пока просто поверьте я на слово $ java \ --module-path=graal/sdk/mxbuild/modules/orggraalvmgraalsdkjargraal/truffle/mxbuild/modules/comoracletruffletruffleapijar \ --upgrade-module-path=graal/compiler/mxbuild/modules/jdkinternalvmcompilerjar \ -xx+unlockexperimentalvmoptions \ -xx+enablejvmci \ -xx+usejvmcicompiler \ -xx-tieredcompilation \ -xx+printcompilation \ -xxcompileonly=demoworkload \ demo  583 25 demoworkload 4 bytes  интерфейс компилятор jvm вы не кажется что мы сделать что-то достаточно необычный у мы есть установленный jvm и мы заменить jit-компилятор на только что скомпилировать новый не менять что-либо в самый jvm этот возможность обеспечивать новый интерфейс jvm под название jvmci — jvm compiler interface — то что как я говорить выше быть jep 243 и войти в java 9 идея аналогичный некоторые другой существующий технология jvm возможно вы когда-нибудь уже сталкиваться с дополнительный обработка исходный код в javac с использование api java для обработка аннотация java annotation processing api этот механизм давать возможность выявление аннотация и модель исходный код в который они использоваться и создание новый файл на они основа также вы возможно использовать дополнительный обработка байткод в jvm с помощь java-агент java agents этот механизм позволять модифицировать байткод java перехватывать он при загрузка идея jvmci схожий он позволять подключить собственный java jit-компилятор написать на java сейчас я хотеть сказать пара слово о тот как быть показывать код в ход этот презентация сначала для понимание идея я быть показывать несколько упрощённый идентификатор и логика в вид текст на слайд а после быть переключаться на скриншот eclipse и показывать реальный код который мочь быть немного сложный но главный идея остаться тот же основный часть это выступление иметь цель показать что с реальный код проект действительно можно работать и поэтому я не хотеть он скрывать хотя он и мочь быть несколько сложный с это момент я приступать к развеивания мнение который мочь у вы быть что jit-компилятор — это очень сложно что jit-компилятор принимать на вход он принимать байткод метод который надо скомпилировать а байткод как подсказывать название это просто массив байт что jit-компилятор выдавать в качество результат он выдавать машинный код метод машинный код это тоже просто массив байт в итог интерфейс который надо реализовать при написание новое jit-компилятор для он встраивание в jvm быть выглядеть примерно так interface jvmcicompiler { byte[] compilemethodbyte[] bytecode } поэтому если вы не представлять как java мочь делать что-то настолько низкоуровневый как jit-компиляция в машинный код то теперь видно что это не такой уж и низкоуровневый работа правда это просто функция из byte[] в byte[] в действительность весь несколько сложный только байткод недостаточно — мы также нужный ещё некоторый информация такой как количество локальный переменный необходимый размер стек и информация собрать профилировщик интерпретатор чтобы понимать как код выполняться по факт поэтому представимый вход в вид compilationrequest который сказать мы о требовать компиляция javamethod и предоставить весь необходимый информация interface jvmcicompiler { void compilemethodcompilationrequest request } interface compilationrequest { javamethod getmethod } interface javamethod { byte[] getcode int getmaxlocals int getmaxstacksize profilinginfo getprofilinginfo  } также интерфейс не требовать возврат скомпилировать код вместо это для установка install машинный код в jvm использоваться ещё один api hotspotinstallcodetargetcode теперь чтобы написать новый jit-компилятор для jvm надо просто реализовать этот интерфейс мы получать информация о требовать компиляция метод и должный скомпилировать он в машинный код и вызвать installcode class graalcompiler implements jvmcicompiler { void compilemethodcompilationrequest request { hotspotinstallcode } } давать переключиться в eclipse ide с graal и посмотреть на некоторый реальный интерфейс и класс как говориться ранее они быть несколько сложный но не намного сейчас я хотеть показать что мы мочь вносить в graal изменение и сразу использовать они в java 9 я добавить новое сообщение лог который быть выводиться при компиляция метод с использование graal добавить он в реализовать метод интерфейс который вызываться jvmci class hotspotgraalcompiler implements jvmcicompiler { compilationrequestresult compilemethodcompilationrequest request { systemerrprintln"going to compile " + requestgetmethodgetname  } } пока отключить существующий в hotspot логирование компиляция теперь мы мочь видеть наш сообщение из изменить версия компилятор $ java \ --module-path=graal/sdk/mxbuild/modules/orggraalvmgraalsdkjargraal/truffle/mxbuild/modules/comoracletruffletruffleapijar \ --upgrade-module-path=graal/compiler/mxbuild/modules/jdkinternalvmcompilerjar \ -xx+unlockexperimentalvmoptions \ -xx+enablejvmci \ -xx+usejvmcicompiler \ -xx-tieredcompilation \ -xxcompileonly=demoworkload \ demo going to compile workload если вы попробовать повторить это сам то заметить что не требоваться даже запуск наш система сборка — mx build достаточно обычный для eclipse compile on save и уж точно мы не надо пересобирать сам jvm мы просто встраивать модифицированный компилятор в существующий jvm граф graal ну что же мы знать что graal преобразовать один byte[] в другой byte[] теперь давать поговорить о теория и структура дать который он использовать тк они немного необычный даже для компилятор по суть компилятор заниматься обработка ваш программа для это программа необходимый представить в вид какой-то структура дать один из вариант являться байткод и подобный он список инструкция но они не очень выразительный вместо это для представление ваш программа graal использовать граф если взять простой оператор сложение который суммировать два локальный переменный то граф быть включать по один узел для загрузка каждый переменный один узел для сумма и два ребро который показывать что результат загрузка локальный переменный поступать на вход оператор сложение иногда это называть граф зависимость программа program dependency graph иметь выражение вид x + y мы получить узел для локальный переменный x и y и узел они сумма синий ребро на это граф показывать направление поток дать от чтение локальный переменный к суммирование также мы мочь использовать ребро для отражение порядок выполнение программа если вместо чтение локальный переменный мы вызывать метод то мы нужно запомнить порядок вызов и мы не мочь переставлять они местами не знать о код внутри для это есть дополнительный ребро который и задавать этот порядок они показать красный цвет итак граф graal на самый дело это два граф совместить в один узел одинаковый но один ребро показывать направление поток дать а другой — порядок передача управление между они чтобы увидеть граф graal можно воспользоваться инструмент под название idealgraphvisualiser или igv запуск выполняться с помощь команда mx igv после это запустить jvm с флаг -dgraaldump простой поток дать можно увидеть написать несложный выражение int averageint a int b { return a + b / 2 } можно видеть как параметр 0 p0 и 1 p1 поступать на вход операция сложение который вместе с константа 2 c2 поступать на вход операция деление после данный значение возвращаться для тот чтобы посмотреть на более сложный поток дать и управление ввести цикл int averageint[] values { int sum = 0 for int n = 0 n < valueslength n++ { sum += values[n] } return sum / valueslength } в это случай у мы есть узел начало и окончание цикл чтение элемент массив и чтение длина массив как и ранее синий линия показывать направление поток дать а красный — поток управление теперь вы мочь видеть почему этот структура дать иногда называть море узел sea of nodes или солянка узел soup of nodes хотеть сказать что c2 использовать очень схожий структура дать и в действительность именно c2 популяризировать идея компилятор море узел так что это не нововведение graal я не быть показывать процесс построение это граф до следующий часть выступление но когда graal получать программа в такой формат оптимизация и компиляция выполняться при помощь модификация дать структура дать и это один из причина почему написание jit-компилятор на java иметь смысл java — объектно-ориентированный язык а граф — это набор объект соединить ребро в вид ссылка от байткод к машинный код давать посмотреть как этот идея выглядеть на практика и проследить некоторый этап процесс компиляция получение байткод компиляция начинаться с байткод вернуться к наш небольшой пример с суммирование int workloadint a int b { return a + b } вывести принимать на вход байткод непосредственно перед начало компиляция class hotspotgraalcompiler implements jvmcicompiler { compilationrequestresult compilemethodcompilationrequest request { systemerrprintlnrequestgetmethodgetname + " bytecode " + arraystostringrequestgetmethodgetcode  } } workload bytecode [26 27 96 -84] как видно входной дать для компилятор являться байткод парсер байткод и построитель граф построитель воспринимать этот массив байт как байткод jvm преобразовать он в граф graal это являться свой род абстрактный интерпретация — построитель интерпретировать байткод java но вместо передача значение манипулировать свободный конец ребро и постепенно соединять они друг с друг давать воспользоваться преимущество тот что graal написать на java и посмотреть как это работать использовать инструмент навигация eclipse мы знать что в наш пример есть узел сложение поэтому давать найти где он создаваться видно что они создавать парсер байткод и это привести мы к код обработка iadd 96 который мы видеть в распечатать входной массив private void genarithmeticopjavakind kind int opcode { valuenode y = framestatepopkind valuenode x = framestatepopkind valuenode v switch opcode {  case ladd v = genintegeraddx y break  } framestatepushkind appendv } выше я сказать что это абстрактный интерпретация тк весь это очень похоже на интерпретатор байткод если бы это быть реальный интерпретатор jvm тогда он бы снять два значение с стек выполнить сложение и положить результат обратно в дать случай мы снимать с стек два узел который при запуск программа быть представлять себя вычисление добавлять представлять себя результат суммирование новый узел для сложение и размещать он в стек такой образ строиться граф graal получение машинный код для преобразование граф graal в машинный код нужно сгенерировать байт для весь он узел это делаться отдельно для каждый узел с помощь вызов он метод generate void generategenerator gen { genemitadda b } повториться тут мы работать на очень высокий уровень абстракция у мы есть класс с помощь который мы выдавать инструкция машинный код не вдаваться в деталь тот как это работать деталь emitadd несколько сложный и абстрактный по тот причина что арифметический оператор требовать кодирование для множество различный комбинация операнд но при это мочь совместно использовать большой часть они код поэтому я ещё немного упростить программа int workloadint a { return a + 1 } в дать случай быть использовать инструкция инкремент и я показать как это выглядеть в ассемблер void inclregister dst { int encode = prefixandencodedstencoding emitbyte0xff emitbyte0xc0 | encode } void emitbyteint b { dataputbyte b & 0xff } можно видеть что результат являться байт который добавляться в стандартный bytebuffer — просто создание массив байт выходной машинный код давать посмотреть на выходной машинный код также как ранее мы делать с входной байткод — добавить распечатка байт в место он установка class hotspotgraalcompiler implements jvmcicompiler { compilationresult compilehelper {  systemerrprintlnmethodgetname + " machine code " + arraystostringresultgettargetcode  } } также я воспользоваться инструмент который дизассемблировать машинный код при он установка это стандартный средство hotspot я показать как он собрать оно находиться в репозиторий openjdk но по-умолчание не включить в поставка jvm поэтому мы надо собрать он сам $ cd openjdk/hotspot/src/share/tools/hsdis $ curl -o http//ftpheanetie/mirrors/gnu/binutils/binutils-224targz $ tar -xzf binutils-224targz $ make binutils=binutils-224 arch=amd64 cflags=-wno-error $ cp build/macosx-amd64/hsdis-amd64dylib ///// ещё я добавить два новый флаг -xx+unlockdiagnosticvmoptions и -xx+printassembly $ java \ --module-path=graal/sdk/mxbuild/modules/orggraalvmgraalsdkjargraal/truffle/mxbuild/modules/comoracletruffletruffleapijar \ --upgrade-module-path=graal/compiler/mxbuild/modules/jdkinternalvmcompilerjar \ -xx+unlockexperimentalvmoptions \ -xx+enablejvmci \ -xx+usejvmcicompiler \ -xx-tieredcompilation \ -xx+printcompilation \ -xx+unlockdiagnosticvmoptions \ -xx+printassembly \ -xxcompileonly=demoworkload \ demo теперь мы мочь запустить наш пример и увидеть вывод инструкция для наш сложение workload machine code [15 31 68 0 0 3 -14 -117 -58 -123 5 ]  0x000000010f71cda0 nopl 0x0%rax%rax1 0x000000010f71cda5 add %edx%esi \*iadd {reexecute=0 rethrow=0 returnoop=0}  - demoworkload@2 line 10 0x000000010f71cda7 mov %esi%eax \*ireturn {reexecute=0 rethrow=0 returnoop=0}  - demoworkload@3 line 10 0x000000010f71cda9 test %eax-0xcba8da9%rip # 0x0000000102b74006  {pollreturn} 0x000000010f71cdaf vzeroupper 0x000000010f71cdb2 retq хорошо давать проверить что мы действительно контролировать весь это и превратить суммирование в вычитание я изменить метод generate узел суммирование так чтобы вместо инструкция сложение он выдавать инструкция для вычитание class addnode { void generate {  genemitsubop1 op2 false  // changed from emitadd } } если мы запустить это то увидеть что оба байт машинный код измениться и на печать выводиться новое инструкция workload mechine code [15 31 68 0 0 43 -14 -117 -58 -123 5 ] 0x0000000107f451a0 nopl 0x0%rax%rax1 0x0000000107f451a5 sub %edx%esi \*iadd {reexecute=0 rethrow=0 returnoop=0}  - demoworkload@2 line 10 0x0000000107f451a7 mov %esi%eax \*ireturn {reexecute=0 rethrow=0 returnoop=0}  - demoworkload@3 line 10 0x0000000107f451a9 test %eax-0x1db81a9%rip # 0x000000010618d006  {pollreturn} 0x0000000107f451af vzeroupper 0x0000000107f451b2 retq итак что мы узнать graal просто принимать массив байт байткод мы мочь увидеть как из он создаваться граф узел мы мочь увидеть как узел выдавать инструкция и как они кодироваться мы видеть что мочь внести изменение в сам graal [26 27 96 -84] → [15 31 68 0 0 43 -14 -117 -58 -123 5 ] оптимизация и так мы посмотреть как строиться граф и как узел граф преобразоваться в машинный код теперь давать поговорить о тот как graal оптимизировать граф делать он более эффективный фаза оптимизация — это просто метод у который есть возможность выполнить модификация граф фаза создаваться с помощь реализация интерфейс interface phase { void rungraph graph } каноникализация canonicalisation каноникализация означать переупорядочивание узел в единообразный представление у этот техника есть и другой задача но для цель данный выступление я сказать что в действительность это означать свёртывание константа constant folding и урощение узел узел сам ответственный за свой упрощение — для это у они есть метод canonical interface node { node canonical } давать для пример рассмотреть узел операция отрицание который представлять себя унарный оператор вычитание узел операция отрицание удалить себя и свой потомок в случай если он применяться к другой операция отрицание — остаться только сам значение этот оптимизация упростить --x до x class negatenode implements node { node canonical { if value instanceof negatenode { return negatenode valuegetvalue } else { return this } } } это действительно хороший пример тот насколько graal простой для понимание практически дать логика простой настолько насколько это возможно если у вы есть хороший идея как упростить операция в java вы мочь реализовать её в метод canonical global value numbering global value numbering gvn — это техника удаление многократно повторяться избыточный код в пример ниже a + b мочь быть вычислить единожды а результат — переиспользовать int workloadint a int b { return a + b * a + b } graal мочь сравнивать узел на равенство это просто — они равный если у они одинаковый входной значение в фаза gvn выполняться поиск одинаковый узел и они замена единственный копия эффективность этот операция достигаться за счёт использование hash map в вид свой род кэш узел заметить проверка на то что узел нефиксированный — это означать что он не обладать побочный эффект который мочь проявиться в какой-то момент время если бы вместо это вызываться метод то термы стать бы фиксировать и неизбыточный а они слияние в один — невозможный int workload { return geta + getb * geta + getb } укрупнение блокировка lock coarsening давать рассмотреть более сложный пример иногда программист писать код который два раз подряд синхронизироваться на один и тот же монитор возможно что они так не писать но это стать результат другой оптимизация такой как встраивание inlining void workload { synchronized monitor { counter++ } synchronized monitor { counter++ } } если развернуть конструкция то мы увидеть что фактически происходить void workload { monitorenter counter++ monitorexit monitorenter counter++ monitorexit } мы мочь оптимизировать этот код захватывать монитор только один раз вместо он освобождение и повторный захват на следующий же шаг это и есть укрупнение блокировка void workload { monitorenter counter++ counter++ monitorexit } в graal это реализовать в фаза под название lockeliminationphase в метод run производиться поиск весь узел освобождение монитор и выполняться проверка непосредственный следование за они узел захват после это в случай использование один и тот же монитор выполняться они удаление и оставаться только объемлющий узел захват и освобождение void runstructuredgraph graph { for monitorexitnode monitorexitnode  graphgetnodesmonitorexitnodeclass { fixednode next = monitorexitnodenext if next instanceof monitorenternode { accessmonitornode monitorenternode = accessmonitornode next if monitorenternodeobject ## monitorexitnodeobject { monitorexitnoderemove monitorenternoderemove } } } } основной причина для этот оптимизация являться уменьшение код избыточный захват и освобождение но также это позволять выполнять и другой оптимизация такой как комбинация два инкремент в один сложение с 2 void workload { monitorenter counter += 2 monitorexit } давать посмотреть в igv как это работать мы видеть после выполнение оптимизация как граф направляться от два пара захвата\освобождение монитор к один и как после два инкремент преобразоваться в один сложение с 2 не затронуть практический аспект рассматривать работа graal на высокий уровень конечно же я упустить множество важный практический деталь который обеспечивать он хороший работа и создание эффективный машинный код фактически я также пропустить некоторый базовый вещий необходимый для он работа в принцип я не рассказать о некоторый часть graal по тот причина что они концептуально не так простой для демонстрация как привести выше код но я показать где при желание вы смочь они найти назначение регистр в модель граф graal у мы есть узел по который с помощь ребро перемещаться значение но что себя представлять этот ребро в реальность если машинный инструкция нужный входной дать или возможность вернуть результат то что они для это использовать ребро в итог отображаться на регистр процессор регистр подобный локальный переменный для процессор они являться высокий частью иерархия системный память находиться над различный уровень кеш процессор который в свой очередь находиться над оперативный память машинный инструкция мочь писать и читать из регистр и значение такой образ мочь передаваться от один инструкция к другой с помощь они запись один и после чтение два задача выбор регистр для каждый ребро называться назначение регистр register allocation graal использовать схожий с другой jit-компилятор алгоритм назначение регистр — алгоритм линейный развёртка linear scan algorithm диспетчеризация ещё один базовый проблема о который я не упомянуть заключаться в тот что у мы есть граф узел без какой-либо точный порядок они выполнение а процессор требоваться линейный последовательность инструкция в определённый порядок например инструкция сложение принимать на вход два значение который нужно просуммировать и если нет необходимость вычисление один значение ранний другой тот они не иметь побочный эффект то граф тоже не говорить мы о это но при выдача машинный код необходимый определить порядок входной значение этот проблема называться диспетчеризация граф graph scheduling диспетчер требоваться для определение порядок обработка узел он определять последовательность вызов код учитывать требование что весь значение должный быть вычислить на момент они использование можно создать диспетчер который быть просто работать но есть возможность улучшить производительность код например не вычислять значение до момент он фактический использование можно сделать ещё хитрый применить знание о иметься ресурс процессор и давать он работа такой образ чтобы они использоваться наиболее эффективно в какой случай использовать graal в начало выступление в вводный слайд я говорить что на данный момент graal — это исследовательский проект а не находиться на поддержка продукт oracle какой мочь быть практический применение исследование осуществлять в рамка graal компилятор нижний уровень final-tier compiler c помощь jvmci graal мочь использоваться как компилятор нижний уровень в hotspot — то что я и демонстрировать выше по мера появление новый и отсутствовать в hotspot оптимизация в graal он мочь стать компилятор использовать для повышение производительность twitter говорить про то как они использовать graal для этот цель а иметь релиз java 9 и желание экспериментировать вы уже сегодня мочь начать практиковаться в это для тот чтобы начать нужный только флаг -xx+usejvmcicompiler и др огромный польза от jvmci заключаться в тот что он давать возможность подгружать graal отдельно от jvm вы мочь развёртывать deploy какой-то версия jvm и отдельно подключать новое версия graal как и в случай с java-агент при использование graal обновление компилятор не требовать пересборка самый jvm проект openjdk по название metropolis иметь свой цель реализация больший часть jvm на язык java graal представлять себя один из шаг в это направление http//cropenjdkjavanet/\~jrose/metropolis/metropolis-proposalhtml пользовательский оптимизация graal можно расширять дополнительный оптимизация так же как graal подключаться к jvm есть возможность подключение к graal новый фаза компиляция если у вы есть желание применить определённый оптимизация к ваш приложение в graal вы мочь написать для это новый фаза или если у вы есть какой-то особенный набор код машинный инструкция который вы хотеть использовать вы мочь просто написать новый метод вместо использование низкоуровневый код и он последующий вызов с помощь jni charles nutter уже предложить проделать это для jruby и продемонстрировать рост производительность от добавление новый фаза graal смягчающий идентификация объект для упаковать число ruby думать что скоро он выступить с это на какой-нибудь конференция aot ahead-of-time компиляция graal — это просто библиотека java jvmci предоставлять интерфейс использовать graal для осуществление низкоуровневый действие такой как установка машинный код но большой часть graal достаточно изолировать от всего это это означать что вы мочь использовать graal и для другой приложение а не только как jit-компилятор на самый дело между jit- и aot-компилятор не такой уж и большой разница и graal можно использовать в оба случай в действительность существовать два проект реализовать aot с помощь graal java 9 включать инструмент предварительный компиляция класс в машинный код для сокращение время требовать для jit-компиляция особенно на фаза запуск приложение для работа это код весь ещё нужный jvm только вместо запуск компилятор по требование использоваться предварительно скомпилировать код aot java 9 использовать несколько устаревший версия graal который включить только в сборка для linux именно по этот причина я не стать использовать её для дть и вместо это продемонстрировать сборка более свежеть версия и необходимый для использование аргумент командный строка два проект более амбициозный substratevm — это aot-компилятор который компилировать java-приложение в независимый от jvm машинный код фактически на выход вы иметь статически-связанный statically linked исполняемый модуль в это случай jvm не требоваться а исполняемый файл мочь иметь размер всего несколько мегабайт для выполнение такой компиляция substratevm использовать graal в некоторый конфигурация для компиляция код в время выполнение just-in-time substratevm также мочь скомпилировать graal в себя такой образ graal aot-компилировать себя самый $ javac hellojava $ graalvm-0282/bin/native-image hello classlist 96644 ms cap 80446 ms setup 151431 ms typeflow 258070 ms objects 71904 ms features 1627 ms analysis 342258 ms universe 26209 ms parse 52844 ms inline 125994 ms compile 671620 ms compile 881797 ms image 107029 ms debuginfo 67264 ms write 179745 ms [total] 1790756 ms $ ls -lh hello -rwxr-xr-x 1 chrisseaton staff 66m 4 oct 1835 hello $ file /hello /hellojava mach-o 64-bit executable x8664 $ time /hello hello real 0m0010s user 0m0003s sys 0m0003s truffle ещё один проект использовать graal в качество библиотека иметь название truffle truffle — это фреймворк для создание интерпретатор язык программирование поверх jvm большинство язык работать на jvm выдавать байткод который потом jit-компилироваться как обычно но как я говорить выше по тот причина что jit-компилятор jvm представлять себя чёрный ящик довольно трудно контролировать что произойти с это байткод truffle использовать другой подход — вы писать простой интерпретатор для ваш язык следовать определённый правило и truffle автоматически комбинировать программа и интерпретатор для получение оптимизировать машинный код использовать техника известный как частичный вычисление partial evaluation частичный вычисление иметь в свой основа интересный теоретический часть но с практический точка зрение мы мочь говорить о это как о включение код inlining и сворачивание константа constant folding программа вместе с использовать она дать graal иметь функционал включение код и сворачивание константа поэтому truffle мочь использовать он в качество частичный вычислитель именно так я и познакомиться с graal — через truffle я работать над реализация язык программирование ruby который называться truffleruby и использовать фреймворк truffle и также graal truffleruby — это самый быстрый реализация ruby обычно в 10 раз быстрый другой который при это реализовать практически весь возможность язык и стандартный библиотека https//githubcom/graalvm/truffleruby вывод главный идея который я хотеть донести это выступление заключаться в тот что с jit-компилятор java можно работать также как и с любой другой код jit-компиляция включать множество сложность в основное наследовать они от лежать в основа архитектура и также из-за желание выдача как можно более оптимизировать код за возможно короткий время но весь равно это верхнеуровневый задача интерфейс к jit-компилятор представлять себя не большой чем конвертер byte[] байткод jvm в byte[] машинный код этот задача который хорошо подходить для реализация на java сам компиляция не являться задача требовать низкоуровневый и небезопасный язык программирование такой как c++ java-код graal не являться какой-то магия не быть притворяться что он всегда простой но заинтересовать новичок быть в состояние прочесть и понять большой он часть очень советовать вы сам поэкспериментировать с это пользоваться дать подсказка если вы начать с изучение привести выше класс то не потеряться в код впервые открыть eclipse и увидеть длинный список пакет от этот стартовый точка вы мочь двигаться к реализация метод definitions место они вызов и тд постепенно исследовать кодовый база если у вы уже есть опыт контроль и настройка jit с использование инструмент для существующий jit-компилятор jvm такой как jitwatch то вы заметить что чтение код помочь хороший понять почему graal компилировать ваш код именно так а не иначе и если вы понять что что-то работать не так как вы тот ожидать то смочь внести в graal изменение и просто перезапустить jvm для это вы даже не потребоваться покидать ваш ide как я показать на пример с hello-world мы работать над такой потрясать исследовательский проект как substratevm и truffle который использовать graal и действительно менять картина тот что быть возможно в java в будущее весь это возможно благодаря тот что весь graal написать на обычный java если бы для написание наш компилятор мы использовать что-то вроде llvm как предлагать некоторый компания то в многий случай переиспользование код быть бы затруднить и наконец на данный момент есть возможность использовать graal не вносить изменение в сам jvm тк jvmci являться частью java 9 graal мочь быть подключить также как и уже существующий процессор аннотация или java-агент graal — это большой проект над который работать много человек как уже говориться выше я не работать непосредственно над graal я просто имя пользоваться и вы тоже мочь это делать more information about truffleruby low overhead polling for ruby top 10 things to do with graalvm ruby objects as c structs and vice versa understanding how graal works — a java jit compiler written in java flip-flops — the 1-in-10-million operator deoptimizing ruby very high performance c extensions for jruby+truffle optimising small data structures in jruby+truffle pushing pixels with jruby+truffle tracing with zero overhead in jruby+truffle how method dispatch works in jruby+truffle a truffle/graal high performance backend for jruby 
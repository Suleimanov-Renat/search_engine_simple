записка программист ооп and и or философия ооп инкапсуляция наследование полиморфизм… метод член класс разграничение приватность абстракция… как часто я видеть статья на тема ооп и как часто не видеть самый ооп в этот статья не видеть настоящий живой объектно-ориентированный программирование автор владеть терминология мочь привести тысяча определение пресловутый ооп вспомнить пара классический пример с простенький наследование везде напихать утверждение что инкапсуляция — это хорошо… да инкапсуляция — это хорошо но это не быть ооп как не быть весь остальной термин не быть даже то что в ооп принять оперировать класс на самый дело слово «принять — неправильный в ооп можно оперировать класс и удобно работать именно с класс однако существовать подход когда класс нет а ооп — есть как так почему разве класс — не самый главный часть ооп разве он можно выбросить разве остаться ооп избавиться мы от класс остаться ведь что есть «класс инструмент сложный многофункциональный инструмент а что есть «ооп философия философия взаимодействие философия программистский мышление философия в который есть закон и правило способ и методика инструмент и материал вы мочь выгнать музыкант из-за фортепиано — он взять флейта отобрать флейта — музыкант натянуть струна и изобразить мелодия завязать он рука и он просто стать напевать музыка в немой самый ооп подобно музыка он можно изучать в теория обширный партитура ооп-код гордый скрипичный абстрактный класс нота-класс в связка бемоль наследник рефрен идти перегрузка метод и ещё пара ловкий переход с размер на размер чтобы достигнуть определённый эффекта… с практика тоже весь хорошо сложить простой мелодия с помощь металлофон постучать молоточек по чужое класс выучить гитарный аккорд — и скомпоновать простой программа с стандартный решение стандартный алгоритм стандартный подход хотеть что-то нестандартный тогда вы — в музыкальный школа в она вы научить играть на разный инструмент и правильно сочетать они вы узнать про паттерн проектирование шаблонный класс абстрагирование от алгоритм сокрытие информация и много что ещё вы вдруг понять что сочинять мелодия — тоже искусство прошлое ваш поделка показаться вы грубый аморфный безобразный и вы удивиться что ранний писать так неуклюже вон там хороший быть бы создать класс и перенести в он часть функция здесь хороший воспользоваться стандартный решение чем придумывать свой а вот этот неочевидный обходный манёвр решаться всего-навсего абстрактный класс и три простейшее наследниками… знать вы на верный путь вы уже понимать что ооп — это не нота но музыка и вы учиться гармония теперь чтобы дирижировать оркестр ооп или быть хороший композитор остаться совсем немного всего-то лишь закончить консерватория там вы не только изучать музыка — вы учиться она чувствовать дышать она думать она проблема and и or в свой работа над 04 версия orm для qt я столкнуться с интересный программистский проблема и смочь она красиво решить я захотеться поделиться мысль с кто-то ещё и я стать записывать они в вид отрывочный фраза вскоре я взяться за более содержательный предложение — так появиться этот записка программист в мой orm-библиотека qst о 03 версия который я уже писать на хабра пока нет генерация сложный запрос и это как раз то что я хотеть реализовать сейчас но где сложный запрос там и большой условный конструкция который попробовать разобрать на приоритетность весь этот вложить and и or условие да ещё если без скобка — с ум можно сойти пока придумать как это хороший сделать я понять что я прежде всего нужный класс для один маленький простой условие пусть это быть qstcondition — и ничто что длинный название на этап предварительный проектирование сойти и так сначала я расписать на бумажка какой хотеть бы видеть код на с++ если бы класс qstcondition у я уже быть для начало «запрограммировать простой условие f1 и f2 — это поль в sql-запрос f1 = f2 f1 = 5 5 = 5 я бы хотеть создавать экземпляр класс qstcondition разнообразный способ qstcondition"f1" functorequal "f2" qstcondition"f1" functorequal qvariant5 qstcondition"f1 = f2" qstconditionqvariant5 functorequal qvariant5 qstcondition"f1 = " qvariant5 в мой библиотека есть класс qstfield — абстракция над поль в sql-понимание qstvalue — абстракция над константа класс qstcondition должный они понимать qstconditionqstfield"f1" functorequal "f2" // здесь матрёшка в qstcondition передаваться qstfield в который передаваться qstvalue в который передаваться qvariant запись можно чуть-чуть укоротить оставить 5 вместо qvariant5 qstconditionqstfield"f1" qstvalueqvariant5 functorequal qstconditionqstfield"f1" functorequal qstfield"f2" qstconditionqstvalueqvariant5 functorequal qvariant5 qstconditionqstvalueqvariant5 functorequal qvariant5 какой же должный быть конструктор для весь этот случай в первое приближение получиться пять штука 1 qstconditionqstring field1 comparefunctor functor qstring field2 2 qstconditionqstring field1 comparefunctor functor qvariant value 3 qstconditionqvariant value1 comparefunctor functor qvariant value2 4 qstconditionqstring stringcondition 5 qstconditionqstfield qstfield1 comparefunctor functor qstfield qstfield2 я уже понимать что далее у я есть два вариант развитие где-то внутри класс qstcondition быть лежать имя полый функтор значение можно быть бы положить имя полый в два строка что-то вроде qstcondition { qstring fieldname1 fieldname2 qvariant value1 value2 comparefunctor functor } что же тогда делать с пять конструктор в qstfield есть «имя поль — name  я мочь бы извлечь он и положить в строка qstconditionqstfield field1 comparefunctor functor qstfield field2  fieldname1field1name // извлекать и класть в строка fieldname2field2name value1qvariant value2qvariant functorfunctor {} прогнозировать я прийтись брать вот этот самый текстовый fieldname1 fieldname2 и передавать они по много раз в qstfield для генерация sql не хороший ли сразу хранить имя полый в готовый класс qstfield и логичный и семантически правильный как там по затрата на создание/хранение/копирование объект класс qstfield — уж не знать это я волновать в последний очередь особенно на этап проектирование потом я вспомнить что один из конструктор qstfield выглядеть так qstfieldconst qstring &name const fieldvisibility &visibility = fieldvisible const char *columntitle = "" const int &columnwidth = 0 const qtorientation &titleorientation = qthorizontal хранить я дать весь равно в qstfield значит конструктор 1 можно исключить вместо он быть вызываться конструктор 5 даже если мы передавать просто два строка в качество имя полый оставить я конструктор 1 и компилятор бы я обругать эй прогера у ты конструктор ambiguous чтобы в это убедиться я от теория перейти к практика написать класс qstcondition поместить в он весь что выше и сделать несколько тестиковый так и есть компилятор выдавать ошибка вот только не там где я ожидать maincpp67 error call of overloaded 'qstconditionconst char [3] qstcomparefunctor const char [3]' is ambiguous note candidates are qstqstconditionqstconditionqvariant qstcomparefunctor qvariant note qstqstconditionqstconditionqstring qstcomparefunctor qvariant note qstqstconditionqstconditionqstring qstcomparefunctor qstring вот так-то конфликтовать конструктор 1 2 и 3 после непродолжительный раздумье я переписать класс поменять заодно порядок параметр сейчас конструктор выглядеть так qstconditionqstring stringcondition qstconditionqstfield field1 qstfield field2 comparefunctor functor qstconditionqstring fieldname1 qstring fieldname2 comparefunctor functor qstconditionqstvalue value1 qstvalue value2 comparefunctor functor qstconditionqstfield field qvariant value comparefunctor functor qstconditionqstfield field qstvalue value qstconditionqstring fieldname qstvalue value comparefunctor functor вот с простейшее случай разобраться пора переходить к монстр вспоминать про приоритет булев операция в конструкция «a and b or c и понимать что с приоритет возиться не хотеть значит надо как-то запретить создавать такой sql-запрос скобка да а где скобка там вложить условие «a and b or c записать на язык sql целевой условие f1 = f2 and f3 < 5 or f3 is null быть бы полезный некий гипотетический класс qstand и qstor qstandqstcondition"f1 = f2" qstor"f3 < 5" qstcondition"f3 is null"  конструкция монструозный но пока на стадия предварительный дизайн ничто не поделать хотя можно быть бы сделать примерно так qstcondition"f1 = f2"and qstcondition"f3" functorless 5or"f3 is null"oror andand взять на заметка это «нанизывание а пока просить обратить внимание and и or равноправный за исключение приоритет конечно то есть оба следующий вариант должный работать qstandqstcondition"f1 = f2" qstor"f3 < 5" qstcondition"f3 is null"  qstorqstcondition"f1 = f2" qstand"f3 < 5" qstcondition"f3 is null"  и вот задача как сделать этот два класс qstand и qstor оба «знать друг друг теоретически когда такой встречаться в с++ можно попробовать предопределение class b class a { // использоваться класс b } class b { // использоваться класс a } этот вариант я отбросить сразу даже не уяснить получиться бы что или нет класс qstand и qstor равноправный а если подумать они — один и то же только один выдавать «and а два «or они должный знать друг о друг как можно маленький не должный зависеть друг от друг в иной ситуация где быть бы не два вариант и/ить а три пять десять и более равноправный класс предопределение не подойти бы я не нравиться сам вид предопределение что-то здесь нарушаться не то логический стройность не то принцип сокрытие информация я стать думать далёкий и прийти к вывод что с помощь наследование qstand и qstor сделать быть бы элементарный задавать абстрактный класс-предок qstbool прописывать у он виртуальный метод и наследоваться два раз class qstbool { public qstbool virtual ~qstbool = 0 virtual qstring operatorname const } class qstand  public qstbool { public qstand virtual qstring operatorname const { return "and" } } class qstor  public qstbool { public qstor virtual qstring operatorname const { return "or" } } весь работать бы замечательный вызываться какой надо конструктор но… посмотреть ещё раз на то что хотеть получить qstandqstcondition"f1 = f2" qstor"f3 < 5" qstcondition"f3 is null"  написать конструктор qstandqstcondition condition1 qstor orcondition2 qstand должный получать в конструктор объект qstor про который он ничто не известно я мочь бы сделать такой стандартный для ооп финт qstboolqstcondition condition1 qstbool * boolcondition2 и передавать уже не объект класс qstand и qstor а указатель на этот объект весь бы работать да вот незадача мы бы прийтись либо передавать указатель на ранее описать объект либо создавать этот объект с помощь оператор new и следить потом что он удалённый 1 qstor myor1qstcondition"f3 < 5" qstcondition"f3 is null" qstandqstcondition"f1 = f2" &myor1 2 qstandqstcondition"f1 = f2" new qstorqstcondition"f3 < 5" qstcondition"f3 is null"  ни то ни другой не соответствовать тот что я хотеть получить наследование заставлять беспокоиться о лишний вещь утяжелять и без тот немаленький код есть ли выход на ум крутиться шаблон где-то я уже встречаться с подобный задача я стать обдумывать класс qstor qstand и qstbool как если бы они быть шаблонный при это ни qstand ни qstor не должный с себя притащить такой громоздкий вещь как доопределение шаблон то есть вариант qstand<andstrategy> и qstor<orstrategy> отпадать поскольку заставлять писать много но сам идея стратегия кажется быть хороший я написать два простой класс class qstandoperatorstrategy { public qstring operatorname const { return "and" } } class qstoroperatorstrategy { public qstring operatorname const { return "or" } } теперь они надо воспользоваться как ничто придумать не получаться этот qstbool я нервировать и я решить что пока забить на он написать просто класс использовать шаблон «стратегия template <class t> class booltemplate { public qstring operatorname const { t t return toperatorname } } ну допустить как теперь из это вывести qstand и qstor сначала попробовать так typedef booltemplate<qstandoperatorstrategy> qstand typedef booltemplate<qstoroperatorstrategy> qstor весь бы хорошо да вот опять не получаться запихнуть в каждый из этот класс неявный знание о друг чего-то не хватать я снова зайти в тупик решить вернуться к qstbool поэкспериментировать пусть то что я написать и не компилироваться зато оно отражать что я хотеть template <class operator> class qstbool { public qstbool {} // конструктор по умолчание qstboolconst qstcondition &cond const qstand &op {} qstboolconst qstcondition &cond const qstor &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} } typedef booltemplate<qstandoperatorstrategy> qstandtemplate typedef booltemplate<qstoroperatorstrategy> qstortemplate typedef qstbool<qstandtemplate> qstand typedef qstbool<qstortemplate> qstor и опять же как передавать в класс qstbool то о чем он совсем ну совсем ничто не знать и не надо передавать пусть он получать в каждый из конструктор самый себя — а ведь qstand и qstor — это и есть qstbool только доопределить главный что я должный быть понять весь три класс — это один и то же qstand и qstor — два сторона один монета а qstbool — это сам монета интересно что получиться если передать в qstbool оба стратегия добавлять два стратегия переписывать typedef' template <class operator1 class operator2> class qstbool { public qstbool {} qstboolconst qstcondition &cond const qstand &op {} qstboolconst qstcondition &cond const qstor &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} } typedef qstbool<qstandtemplate qstortemplate> qstand // ставить два стратегия отличаться от один typedef qstbool<qstortemplate qstandtemplate> qstor так… я чувствовать что загадка почти пасть заменять qstand и qstor тем что у я в typedef' и получать красота template <class operator1 class operator2> class qstbool { public qstbool {} qstboolconst qstcondition &cond const qstbool<qstandtemplate qstortemplate> &op {} qstboolconst qstcondition &cond const qstbool<qstortemplate qstandtemplate> &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} } и опять qstbool ничто не знать о класс qstandtemplate qstortemplate но ведь именно они я передавать в качество стратегия заменять qstandtemplate на operator1 qstortemplate на operator2 в итог код выглядеть так template <class operator1 class operator2> class qstbool { public qstbool {} qstboolconst qstcondition &cond const qstbool<operator1 operator2> &op {} qstboolconst qstcondition &cond const qstbool<operator2 operator1> &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} } быстро писать примерчик qstand andcondqstcondition"f1 = f2" qstorqstcondition"f3 = f4" qstcondition"f3 is null" qstor orcondqstcondition"f1 = f2" qstandqstcondition"f3 = f4" qstcondition"f3 is null" оба работать остаться совсем немного хотеть чтобы объект возвращать строка свой оператор добавлять в qstbool функция qstring operatorname const { operator1 t return toperatorname } фокус в тот что для qstand в качество operator1 приходить qstandtemplate а для qstor — qstortemplate и каждый раз функция выдавать именно то что нужно убедиться просто выводить результат qstand andcond2 qstor orcond2 qdebug << andcond2operatorname // выводить and qdebug << orcond2operatorname // выводить or замечательный так не расслабляться привести весь код который получиться class qstandoperatorstrategy { public qstring operatorname const { return "and" } } class qstoroperatorstrategy { public qstring operatorname const { return "or" } } template <class t> class booltemplate { public qstring operatorname const { t t return toperatorname } } template <class operator1 class operator2> class qstbool { public qstbool {} qstboolconst qstcondition &cond const qstbool<operator1 operator2> &op {} qstboolconst qstcondition &cond const qstbool<operator2 operator1> &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} qstring operatorname const { operator1 t return toperatorname } } typedef booltemplate<qstandoperatorstrategy> qstandtemplate typedef booltemplate<qstoroperatorstrategy> qstortemplate typedef qstbool<qstandtemplate qstortemplate> qstand // ставить два стратегия отличаться от один typedef qstbool<qstortemplate qstandtemplate> qstor приглядеться класс booltemplate qstandtemplate и qstortemplate — лишний убирать этот ненужный прослойка теперь подумать насчёт два конструктор qstboolconst qstcondition &cond const qstbool<operator1 operator2> &op {} qstboolconst qstcondition &cond const qstbool<operator2 operator1> &op {} из-за первое возможный конструкция вид qstandqstcondition qstand и qstorqstcondition qstor они в принцип не сильно мешать если нужно построить такой sql-код f1 and f2 and f3 только особый смысл я в это не видеть убирать один конструктор — запрещать внутри класс qstand использовать он же то же самый для qstor template <class operator1 class operator2> class qstbool { public qstbool {} qstboolconst qstcondition &cond const qstbool<operator2 operator1> &op {} qstboolconst qstcondition &cond1 const qstcondition &cond2 {} qstboolconst qstring &stringcond1 const qstring &stringcond2 {} qstring operatorname const { operator1 op1 return op1operatorname } } typedef qstbool<qstandoperatorstrategy qstoroperatorstrategy> qstand typedef qstbool<qstoroperatorstrategy qstandoperatorstrategy> qstor итак главный задача решить — и решить красиво на последок привести ещё один выкрутас вспомнить что чуть ранее я рассуждать что можно быть бы организовать «нанизывание qstcondition"f1 = f2"and qstcondition"f3" functorless 5or"f3 is null"oror andand для класс qstand и qstor этот функция быть бы полезный только я должный помнить что если нанизываться and' or уже недопустимый и наоборот как такой сделать элементарный добавлять в класс-стратегия по один функция отвечать за свой операция прийтись функция написать больший буква потому что на функция «and компилятор ругаться class qstandoperatorstrategy { public qstandoperatorstrategy andconst qstcondition &condition { // код return *this } qstring operatorname const { return "and" } } class qstoroperatorstrategy { public qstoroperatorstrategy orconst qstcondition &condition { // код return *this } qstring 
java и время часть один восемь год назад я принимать участие в проектирование и разработка сервис который быть должный обслуживать запрос пользователь с весь уголок земной шар и координировать они действие работать над проект я понять что очень часто многие важный аспект работа с время просто игнорироваться иногда это действительно не очень критично если сервис локальный и имя пользоваться только на определённый территория либо пользователь естественный образ разделить на почти не взаимодействовать между себя географический кластер однако же если сервис объединять пользователь по весь мир то без чёткий понимание принцип работа с время уже не обойтись представимый сервис в который общий событие совещание например начинаться в какой-то строго определённый время а пользователь рассчитывать на это какой время имя показывать в какой момент они беспокоить уведомление что такой день рождение и когда можно поздравить человек — в статья я попробовать это осмыслить статья не претендовать на глубина и/ить академичность это попытка систематизировать опыт и обратить внимание разработчик на не очень очевидный аспект в jdk8 появиться новое date time api в который появиться множество новый полезный класс но я не быть он упоминать также как и о отличный сторонний библиотека это отдельный большой тема который заслуживать отдельный статья плюс как я уже упомянуть я стараться рассказывать не о какой-то конкретный технология а о принцип работа в целое а в это план новое api принципиально ничто не отличаться от старое временной ося начать сильно издалёка прямо очень издалёка нарисовать ося время прямо тут начинаться разный вопрос идти ли время всегда в один направление идти ли оно равномерно непрерывно ли оно что принять за единичный вектор единый ли этот ося для весь зависеть ли от положение в пространство от скорость движение каков минимально измерять отрезка собственно тут я готовый только задавать вопрос но никак не отвечать на они есть мнение что никакой время нет но я также пока не готовый к обсуждение это вопрос но есть и уже решить момент про единица измерение весь ясно — она чётко и однозначно специфицировать расстояние от москва до вашингтон составлять примерно 7840000 метр и свет проходить это расстояние по поверхность земля минимум за 0026 секунда что совсем немало запрос на создание учётный запись пользователь в владивосток быть отработать на московский сервер только через некоторый время такой образ информация о происходить событие доступный совсем не сразу и зависеть от расстояние между точка в пространство кроме тот сам скорость течение время зависеть от скорость перемещение объект причём даже для вполне рядовой около-земной технология вроде gps текущий стандартный библиотека обработка время на java считать что никакой релятивистский эффект не существовать и никто не двигаться на около-светов скорость а ося время один и единый для весь по крайний мера в масштаб один планета — и это вполне весь мы устраивать возможно впоследствии в jdk #6543 быть реализовать новый java date time api который позволить написать сервис для внутренний офисный система «сокол тысячелетие с учёт скорость он движение и наличия/отсутствие кротовый нора ряд теперь отметить на временной ося некий момент вот например прямо сейчас я нажать на кнопка «точка нажать теперь нужно придумать способ с помощь который я смочь бы сообщить вы о тот в какой именно момент я нажать этот кнопка самый простой способ сделать это — обозначить какой-то момент время общий для мы весь с который мы весь постоянно отсчитывать временной отсчёт если этот момент время обозначить тот-самый-момент то я смочь передавать вы число свой отсчёт с это общий момент а вы смочь понять отношение между время нажатие кнопка и свой текущий время при получение мой значение в примитивный физический мир мы мочь бы встретиться и одновременно запустить одинаковый песочный часы после что спокойно разойтись по свой дело а время событие сообщать в вид высота песочный столб на наш экземпляр часы вероятно часы должный быть очень больший и громоздкий использовать мы тот-самый-момент в свой очередь мочь быть также измерение — но уже относительно какой-то более общий и важный событие в наш случай так и происходить тот-самый-момент в система unix-time числовой значение 0 который использоваться в java — это временной точка с метка 000000 1 январь 1970 от рх по utc уже по другой шкала — григорианский календарь при чем тут java для задание временной точка на временной ося в java существовать класс javautildate вообще javautildate — это позор java начинать с самый ранний версия во-первых у он название не отражать быть а во-вторых он mutable однако жизнь быть простой если вы быть воспринимать он как простой обёртка над внутренний поль тип long в который храниться количество миллисекунда с того-самого-момент — и ничто более весь остальной метод пометить как устаревший и использовать они не нужно ни в кой случай просто запомнить что javautldate тождественный по свой суть простой числовой long-значение unix-time в миллисекунда date moment = new date1451665447567l // задавать количество миллисекунда unix-time с того-самого-момент momentgettime // узнать количество миллисекунда unix-time с того-самого-момент если немного подумать то становиться понятно что в любой язык есть ограничение точность представление время поэтому javautildate как и любой другой подобный тип представлять себя вовсе не точка на временной ося а отрезка в наш случай — отрезка миллисекундный длительность но с практический точка зрение такой точность мы устраивать поэтому и далёкий быть называть это точка поскольку представление в java с самый начало 64-битный то на наш век хватить точно мы хватитdate theend = new datelongmaxvalue dateformat dateformat = simpledateformatgetdatetimeinstancesimpledateformatlong simpledateformatlong dateformatsettimezonetimezonegettimezone"utc" string text = dateformatformattheend systemoutprintlntext # august 17 292278994 71255 am utc для различный операция с время такой как чтение/установка/модификация отдельный календарный полый год месяц день часы минута секунда и прочее существовать класс javautilcalendar он также не без грех — при операция помнить что месяц идти с 0 хороший использовать константа а день идти с 1 javautilcalendar @test public void testsunday throws exception { calendar calendar = calendargetinstance calendarsettimezonetimezonegettimezone"utc" calendarset2016 calendarjanuary 5 12 30 0 calendaraddcalendardayofyear -2 assertassertequalscalendarsunday calendargetcalendardayofweek } другой мутный момент в javautilcalendar состоять в тот что при установка в немой полный дата yyyymmddhhmmss количество миллисекунда не сбрасываться в 0 а оставаться равный количество миллисекунда от предыдущий установленный момент текущий время если календарь не меняться поэтому если по условие задача в миллисекунда должный быть 0 то это пол нужно сбросить ещё один дополнительный вызов javautilcalendar @test public void testcalendarms throws exception { timezone tz = timezonegettimezone"europe/moscow" calendar calendar = calendargetinstancetz calendarsetlenientfalse calendarset2016 calendarapril 20 12 0 0 systemoutprintlncalendargettimeinmillis calendarsetcalendarmillisecond 0 systemoutprintlncalendargettimeinmillis } 1461142800808 1461142800000 первое число гулять в один три разряд в зависимость от время вызов это поведение мочь быть достаточно критичный в тест для перевод временной метка в точка на ося и обратно существовать класс javatextdateformat и он наследник javatextdateformat @test public void testformat throws exception { timezone tz = timezonegettimezone"europe/moscow" dateformat dateformat = new simpledateformat"yyyy-mm-dd hhmmss" dateformatsetlenientfalse dateformatsettimezonetz date moment = dateformatparse"2005-03-27 013000" assertassertequals"2005-03-27 013000" dateformatformatmoment } про javatextdateformat и javautilcalendar обязательно нужно сказать следующий у оба класс есть метод settimezone для явный установка временной зона крайне желательно всегда он использовать для тот чтобы обозначить что вы полностью контролировать процесс а не полагаться на временной зона по-умолчание у оба класс есть метод setlenient для установка «мягкий режим в такой режим оба класс быть снисходительно относиться к ошибка в календарный метка пытаться угадать что же вы иметь в вид на самый дело тут зависеть от ситуация но я бы рекомендовать угадывание отключать по умолчание «мягкий режим включить оба класс потоко-небезопасный и если для javautilcalendar это совершенно ожидать поскольку мы понимать что у он есть внутренний состояние то в случай javatextdateformat это для многий оказываться сюрприз также есть в старый апи ещё несколько класс javasqltimestamp — расширение subclass javautildate с наносекундный точность для работа с тип timestamp в бд javasqldate — расширение subclass javautildate для работа с тип date в бд javasqltime — расширение subclass javautildate для работа с тип time в бд кроме тот любой временной точка можно хранить в вид обычный long-значение unix-time в миллисекунда временной зона люба кто работать в глобальный компания с множество офис по весь мир или даже просто по россия знать что информация который содержаться в фраза «совещание быть в 01 январь 2016 в 140000 практически бесполезный метка «1400 не соответствовать какой-то конкретный точка на временной ося а верный сказать — соответствовать сразу несколько для тот чтобы весь собраться в видео-переговорок в один и то же время организатор совещание нужно указать кое-что ещё а именно временной зона в который мы быть интерпретировать метка «1400 часто временной зона подразумеваться по главенство головной офис «работать по московский время в противный же случай если временной зона по-умолчание вообще никак не подразумеваться то нужно задать она в явный вид например «01 январь 2016 в 140000 msk — в это случай точка на временной ося задаваться совершенно однозначно и весь собраться на совещание в один и тоже время для устранение неоднозначность при операция с временной метка в формат ччmmcc временной зона должный быть указать как при вывод временной метка так и при ввод можно не указывать временной зона явно в случай когда она можно какой-либо образ подразумевать неявно временной зона подразумеваться один и тот же по умолчание для всего сервис временной зона явно указать в профиль сам пользователь временной зона пользователь можно вычислить по он положение через гео-координата временной зона пользователь можно вычислить по он положение через ip адрес временной зона пользователь можно вычислить по он положение через косвенный признак анализ поведение текущий смещение временной зона пользователь можно вычислить через javascript наверное стоить отметить что временной зона сервис по умолчание и временной зона сервер по умолчание — это в общий совсем не один и то же bios cистем приложение и утилит мочь например работать в временной зона utc но при весь это временной зона сервис быть временной зона москва хотя конечно сильно простой когда они совпадать — в такой случай админ настраивать временной зона на сервер а программист о они не думать вообще если это как раз ваш случай — далёкий мочь не читать один и тот же временной метка можно выводить по-разному для пользователь — с использование тот временной зона который наиболее привычный для каждый например следующий временной метка указывать на один и тот же временной точка на временной ося fri jan 1 162900 msk 2016 fri jan 1 132900 utc 2016 fri jan 1 142900 cet 2016 fri jan 1 212900 sgt 2016 fri jan 1 222900 jst 2016 википедия про временной зона в java информация о временной зона представить класс javautiltimezone нужно сказать что временной зона — это не смещение нельзя сказать что gmt+3 — это europe/moscow но можно сказать что в течение всего 2016-го год временной зона europe/moscow быть соответствовать смещение gmt+3 временной зона — это весь история смещение полностью за весь исторический период а также другой дать который позволять мы правильно вычислять смещение в разный исторический момент а также производить правильный временной расчёт поисследовать временной зона — для начало посмотреть на europe/moscow europe/moscow @test public void testtzmoscow throws exception { timezone tz = timezonegettimezone"europe/moscow" systemoutprintlntzgetrawoffset systemoutprintlntzgetoffsetsystemcurrenttimemillis systemoutprintlntzusedaylighttime systemoutprintlntzgetdisplaynamefalse timezonelong localeenglish systemoutprintlntzgetdisplaynamefalse timezoneshort localeenglish systemoutprintlntzgetdisplaynametrue timezonelong localeenglish systemoutprintlntzgetdisplaynametrue timezoneshort localeenglish systemoutprintlntzgetdisplaynamefalse timezonelong localefrench systemoutprintlntzgetdisplaynamefalse timezoneshort localefrench systemoutprintlntzgetdisplaynametrue timezonelong localefrench systemoutprintlntzgetdisplaynametrue timezoneshort localefrench } 10800000 10800000 false moscow standard time msk moscow daylight time msd heure standard de moscou msk heure avancée de moscou msd видеть что у зона europe/moscow текущий базовый смещение составлять +3 час относительно utc а общий смещение в данный момент составлять также +3 час перевод стрелка на летний время в перспектива отсутствовать у зона есть отдельный имя для летний и зимний время теперь посмотреть на парижский время europe/paris @test public void testtzparis throws exception { timezone tz = timezonegettimezone"europe/paris" systemoutprintlntzgetrawoffset systemoutprintlntzgetoffsetsystemcurrenttimemillis systemoutprintlntzusedaylighttime systemoutprintlntzgetdisplaynamefalse timezonelong localeenglish systemoutprintlntzgetdisplaynamefalse timezoneshort localeenglish systemoutprintlntzgetdisplaynametrue timezonelong localeenglish systemoutprintlntzgetdisplaynametrue timezoneshort localeenglish systemoutprintlntzgetdisplaynamefalse timezonelong localefrench systemoutprintlntzgetdisplaynamefalse timezoneshort localefrench systemoutprintlntzgetdisplaynametrue timezonelong localefrench systemoutprintlntzgetdisplaynametrue timezoneshort localefrench } 3600000 3600000 true central european time cet central european summer time cest heure d'europe centrale cet heure d'été d'europe centrale cest базовый смещение составлять +1 час относительно utc общий смещение в данный момент составлять также +1 час переход на летний время в перспектива у зона есть также присвоить два имя — для зимний и для летний время отдельно теперь посмотреть на зона «gmt+5 это фактически не совсем временной зона — у нея нет история нет летний время а смещение постоянно gmt+5 @test public void testgmt5 throws exception { timezone tz = timezonegettimezone"gmt+5" systemoutprintlntzgetrawoffset systemoutprintlntzgetoffsetsystemcurrenttimemillis systemoutprintlntzusedaylighttime systemoutprintlntzgetdisplaynamefalse timezonelong localeenglish systemoutprintlntzgetdisplaynamefalse timezoneshort localeenglish systemoutprintlntzgetdisplaynametrue timezonelong localeenglish systemoutprintlntzgetdisplaynametrue timezoneshort localeenglish systemoutprintlntzgetdisplaynamefalse timezonelong localefrench systemoutprintlntzgetdisplaynamefalse timezoneshort localefrench systemoutprintlntzgetdisplaynametrue timezonelong localefrench systemoutprintlntzgetdisplaynametrue timezoneshort localefrench } 18000000 18000000 false gmt+0500 gmt+0500 gmt+0500 gmt+0500 gmt+0500 gmt+0500 gmt+0500 gmt+0500 так и есть смещение постоянно составлять +5 часы относительно gmt и никогда не меняться пример продолжить рассказывать пример то что слишком долго объяснять на слово для начало посмотреть что происходить в 2005 год в временной зона «europe/moscow europe/moscow - 2005$ zdump -v /usr/share/zoneinfo/europe/moscow | grep 2005 /usr/share/zoneinfo/europe/moscow sat mar 26 225959 2005 ut = sun mar 27 015959 2005 msk isdst=0 gmtoff=10800 /usr/share/zoneinfo/europe/moscow sat mar 26 230000 2005 ut = sun mar 27 030000 2005 msd isdst=1 gmtoff=14400 /usr/share/zoneinfo/europe/moscow sat oct 29 225959 2005 ut = sun oct 30 025959 2005 msd isdst=1 gmtoff=14400 /usr/share/zoneinfo/europe/moscow sat oct 29 230000 2005 ut = sun oct 30 020000 2005 msk isdst=0 gmtoff=10800 отлично мы видеть перевод стрелка на летний и обратно на зимний время посмотреть на то что происходить в этот момент с временной метка для начало — переход на зимний время переход на зимний время @test public void testwintertime throws exception { timezone tz = timezonegettimezone"europe/moscow" dateformat dateformat = new simpledateformat"yyyy-mm-dd hhmmss z" dateformatsetlenientfalse dateformatsettimezonetz calendar calendar = calendargetinstance calendarsetlenientfalse calendarsettimezonetimezonegettimezone"utc" calendarset2005 calendaroctober 29 22 0 0 for int i = 0 i < 62 i++ { string mark = dateformatformatcalendargettime systemoutprintf"%s - %d %s\n" mark tzgetoffsetcalendargettimeinmillis tzindaylighttimecalendargettime calendaraddcalendarminute +1 } } 2005-10-30 020000 msd - 14400000 true 2005-10-30 020100 msd - 14400000 true  2005-10-30 025800 msd - 14400000 true 2005-10-30 025900 msd - 14400000 true 2005-10-30 020000 msk - 10800000 false 2005-10-30 020100 msk - 10800000 false видеть что после 025900 msd стрелка сдвигаться на час назад и следующий метка идти уже 020000 msk — зимний время также временной зона говорить о тот что летний время закончиться а смещение измениться с gmt+4 на gmt+3 в пример есть интересный нюанс c помощь зона «europe/moscow совершенно невозможно установить в календарь точка соответствующий метка 020000 msd — устанавливаться точка 020000 msk что на час поздний чем нужно мы чтобы задать этот точка как начать отсчёт приходиться прибегать к услуга временной зона utc в который можно установить весь другой вариант мочь быть установка точка 010000 msd в зона «europe/moscow и прибавление час теперь — переход на летний время переход на летний время @test public void testsummertime { timezone tz = timezonegettimezone"europe/moscow" dateformat dateformat = new simpledateformat"yyyy-mm-dd hhmmss z" dateformatsetlenientfalse dateformatsettimezonetz calendar calendar = calendargetinstance calendarsetlenientfalse calendarsettimezonetimezonegettimezone"utc" calendarset2005 calendarmarch 26 22 0 0 for int i = 0 i <= 60 i++ { string mark = dateformatformatcalendargettime systemoutprintf"%s - %d %s\n" mark tzgetoffsetcalendargettimeinmillis tzindaylighttimecalendargettime calendaraddcalendarminute +1 } } 2005-03-27 010000 msk - 10800000 false 2005-03-27 010100 msk - 10800000 false  2005-03-27 015800 msk - 10800000 false 2005-03-27 015900 msk - 10800000 false 2005-03-27 030000 msd - 14400000 true 2005-03-27 030001 msd - 14400000 true видно что после 015900 msk сразу следовать 030000 msd — то есть перевод стрелка на час вперёд временной зона сигнализировать что в этот момент смещение меняться с gmt+3 на gmt+4 а также появляться флаг летний время но что быть если мы попробовать обработать метка «2005-03-27 023000 в зона «europe/moscow — в теория такой метка существовать не должный несуществующий метка @test public void testmissing throws exception { timezone tz = timezonegettimezone"europe/moscow" dateformat dateformat = new simpledateformat"yyyy-mm-dd hhmmss" dateformatsetlenientfalse dateformatsettimezonetz date moment = dateformatparse"2005-03-27 023000" systemoutprintlnmoment } javatextparseexception unparseable date "2005-03-27 023000" весь верно — в строгий режим мы получать исключение посчитать длительность день в день перевод стрелка на зимний время перевод на зимний время @test public void testwinterday { timezone tz = timezonegettimezone"europe/moscow" calendar calendar = calendargetinstance calendarsetlenientfalse calendarsettimezonetz calendarset2005 calendaroctober 30 0 0 0 date time1 = calendargettime calendaraddcalendardayofyear +1 date time2 = calendargettime systemoutprintlntimeunitmillisecondstohourstime2gettime - time1gettime } 25 с 2005-10-30 000000 msd до 2005-10-31 000000 msk прошлый 25 часы а не 24 теперь проверить день переход на летний время переход на летний время @test public void testsummerday { timezone tz = timezonegettimezone"europe/moscow" calendar calendar = calendargetinstance calendarsetlenientfalse calendarsettimezonetz calendarset2005 calendarmarch 27 0 0 0 date time1 = calendargettime calendaraddcalendardayofyear +1 date time2 = calendargettime systemoutprintlntimeunitmillisecondstohourstime2gettime - time1gettime } 23 c 2005-03-27 000000 msk до 2005-03-28 000000 msd пройти 23 час а не 24 этот два последний пример посвятить тем кто прибавлять 24*60*60*1000 миллисекунда не как 24 час а как календарный день вы мочь сказать теперь такой проблема нет так как большой нет и перевод на летнее/зимный время на это я мочь ответить следующий ваш программа должный работать корректно в люба временной зона а не только зона «europe/moscow расчёт «назад в прошлое весь равно требовать корректный подход в 2016 год у мы быть выбор госдума а в 2018 быть выбор президент — так что я думать что история ещё не закончить javasqltime javasqldate тип предназначаться для работа с sql тип time и date соответственно подразумеваться что оба значение от временной зона не зависеть но к сожаление это не совсем так поскольку оба тип являться наследник javautildate — интерпретация день-часы зависеть от временной зона проблема с тип javasql @test public void testsqltime throws exception { // предположим что сейчас 2015-01-01 010000 msk calendar calendar = calendargetinstance calendarsettimezonetimezonegettimezone"europe/moscow" calendarsettimeinmillis0 calendarset2015 calendarjanuary 10 1 0 0 long now = calendargettimeinmillis // создавать инстанс javasqltime javasqltime sqltime = new javasqltimenow javasqldate sqldate = new javasqldatenow // теперь выводить значение время в временной зона europe/london dateformat timeformat = new simpledateformat"hhmmss" timeformatsettimezonetimezonegettimezone"europe/london" assertassertequals"220000" timeformatformatsqltime // теперь выводить значение дата в временной зона europe/london dateformat dateformat = new simpledateformat"yyyy-mm-dd" dateformatsettimezonetimezonegettimezone"europe/london" assertassertequals"2015-01-09" dateformatformatsqldate } в принцип оба тип справляться с задача перенос информация от бизнес-логика в jdbc-драйвер поскольку обычно код и там и там работать в один временной зона но в более продвинуть случай включая сериализация надо быть очень аккуратный при использование этот класс в новый api для соответствующий тип подобный проблема решить utc gmt большинство знать что gmt и utc — это особый обозначение относительно который оформляться смещение в другой временной зона но не весь знать что utc и gmt — это не совсем один и тоже формально я иметь в вид то что метка «2015-12-01 000000 gmt и «2015-12-01 000000 utc обозначать различный хоть и близкие точка на временной ося gmt вычисляться астрономичёска по положение земля относительно другой объект gmt также напрямую использоваться в качество временной зона в некоторый страна поскольку вращение земной шар хаотично замедляться земля оказываться в один и тот же положение через весь увеличиваться промежуток время такой образ расстояние между временной точка по соседний метка по gmt например «100001 и «100002 мочь точно не равняться один секунда utc ввести на замена gmt и рассчитываться по атомный часы непосредственно в качество временной зона не использоваться только как опора для смещение в utc расстояние между временной метка например «100001 и «100002 совершенно одинаковый и строго равно один секунда замедление земной вращение и накапливаться отличие от gmt решаться ввод лишний секунда в год или даже два — а именно секунда координация leap second такой образ разница между точка с одинаковый метка в gmt и utc никогда не превышать один секунда писать что время utc практически повсюду вытеснить gmt и что использовать обозначение смещение в вид gmt+3 уже давно моветон — правильно использовать обозначение utc+3 ни gmt ни utc летний время не иметь надо сказать что unix-time который использоваться в java ни utc ни gmt напрямую не соответствовать с один сторона в unix-time разница между соседний метка составлять всегда равно 1 секунда с другой сторона наличие leap second в unix-time не предполагаться временной зона по умолчание отображать ли вы временной зона при вывод явно или не отображать запрашивать ли вы временной зона при ввод или не запрашивать указывать ли вы временной зона при операция над время или не указывать — какой-то временной зона весь равно присутствовать в этот операция неявно если вы не указать свой — быть использовать временной зона по-умолчание термин временной зона по-умолчание уже быть упомянуть несколько раз по текст выше весь потому что без это понятие ничто и объяснить толком нельзя весь операция с время вывод и ввод временной метка требовать временной зона то что вы она не указывать не означать что она нет — просто она браться по-умолчание но весь снова не так-то просто — по умолчание для кто и что начать с ядро в мануал к hwclock сказать что в ядро есть внутренний концепция временной зона но она почти никто не использовать кроме некоторый редкий модуль — вроде драйвер файловый система fat проинформировать ядро о смена временной зона можно этот же команда hwclock прикладной приложение определять временной зона по-умолчание несколько способ во-первых общесистемный временной зона полный информация о она в ubuntu храниться в файл мочь быть симлинк /etc/localtime а имя этот временной зона — в файл /etc/timezone $ cat /etc/timezone europe/moscow $ file /etc/localtime /etc/localtime timezone data version 2 15 gmt time flags 15 std time flags no leap seconds 77 transition times 15 abbreviation chars $ zdump -v /etc/localtime | head -n 10 /etc/localtime -9223372036854775808 = null /etc/localtime -9223372036854689408 = null /etc/localtime wed dec 31 212942 1879 ut = wed dec 31 235959 1879 lmt isdst=0 gmtoff=9017 /etc/localtime wed dec 31 212943 1879 ut = thu jan 1 000000 1880 mmt isdst=0 gmtoff=9017 /etc/localtime sun jul 2 212942 1916 ut = sun jul 2 235959 1916 mmt isdst=0 gmtoff=9017 /etc/localtime sun jul 2 212943 1916 ut = mon jul 3 000102 1916 mmt isdst=0 gmtoff=9079 /etc/localtime sun jul 1 202840 1917 ut = sun jul 1 225959 1917 mmt isdst=0 gmtoff=9079 /etc/localtime sun jul 1 202841 1917 ut = mon jul 2 000000 1917 mst isdst=1 gmtoff=12679 /etc/localtime thu dec 27 202840 1917 ut = thu dec 27 235959 1917 mst isdst=1 gmtoff=12679 /etc/localtime thu dec 27 202841 1917 ut = thu dec 27 230000 1917 mmt isdst=0 gmtoff=9079 установить временной зона для система можно специальный команда для ваш дистрибутив для ubuntu это $ dpkg-reconfigure tzdata а также есть вежливый утилит tzselect $ tzselect please identify a location so that time zone rules can be set correctly please select a continent ocean "coord" or "tz" 1 africa 2 americas 3 antarctica 4 arctic ocean 5 asia 6 atlantic ocean 7 australia 8 europe 9 indian ocean 10 pacific ocean 11 coord - i want to use geographical coordinates 12 tz - i want to specify the time zone using the posix tz format # второе способ указание временной зона являться переменный окружение tz в который можно указать идентификатор временной зона индивидуально для каждый программа и/ить пользователь $ echo $tz $ date wed dec 30 201818 msk 2015 $ tz=utc date wed dec 30 171825 utc 2015 $ tz=europe/london date wed dec 30 171835 gmt 2015 $ tz=europe/paris date wed dec 30 181840 cet 2015 некоторый программа можно попросить о специфический временной зона в настройка и/ить аргумент командный строка $ date --utc fri jan 1 083436 utc 2016 кстати можно попросить date вывести только текущий временной зона без время $ date +%z msk но это для обычный программа под libc а у мы целый платформа java поэтому кроме этот два перечисленный возможность у мы есть ещё два можно указать аргумент для запуск jvm $ cat << eof | scala -dusertimezone=europe/paris print"%s\n%s\n"formatjavautiltimezonegetdefaultgetid new javautildate eof  europe/paris wed dec 30 192400 cet 2015 а можно прямо в код установить временной зона по умолчание через метод timezonesetdefaulttimezone timezone $ cat << eof | scala > javautiltimezonesetdefaultjavautiltimezonegettimezone"america/losangeles" > print"%s\n%s\n"formatjavautiltimezonegetdefaultgetid new javautildate > eof  america/losangeles wed dec 30 102545 pst 2015 или даже весь сразу $ tz=europe/london cat << eof | scala -dusertimezone=europe/paris javautiltimezonesetdefaultjavautiltimezonegettimezone"america/losangeles" print"%s\n%s\n"formatjavautiltimezonegetdefaultgetid new javautildate eof  america/losangeles wed dec 30 103728 pst 2015 база временной зона законодатель и правительство различный страна и даже регион не сидеть сложить рука регулярно включая/отключать летний время или даже перемещать регион между часовой пояс критически важный иметь на система весь последний информация о подобный изменение — в противный случай время быть вводиться и выводиться неправильно человек быть получать смс-ка в время свой сон а расчёт вроде "+2 календарный дня" быть неправильный в linux обычный программа на libc использовать база временной зона состоять из файл в директория /usr/share/zoneinfo этот файл принадлежать пакет tzdata за который активно присматривать разработчик каждый из дистрибутив этот пакет своевременно обновляться и проблема с он я не помнить в крайний случай весь информация можно обновить вручную если ваш развернуть версия linux уже большой никто не поддерживаться к счастие я не прийтись расписывать тут формат содержимое этот файл ни история они возникновение — поскольку на хабра уже есть отличный статья на этот тема не менее отличный статья есть в википедия но не весь так просто java использовать свой собственный база с временной зона и если для openjdk как правило можно просто и легко обновить пакет tzdata-java штатный пакетный менеджер то для oracle jdk прийтись либо апгрейдить весь jdk целиком на новый версия либо пользоваться отдельный специальный утилита для обновление база временной зона в уже установленный jdk кстати упомянуть выше библиотека joda-time не использовать ни системный база tzdata ни база из jvm — да у нея есть ещё один свой внутренний база временной зона который нужно также обновлять отдельный и неповторимый способ для python нужно ставить и затем также не забыть обновлять отдельный библиотека для javascript есть куча какой-то сторонний библиотека как минимум я точно помнить что поддержка есть в google closure вообще тема тот что тот или иной софт использовать свой личный база с временной зона всплывать регулярно например модуль календарь lightning для почтовый клиент thunderbird хранить свой личный sqlite-база с часовой зона и поэтому при последний изменение в наш государство я приходиться делать прямая интервенция в этот база для корректировка иначе весь митинг просто плыть по время вообще есть ощущение что в основной масса разработчик не страдать паранойя как я про временной зона никто не думать и в базовый поставка свой платформа tzdata никто не включать — кроме разработчик jvm отдельный слово я хотеть бы сказать про android быть краткий — временной зона в android это боль при разработка платформа никто не подумать про отдельный механизм обновление tzdata как и про то что у законодатель по весь мир есть страшный зуд к перемена кто бы мочь подумать база с временной зона меняться только в случай если вендор прошивка это захотеть учитывать то что некоторый вендор переставать узнавать свой собственный телефон уже через полгода то можно сказать что на многий аппарат tzdata просто не обновляться никогда продвинуть пользователь менять текущий временной зона в свой аппарат на другой более-менее подходящий текущий условие например europe/minsk вместо europe/moscow непродвинуть пользователь весь также жить в europe/moscow gmt+4 и просто переводить стрелка — в результат что временной метка событие в весь программа сдвигаться на час назад есть конечно вариант с рутирование и использование сторонний решение для обновление но весь пользователь рутировать телефон не заставить календарь про необходимость указание временной зона вместе с метка уже быть сказать однако настоящий параноик должный бы указывать ещё и система летоисчисление мы не делать это потому как наиболее развить часть население земной шар уже договориться использовать григорианский календарь хотя мы до сей пора в удовольствие праздновать новый год по юлианский календарь а некоторый из мы высказывать другой отличаться точка зрение на то как именно правильно считать дата есть совершенно другой порой достаточно странный система счисление в который один и тот же временной точка можно отобразить совершенно по-иному например — календарь чучхе вообще такой система оказываться достаточно много а весь мы просто не задумываться что наш календарь лишь один из многий возможно самый использовать но не единственный поиграться с некоторый можно тут leap year високосный год — год в который 366 день а не 365 день как в обычный год в високосный год добавляться один день к февраль — 29 февраль формула определение тот что год високосный простой и описать в википедия leap second а вот с лишний секунда секунда координация весь сильно сложный быть процесс в тот что земля постоянно немножко замедляться и она положение относительно звезда по один и тем же метка время постоянно меняться если не производить коррекция то время день и ночь быть постоянно сдвигаться чтобы это не происходить учёный отслеживать положение земля вычислять необходимый коррекция и вносить она в план корректировка поскольку процесс замедление хаотичный долгосрочный план по коррекция составить невозможно — определение необходимость ввод секунда коррекция происходить по текущий ситуация также теоретически возможный ввод отрицательный секунда координация — в случай если земной шар вдруг наоборот ускориться подразумеваться что при наличие секунда координация время по utc течь с появление 60-ть секунда 235958 235959 235960 # leap second 000000 000001 в концепция unix-time не существовать понятие секунда с номер 60 «because it does not handle leap seconds it is neither a linear representation of time nor a true representation of utc для тот чтобы хоть как-то соответствовать время по utc использоваться трюк с перевод время на секунда назад в полночь 235958 235959 235959 # leap second 000000 000001 трюк проводиться либо через сервис точный время либо сам ядро автономно на основание дать в файл таймзона это именно хак который иметь свой негативный последствие количество секунда между 235900 и 000100 следующий день равно 120 а не 121 как должный быть поскольку один секунда мы съедать весь прошлое смещаться на секунда вперёд в java поскольку весь время завязать на концепция unix-time также нет никакой учёт leap-second нет ни в старый api ни в новый api ни в библиотека joda-time при это сам информация о leap-second в база tzdata есть а в javadoc к метод javautildate#getseconds говориться о тот что в некий пока несуществующий гипотетический java-машина значение поль секунда мочь быть равно 60 или даже 61 сначала проверить то что в момент leap second класс java этот секунда не учитывать старое api @test public void testleapsecond1 throws exception { timezone tz = timezonegettimezone"utc" calendar calendar = calendargetinstance calendarsetlenientfalse calendarsettimezonetz calendarset2015 calendarjune 30 23 59 0 date d1 = calendargettime calendarset2015 calendarjuly 1 0 1 0 date d2 = calendargettime long elapsed = d2gettime - d1gettime systemoutprintlntimeunitmillisecondstosecondselapsed } 120 результат — 120 секунда а не 121 как должный быть теперь проверить новое api новое api @test public void testleapsecond2 throws exception { zoneddatetime beforeleap = zoneddatetimeof2015 6 30 23 30 0 0 zoneoffsetutc zoneddatetime afterleap = zoneddatetimeof2015 7 1 0 30 0 0 zoneoffsetutc long elapsed = afterleaptoinstanttoepochmilli - beforeleaptoinstanttoepochmilli systemoutprintlntimeunitmillisecondstosecondselapsed } 3600 ровно 3600 секунда а должный быть 3601 выяснить сколько именно секунда координация быть за весь время самый простой — проверить это на страница в вика проверить и другой способ информация о секунда координация есть в дубликат временной зона в директория /usr/share/zoneinfo/right $ file /usr/share/zoneinfo/right/utc /usr/share/zoneinfo/right/utc timezone data version 2 1 gmt time flag 1 std time flag 26 leap seconds no transition times 1 abbreviation char $ zdump -v /usr/share/zoneinfo/right/utc | grep '5960' | wc -l 26 в основной директория /usr/share/zoneinfo файл таймзона информация о секунда координация не содержимый $ file /usr/share/zoneinfo/utc /usr/share/zoneinfo/utc timezone data version 2 1 gmt time flag 1 std time flag no leap seconds no transition times 1 abbreviation char $ zdump -v /usr/share/zoneinfo/utc | grep '5960' | wc -l 0 как бы мы не смотреть — всего получаться 26 такой секунда теперь посчитать сколько секунда прошлый между 1970-01-01 000000 utc и 2016-01-01 000000 utc посчитать два способ в java по unix-time и какой-нибудь другой более высокоточный способ сначала java 1970-01-01 000000 utc и 2016-01-01 000000 utc - java @test public void testepochdiff throws exception { zoneddatetime s = zoneddatetimeof1970 1 1 0 0 0 0 zoneoffsetutc zoneddatetime f = zoneddatetimeof2016 1 1 0 0 0 0 zoneoffsetutc long elapsed = ftoinstanttoepochmilli - stoinstanttoepochmilli systemoutprintlntimeunitmillisecondstosecondselapsed } 1451606400 получиться 1451606400 перепроверить $ dateutilsddiff --from-zone "right/utc" -f '%s' "1970-01-01 000000" "2016-01-01 000000" 1451606400 весь сходиться — также 1451606400 секунда теперь натравить высокоточный оружие $ dateutilsddiff --from-zone "right/utc" -f '%rs' "1970-01-01 000000" "2016-01-01 000000" 1451606425 вот оно теперь 1451606425 секунда я не очень понятно почему разница составлять 25 а не 26 секунда но другой точный калькулятор я пока что не найти становиться понятно что с путешествие в время есть серьёзный проблема — по крайний мера если мы делать движок управление с использование стандартный java установить точный время мы не смочь точно рассчитать количество секунда на который мы должный откатиться — ошибка составить до полминуты точный путешествие в будущее невозможный вообще в принцип — поскольку количество секунда координация заранее предопределить невозможно currenttimemillis nanotime как практически на люба другой платформа в java существовать два источник время один отображать текущий метка на общий временной ося два — считать время с момент подача питание на процессор javalangsystem#currenttimemillis — возвращать количество миллисекунда прошедшее с полночь 1 январь 1970 по временной зона utc именно этот метод использоваться при создание новый экземпляр javautildate и javautilcalendar несмотря на то что возвращать значение измеряться в миллисекунда реальный гранулярность мочь быть сильно выше — до десяток миллисекунда никакой гарантия на монотонность нет значение мочь скакать вперёд и назад — в результат перевод системный часы оператор или сервис точный время javalangsystem#nanotime — возвращать некоторый абстрактный количество наносекундный «тиковый значение тиковый не обязательно браться с процессорный счётчик — во-первых на современный железо есть множество другой источник точный сигнал во-вторых — на многопроцессорный система есть проблема с тем что у каждый из процессор счётчик свой и поэтому последовательный вызов метод мочь возвращать скакать значение в разный поток конкретный реализация зависеть от железо тип и версия операционный система также несмотря на наносекундный точность результат никакой гарантия на реальный гранулярность не даваться — точность также мочь снижаться до десяток миллисекунда но никак не худой гранулярность javalangsystem#currenttimemillis этот и другой вопрос подробно разобрать тут inside the hotspot vm clocks timers and scheduling events is systemnanotime completely useless linux faq for clockgettimeclockrealtime измерение длительность операция исходить из из предыдущий глава казалось бы можно сделать только один-единственный вывод о правильный измерение время — нужно использовать только метод javalangsystem#nanotime метод javalangsystem#currenttimemillis не подходить поскольку он значение мочь скакать при изменение системный время этот вывод подтверждаться также чтение javadoc к оба метод тем не менее мы смотреть в метод класс javalangthread и видеть нечто очень странный javalangthread#joinlong public final synchronized void joinlong millis throws interruptedexception { long base = systemcurrenttimemillis long now = 0 if millis < 0 { throw new illegalargumentexception"timeout value is negative" } if millis == 0 { while isalive { wait0 } } else { while isalive { long delay = millis - now if delay <= 0 { break } waitdelay now = systemcurrenttimemillis - base } } } по весь видимость это что-то очень древний поскольку например в javautilconcurrentexecutorservice использоваться уже systemnanotime этот же вопрос также очень актуальный для различный сторонний библиотека а уже сколько измерение длительность на база systemcurrenttimemillis реализовать в самописон код — просто не сосчитать время при тестирование не быть растекаться по древо в это вопрос — просто рассказать про свой успешный опыт в уже упомянуть вначале проект восьмилетный давность проект быть достаточно ответственный — деньга балл сложный бизнес-логика откат операция по таймаут смена статус по истечение время и весь подобный разработчик быть два я и фронтендер тестировщик не быть вообще на сервер у мы быть фреймворк для ioc инжекция принцип low-coupling и high-cohesion не то что бы это быть необходимый запас для разработка но если начать читать соответствующий книга становиться трудно остановиться единственный что вызывать у я опасение — это тест нет ничто более беспомощный безответственный и испортить чем разработчик начать писать тест но я знать что рано или поздно мы перейти и на этот дрянь в общий я сразу же решительно завести интерфейс orgmyprojectchronometerpublic interface chronometer { date getcurrentmoment long getcurrentms long getcurrentticks } этот интерфейс инжектиться практически везде где нужно текущий время класс для отслеживание длительность orgmyprojecttimer получать этот интерфейс в конструктор самый тяжёлый при такой подход — помнить что можно а что нельзя можно и нельзя# так нельзя usersetcreatednew date usersetmodifiednew date # так можно date now = chronometergetcurrentmoment usersetcreatednow usersetmodifiednow # так нельзя calendar calendar = calendargetinstance calendaraddcalendardayofyear -3 date expiration = calendargettime # так можно calendar calendar = calendargetinstance calendarsettimezonethisoperationtimezone calendarsettimechronometergetcurrentmoment calendaraddcalendardayofyear -3 date expiration = calendargettime полностью отследить такой кусок конечно можно только в свой личный код но мы важный чтобы этот правильный подход реализовываться в код отвечать за персистентность и бизнес-логика при обсуждение вопрос тестирование никак невозможно не вспомнить про база дать удаление устаревший записей# плохой вариант - нетестировать вообще delete from records where created <= datesubnow interval 30 day # вариант уже тестировать - но весь равно не очень хорошо delete from records where created <= datesubnow interval 30 day # а так надо - параметр полностью вычисляться в бизнес логика и/ить тест delete from records where created <= expiration при такой подход если он корректно реализовать везде весь автотест можно отправить в любой время — весь код можно легко выполнить в 1953 год или в 2312 пример теста// устанавливать "текущее" время mockchronometersetcurrenttime"21200610 153311" // сохранять запись с параметр относительно "текущего" время period period = new period periodsetstarttimeutilsparse"21200601 000000" periodsetendtimeutilsparse"21200701 000000" periodsetindex"wdwwddwwdw" periodsettypeperiodtypemonth periodsetdescription"efefef" periodsdaosaveperiod // что-то проверять - весь логика быть думать что сейчас на часы "21200610 153311" // время не двигаться пока мы он не сдвинуть вручную // поэтому в самый код тест мы мочь делать что-угодно и сколь угодный долго готовить дать например checksomething1 //  прошлый 2 день и ещё немного mockchronometersetcurrenttime"21200612 153814" // проверка тот как код реагировать на повторный вызов по истечение время checksomething2 если вы уже ткнуть палец в монитор и сказать я кг/ за то что я не поставить временной зона в вызов mockchronometer и timeutils — то тогда вот мой вы респект оставлять они в тест на откуп текущий временной зона — значит сделать тест хрупкий на самый же дело оба класс по-умолчание оперировать в временной зона utc всегда когда зона не указать специально в аргумент метод в java 8 в новый date time api появиться интерфейс javatimeclock который ввести ровно для тот же цель — но я не уверенный что общественность это уже оценить альтернативный подход — запускать тест в отдельный jvm с указание агент который быть производить инструментация код с цель перехват вызов к systemnanotime и systemcurrenttimemillis такой подход я не пробовать а беглый поиск готовый решение не предлагать более здравый вариант кажется простой препроцессинг исходный код в процесс сборка — замена вызов systemnanotime systemcurrenttimemillis new date calendargetinstance на вызов к свой класс spring framework 8 год назад в spring быть localeresolver но не быть timezoneresolver что как я кажется вполне характеризовать общий отношение к проблема прийтись написать свой комплект а заодно сделать сабкласс dispatcherservlet после не очень многочисленный но достаточно настойчивый просьба сообщество мой в тот число штатный резолвера временной зона запрос быть ввести в 4-й версия фреймворка mvc отдельный вопрос — как знать временной зона в контроллер правильно установить она для шаблонизатор в freemarker предусмотреть специальный настройка для текущий рендеринг <#setting timezone="europe/moscow"> для jsp также можно указать временной зона индивидуально для одиночный вывод или сразу для всего блок <fmtformatdate type="both" value="${now}" timezone="europe/moscow"/> <fmttimezone value="europe/moscow"> <fmtformatdate type="both" value="${now}"/> </fmttimezone> в velocity тоже что-то есть но я лично не пробовать хранение время в бд самый бронебойный способ хранение временной точка в бд — этот передача значение javautildate#gettime в база в вид простой числовой long-значение unix-time соответственно при чтение мы преобразовать long в javautildate с помощь конструктор это можно сделать в конвертор hibernate или rowmapper' база дать в это случай ничто не знать про время поэтому никакой внезапный эффект мы получить не смочь если очень надо вывести временной точка в вид метка то например в mysql всегда можно вызвать метод fromunixtime такой способ подходить если в запрос в бд и/ить в хранить процедура нет операция с время если же такой операция есть что для простота разработка хороший конечно бы избегать то вы уже в курс что без временной зона они не проходить в это случай надо понять какой именно временной зона действовать в ход операция преобразование или ввода/вывод временной зона указанный по-умолчание для сервер временной зона указанный по-умолчание для субд временной зона указанный по-умолчание для база дать временной зона указанный по-умолчание для таблица временной зона указанный по-умолчание для соединение временной зона храниться в ячейка вместе с временной метка я ни в кой случай не хотеть сказать что не надо хранить время в специально предназначить для это тип просто вариант с прямая хранение long очень сложно как-либо сломать я не смочь придумать как и такой способ никак не зависеть от тип хранилище при хранение время в специально предназначить для это тип нужно обязательно проверить что при указанный настройка бд и она драйвер указанный значение время писаться читаться и выводиться в родной консоль управление этот бд консистентный даже при смена часовой пояс на ход неконсистентность мочь быть вызвать тем что бд на самый дело мочь хранить временной метка а не точка например в случай mysql для хранение время существовать два стандартный тип timestamp and datetime судить по официальный документация timestamp хранить именно временной точка и получить значение «2015-01-01 120000 msk от клиент в московский временной зона вернуть «2015-01-01 090000 utc для другой клиент в временной зона utc что соответствовать один временной точка и совершенно правильно по свой суть а с тип datetime получить от msk-клиент «2015-01-01 120000 msk сервер mysql вернуть utc-клиент «2015-01-01 120000 utc что соответствовать уже другой временной точка и весь дальнейший расчёт быть неверный проверить mysql сначала весь подготовить запуск бд$ sudo docker run --name mysql-time -e mysqlrootpassword=root -d mysql/mysql-server57 $ sudo docker ps -a container id image command created status ports names 82bb3eebc8bc mysql/mysql-server57 /entrypointsh mysq 5 minutes ago up 5 minutes 3306/tcp mysql-time $ sudo docker exec -it 82bb3eebc8bc bash [root@82bb3eebc8bc /]# tz=europe/moscow mysql -u root -p enter password mysql> create database test query ok 1 row affected 000 sec mysql> use test database changed mysql> create table dates id integer t1 timestamp t2 datetime query ok 0 rows affected 002 sec устанавливать в сессия зона «europe/moscow и создавать запись europe/moscowmysql> set timezone = 'europe/moscow' query ok 0 rows affected 000 sec mysql> select @@sessiontimezone +---------------------+ | @@sessiontimezone | +---------------------+ | europe/moscow | +---------------------+ 1 row in set 000 sec mysql> insert into dates values 1 '2015-01-01 120000' '2015-01-01 120000' query ok 1 row affected 000 sec mysql> select * from dates where id = 1 +------+---------------------+---------------------+ | id | t1 | t2 | +------+---------------------+---------------------+ | 1 | 2015-01-01 120000 | 2015-01-01 120000 | +------+---------------------+---------------------+ 1 row in set 000 sec менять временной зона сессия на «utc и читаемый запись снова utcmysql> set timezone = 'utc' query ok 0 rows affected 000 sec mysql> select @@sessiontimezone +---------------------+ | @@sessiontimezone | +---------------------+ | utc | +---------------------+ 1 row in set 000 sec mysql> select * from dates where id = 1 +------+---------------------+---------------------+ | id | t1 | t2 | +------+---------------------+---------------------+ | 1 | 2015-01-01 090000 | 2015-01-01 120000 | +------+---------------------+---------------------+ 1 row in set 000 sec видеть что временной метка поль t1 измениться — как и должный быть а временной метка для поль t2 при смена временной зона не измениться и теперь соответствовать другой точка на числовой ося для большинство бд существовать специфичный тип который хранить только дата и только время такой тип невозможно привести к временной точка не указать временной зона о чем мы уже знать но также необходимый дополнить этот значение недоставать частью время или дата соответственно на самый дело можно и не приводить такой тип к временной точка если в это нет никакой необходимость — например в случай простой вывод день исторический событие просто нужно помнить что это метка или даже она часть а не временной точка на ося многие бд иметь разновидность тип который кроме самый временной точка хранить дополнительный и информация о временной зона в который она быть ввести например это мочь быть полезно если нужно знать какой именно временной зона быть первичный для это значение ntp вне зависимость от причина по который локальный время в система отклоняться от реальный на помощь приходить сервис поставка точный время с различный протокол самый популярный из который — это протокол ntp атомный часы — достаточно дорогой удовольствие поэтому чтобы не перегрузить связанный с они сервер в ntp выстраиваться целый иерархия для обслуживание запрос рядовой пользователь клиент регулярно опрашивать сразу несколько сервис точный время в разный подсеть одновременно производить компенсация время потратить на отправка и приём udp датаграмма откидывать значение являться выброс и затем усреднять они специальный алгоритм заявляться что при использование в публичный сеть возможный точность синхронизация мочь достигать 10мс уведомление в большинство сервис мобильный уведомление пушить и смс можно поделить на два класс срочный сообщение новое дружба платёж и несрочный промый реклама предложение изменение регламент один пользователь скорее всего ожидать получить сразу же при наступление событие для второе же событие как таковой мочь и не быть и пользователь хороший беспокоить в комфортный для он время комфортный время по-умолчание можно считать например период с 10 утро до 20 вечер если это критично комфортный время можно позволить указывать вручную индивидуально так или иначе этот период мы обязать трактовать в какой-то временной зона и вполне очевидно что это быть временной зона пользователь в принцип если сервис работать только для какой-то ограниченный территория например для один город весь это можно не учитывать и считать что временной зона весь пользователь совпадать с временной зона сервер но для распределенный сервис это недостаточно поэтому временной зона необходимый сохранять для фоновый задача — как минимум индивидуально для пользователь а ещё хороший отдельно для каждый устройство пользователь в современный реалия один и тот же учётный запись приложение мочь использоваться сразу на несколько устройство например на стационарный android tv который всегда находиться дом в москва и на android-планшет который уезжать вместе с пользователь в отпуск в таиланд поэтому возможно что уведомление на оба устройство прийтись отсылать в разный время иметь временной зона пользователь и комфортный для он время всегда можно рассчитать точка на временной ося когда мы мочь начать он спамить примерdate now = chronometergetcurrentmoment timezone timezone = userdevicerecordgettimezone calendar calendarfrom = calendargetinstancetimezone calendarfromsettimenow calendarfromsetcalendarhourofday comforthourfrom calendar calendartill = calendargetinstancetimezone calendartillsettimenow calendartillsetcalendarhourofday comfortourhourtill if nowaftercalendartillgettime { calendarfromaddcalendardayofyear +1 } long delayms = mathmaxcalendarfromgettimegettime - nowgettime 0 notificationservicesendnotificationwithdelaymsg delayms am / pm я предполагать что тут нет человек который бы уже не понять что речь идти о 12-часовой представление временной метка но не только лишь весь знать как именно переводиться этот аббревиатура am лата ante meridiem дословно — «до полдень и pm лата post meridiem дословно — «после полдень а сюрприз для многий быть то что полночь — это не 12pm и даже не 0am а очень даже 12am аналогично полдень — это не 12am и не 0pm а 12pm в такой обозначение путаться даже житель привычный к такой формат страна поэтому придумывать различный трюк часы реальный время на люба железка с люба архитектура есть специальный чип с подключить батарейка — это часы реальный время или в терминология linux «the hardware clock они бесшумно тикать свой электрон вне зависимость от внешний условие подать ли основный питание на системный блок установить ли операционный система а также от наличие или отсутствие какой-либо ваш действие они ход прерываться только после тот как энергия в батарейка иссякнуть что на самый дело произойти с ваш оборудование достаточно нескоро для управление часами hardware clock фактически для отправка команда в этот чип в linux существовать специальный команда hwclock поскольку она напрямую общаться с оборудование как правило это /dev/rtc выполнять она нужно с право root $ sudo hwclock wed 30 dec 2015 175912 msk -0328637 seconds команда автоматически приводить время получить из hardware clock к временной зона система но что это за странный смещение в конец вывод дело в тот что на самый дело в ядро linux есть ещё другой свой собственный часы the system time ядро linux считывать показание с чип один раз в начало загрузка ядро после что тикать уже сам по себя в ход прерывание скорее всего это сделать по один простой причина — читать дать с железный чип hardware clock по последовательный шина на каждый пользовательский запрос относительно долго поэтому простой вести свой локальный исключительно программный счётчик после тот как ядро linux прочитать значение с hardware clock с последний теоретически можно производить любой операция — на время в приложение это никак не повлиять такой образ в система параллельно тикать двое часы — настоящий электронный часы и программный часы в ядро между они неизбежно возникать разница который и отобразить в вывод команда hwclock есть два вариант решение этот проблема а для кто-то это и вовсе не проблема рассмотреть один вариант предположить также что система не подключить к сеть поскольку железный часы hardware clock работать круглый сутки без какой либо перерыв — то и ошибаться они в среднее на один и тот же величина каждый день утилит hwclock мочь нивелировать это через специальный механизм коррекция при чтение значение из чип пользователь достаточно два раз установить hardware clock с какой-то существенный промежуток время между установка утилит hwclock сам посчитать на сколько именно ошибаться hardware clock в течение сутки после что сохранить этот величина в файл /etc/adjtime после это мы мочь периодически читать значение из hardware clock и устанавливать значение system time по он при это утилит сам произвести коррекция накопить ошибка на сохранить ранее величина дневный ошибка два вариант предполагать что у мы есть какой-то способ периодический правильный установка system time в ядро скорее всего это какой-то внешний источник точный время с помощь который мы мочь приводить system time в актуальный состояние весь что оставаться после это — попросить ядро периодически раз в 11 секунда скидывать верный значение ядро system time в чип hardware time дробный о весь это можно прочитать в мануал команда hwclock также наверное стоить рассказать о тот что система linux мочь интерпретировать значение из hardware clock два способ связать это с тем что hardware clock хранить время в вид счётчик yyyy mm dd hh mm ss а как быть уже сказать выше без временной зона этот счётчик нельзя привязать к точка на временной ося на самый дело тут всего два вариант это быть или utc или локальный временной зона тот что установить в операционный система по-умолчание для начало зайти в bios и посмотреть на часы в главное меню сравнить показание часы в bios и свой наручный часы если они совпадать то у вы часы bios идти по локальный время поздравлять — скорее всего у вы windows компьютер а если не совпадать то часы bios установить в временной зона utc или другой вариант — они идти неправильно windows по умолчание требовать чтобы время в чип hardware clock соответствовать локальный время а linux легко мочь работать как с локальный время в hardware clock так и время по utc последний предпочтительный поэтому как правило при двойной загрузка система часы в bios идти по локальный время специально для windows а linux к это приспосабливаться посмотреть текущий режим в debian/ubuntu можно так $ cat /etc/default/rcs | grep utc # assume that the bios clock is set to utc time recommended utc=yes хаки время если нужно заставить какой-то программа думать что в данный момент для нея время отличаться от время весь система то в репозиторий ubuntu/debian уже есть утилит faketime который перехватывать и модифицировать системный вызов $ date wed dec 30 225311 msk 2015 $ faketime -f '+2y' date fri dec 29 225339 msk 2017 день рождение если кто-то сказать что родиться «15 апрель мы получить возможность поздравлять это человек с днём рождение каждый год если он сказать что родиться «15 апрель 2001 год мы получить возможность узнать ещё и он возраст но и в тот и друг случай это никак не соответствовать никакой временной точка на ося во-первых не указать время рождение во-вторых не указать временной зона рождение хотя теоретически временной зона дата рождение можно узнать если указать точный место рождение как именно мы рассчитывать временной точка в который мы мочь отправить поздравление самый пользователь а в какой временной точка отправлять уведомление о он день рождение он друг как вариант можно предложить следующий отправка нотификация пользователь — tu поскольку временной зона рождение мы неизвестный использовать текущий временной зона пользователь поскольку время рождение неизвестно использовать комфортный для пользователь время отправка нотификация друг — tf также комбинировать дата рождение пользователь временной зона друг и комфортный время друг japan-france @test public void testbirthday throws exception { timezone japantz = timezonegettimezone"japan" calendar japancalendar = calendargetinstancejapantz japancalendarsetlenientfalse japancalendarsettimeinmillis0 japancalendarset2016 calendarapril 15 9 0 0 systemoutprintln"japan 2016-04-15 090000 " + japancalendargettimeinmillis japancalendarset2016 calendarapril 15 21 0 0 systemoutprintln"japan 2016-04-16 210000 " + japancalendargettimeinmillis timezone francetz = timezonegettimezone"europe/france" calendar francecalendar = calendargetinstancefrancetz francecalendarsetlenientfalse francecalendarsettimeinmillis0 francecalendarset2016 calendarapril 14 9 0 0 systemoutprintln"france 2016-04-14 090000 " + francecalendargettimeinmillis francecalendarset2016 calendarapril 14 21 0 0 systemoutprintln"france 2016-04-14 210000 " + francecalendargettimeinmillis francecalendarset2016 calendarapril 15 9 0 0 systemoutprintln"france 2016-04-15 090000 " + francecalendargettimeinmillis francecalendarset2016 calendarapril 15 21 0 0 systemoutprintln"france 2016-04-15 210000 " + francecalendargettimeinmillis } japan 2016-04-15 090000 1460678400000 japan 2016-04-16 210000 1460721600000 france 2016-04-14 090000 1460624400000 france 2016-04-14 210000 1460667600000 france 2016-04-15 090000 1460710800000 france 2016-04-15 210000 1460754000000 время tf мочь быть сильно большой чем время tu — например если пользователь находиться в япония а он друг — в европа в это случай получаться что к момент когда друг в европа рано утром прийти уведомление сам пользователь в япония уже возможно закончить праздновать свой др в такой случай можно сдвинуть время уведомление друг на день назад а в фраза уведомление добавить слово «завтра пограничный возраст есть ещё один крайне интересный для я момент уже юридический характер есть целый ряд граничный возраст возраст совершеннолетие возраст сексуальный согласие возраст уголовный ответственность предположим что некто родиться в 20000110 000001 в владивосток совершить нетяжкий преступление 20160109 235959 в москва по запись день рождение в паспорт 20000110 и день преступление в протокол 20160109 получаться что 16 год человек ещё не исполниться однако 20160109 235959 в москва — это уже быть 20160110 в владивосток где он родиться и тогда 16 год он уже есть в обратный ситуация человек родиться в москва и совершить преступление в владивосток уже исполниться 16 а вот если посчитать по московский время — получаться что ещё нет для устранение это казус в судебный практика использоваться норма при который активация прав/ответственность наступать с 000000 в день следующий за ожидать то есть уголовный ответственность наступить в 20160111 000000 по место совершение событие — в это случай человек точно быть 16 год где бы он не находиться вывод не игнорировать таймзона если у вы почти готовый машина время то я не рекомендовать использовать стандартный библиотека java для точный расчёт смещение в прошлое точный путешествие в будущее по временной метка невозможный в принцип также текущий версия jdk не подходить для написание внутренний система планирование на космический корабль галактический империя два часть статья — про новое date time api в java 8 
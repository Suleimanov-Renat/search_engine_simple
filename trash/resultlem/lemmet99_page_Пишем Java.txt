писать java-френдлить kotlin-код с сторона мочь показаться что kotlin упростить android-разработка вообще не принести при это новый сложность язык ведь java-совместимый так что даже большой java-проект можно постепенно переводить на он не забивать ничто голова так но если заглядывать глубокий в каждый шкатулка найтись двойной дно а в трюмо — потайной дверца язык программирование — слишком сложный проект чтобы они совмещение обходиться без хитрый нюанс разумеется это не означать «всё плохо и использовать kotlin вместе с java не надо а означать что стоить знать о нюанс и учитывать они на наш конференция mobius сергей рябов рассказать как писать на kotlin такой код к который быть комфортно обращаться из java и доклад так понравиться зритель что мы не только решить разместить видеозапись но и сделать для хабра текстовый версия я писать на kotlin уже более три год сейчас только на он но поначалу притаскивать kotlin в существующий java-проект поэтому вопрос «как связать вместе java и kotlin на мой путь возникать довольно часто зачастую при добавление в проект kotlin можно увидеть как вот это… compile 'rxbindingxyx' compile 'rxbinding-appcompat-v7xyx' compile 'rxbinding-designxyx' compile 'autodisposexyz' compile 'autodispose-androidxyz' compile 'autodispose-android-archcomponentsxyz' … превращаться в это compile 'rxbindingxyx' compile 'rxbinding-kotlinxyx' compile 'rxbinding-appcompat-v7xyx' compile 'rxbinding-appcompat-v7-kotlinxyx' compile 'rxbinding-designxyx' compile 'rxbinding-design-kotlinxyx' compile 'autodisposexyz' compile 'autodispose-kotlinxyz' compile 'autodispose-androidxyz' compile 'autodispose-android-kotlinxyz' compile 'autodispose-android-archcomponentsxyz' compile 'autodispose-android-archcomponents-kotlinxyz' специфика последний пара год самый популярный библиотека обзаводиться «обёртка для тот чтобы можно быть использовать они из kotlin более идиоматичный если вы писать на kotlin то знаете что есть классный extension-функция inline-функция лямбда-выражение который доступный из java 6 и это круто это притягивать мы к kotlin но возникать вопрос один из самый больший самый разрекламировать фич язык — interoperability с java если принять в внимание весь перечисленный фич то почему бы тогда просто не писать библиотека на kotlin они весь быть отлично работать из коробка с java и не нужно быть поддерживать весь этот обёртка весь быть счастливый и довольный но конечно на практика не весь так радужно как в рекламный проспект всегда есть «приписочка мелкий шрифт есть острый грань на стык kotlin и java и сегодня мы о это немного поговорить острый грань начать с различие например в курс ли вы что в kotlin нет ключевой слово volatile synchronized strictfp transient они заменить одноимённый аннотация находиться в пакет kotlinjvm так вот о содержимое это пакет и пойти большой часть разговор есть timber — такой библиотечка-абстракция над логгера от небезызвестный жеки вартанов она позволять вы в ваш приложение везде использовать её а весь куда вы хотеть отправить лог в logcat или на ваш сервер для анализ или в crash reporting и так далее оборачиваться в плагинчик давать для пример представимый что мы хотеть написать аналогичный библиотека только для аналитика тоже абстрагироваться object analytics { fun sendevent event {} fun addpluginsplugs list<plugin> {} fun getplugins list<plugin> {} } interface plugin { fun init fun sendevent event fun close } data class event val name string val context map<string any> = emptymap  брать тот же самый паттерн построение у мы один точка вход — это analytics мы мочь посылать туда ивента добавлять плагин и смотреть что у мы там уже добавить plugin — интерфейс плагин который абстрагировать какой-то конкретный аналитический api и собственно класс event содержимый ключ и наш атрибут который мы отправлять здесь доклад не про то стоить ли использовать синглтон поэтому давать не быть разводить холивар а быть смотреть как это весь дело причесать теперь немножко погрузиться вот пример использование наш библиотека в kotlin private fun useanalytics { analyticssendevent"onlynameevent" val props = mapof userid to 1235 "mycustomattr" to true  analyticssendevent"customevent" props val hasplugins = analyticshasplugins analyticsaddpluginemptyplugin // dry-run analyticsaddpluginslistofloggerplugin"alog" segmentplugin val plugins = analyticsgetplugins //  } в принцип выглядеть так как и ожидаться один точка вход метод вызываться а-ля статика event без параметр event с атрибут проверять есть ли у мы плагин запихивать туда пустой плагин для тот чтобы просто какой-то «dry run-прогон сделать либо добавлять несколько другой плагин выводить они ну и так далее в общий стандартный юзкейс надеяться весь пока понятно а теперь посмотреть что происходить в java когда мы делать то же самый private static void useanalytics { analyticsinstancesendnew event"onlynameevent" collectionsemptymap final map<string object> props = new hashmap<> propsputuserid 1235 propsput"mycustomattr" true analyticsinstancesendnew event"customevent" props boolean hasplugins = analyticsinstancegethasplugins analyticsinstanceaddpluginanalyticsinstancegetemptyplugin // dry-run final list<emptyplugin> pluginstoset = arraysaslistnew loggerplugin"alog" new segmentplugin //  } в глаз сразу бросаться сыр-бор с instance который протянуть наверх наличие явный значение для дефолтный параметр с атрибут какой-то геттер с стрёмный название так как мы в общий-то и собраться здесь чтобы превратить это в что-то похожий на предыдущий файл с kotlin то давать пройтись по каждый момент который мы не нравиться и попробовать он как-то адаптировать начать с event удалять из два строчка параметр colletionsemptymap и вылезать ошибка компилятор с чем же это связать data class event val name string val context map<string any> = emptymap  наш конструктор иметь дефолтный параметр в который мы передавать значение мы приходить из java в kotlin логично предположить что наличие дефолтный параметр генерировать два конструктор один полный с два параметр и один частичный у который можно задать только name очевидно компилятор так не считать давать посмотреть почему он считать что мы не правый наш основной инструмент для анализ весь перипетия тот как kotlin превращаться в jvm-байткод — kotlin bytecode viewer в android studio и intellij idea он находиться в меню tools — kotlin — show kotlin bytecode можно просто нажать cmd+shift+a и вписать в строка поиск kotlin bytecode здесь как ни удивительно мы видеть байткод тот в что превращаться наш kotlin-класс я не ожидать от вы отличный знание байткод и самый главный разработчик ide тоже не ожидать поэтому они сделать кнопочка decompile после её нажатие мы видеть такой примерно неплохой java-код public final class event { @notnull private final string name @notnull private final map context @notnull public final string getname { return thisname } @notnull public final map getcontext { return thiscontext } public event@notnull string name @notnull map context { intrinsicscheckparameterisnotnullname "name" intrinsicscheckparameterisnotnullcontext "context" super thisname = name thiscontext = context } // $ff synthetic method public eventstring var1 map var2 int var3 defaultconstructormarker var4 { if var3 & 2 = 0 { var2 = mapsktemptymap } //  } видеть наш поль геттер ожидать конструктор с два параметр name и context весь происходить нормальный а ниже мы видеть два конструктор и вот он с неожиданный сигнатура не с один параметр а почему-то с четыре тут можно смутиться а можно залезть немного глубокий и покопаться начать разбираться мы понять что defaultconstructormarker — это приватный класс из стандартный библиотека kotlin добавить сюда чтобы не быть коллизия с мы написать конструктор том к мы не мочь задать рука параметр тип defaultconstructormarker а интересный всего int var3 — битовый маска тот какой дефолтный значение мы должный использовать в дать случай если битовый маска совпадать с двойка мы знать что var2 не задать наш атрибут не задать и мы использовать дефолтной значение как мы мочь исправить ситуация для это есть чудо-аннотация @jvmoverloads из тот пакет о который я уже говорить мы должный навесить её на конструктор data class event @jvmoverloads constructor val name string val context map<string any> = emptymap  и что она сделать обратиться к тот же инструмент теперь там видеть и наш полный конструктор и конструктор с defaultconstructormarker и о чудо конструктор с один параметр который доступный теперь из java @jvmoverloads public event@notnull string name { thisname mapnull 2 defaultconstructormarkernull } и как видеть он делегировать весь работа с дефолтный параметр в тот наш конструктор с битовый маска такой образ мы не плодить информация о тот что за дефолтной значение мы нужно засунуть туда мы просто делегировать весь в один конструктор славно проверять что у мы получиться с сторона java компилятор рад и не возмущаться давать посмотреть что мы не нравиться далёкий мы не нравиться этот instance который в idea мозолить фиолетовый цвет не любить фиолетовый цвета  давать проверить за счёт что так получаться снова глянуть в байткод выделить например функция init и убедиться что init действительно сгенерировать не статический то есть как ни крутить мы нужно работать с инстанс это класс и вызывать у он этот метод но мы мочь зафорсить генерация весь этот метод как статический для это есть свой чудесный анннотация @jvmstatic давать добавить её к функция init и send и проверить что теперь думать компилятор на этот счёт мы видеть что к public final init добавиться ключевой слово static и мы избавить себя от работа с instance убедиться в это в java-код компилятор теперь подсказывать мы что мы вызывать статический метод из контекст instance это можно поправить нажать alt+enter выбрать «cleanup code и вуаля instance исчезать весь выглядеть примерно так же как быть в kotlin analyticssendnew event"onlynameevent" теперь у мы есть схема работа с статический метод добавить этот аннотация везде где мы это важный и комментарий если метод у мы — очевидно метод instance то например с проперть не весь так очевидно сам поль например plugins генерироваться как статический а вот геттер и сеттер работать как метод инстанс поэтому для проперть вы тоже нужно добавлять этот аннотация чтобы зафорсить сеттер и геттер как статический например видеть переменный isinited добавлять она аннотация @jvmstatic и теперь мы видеть в kotlin bytecode viewer что метод isinited стать статический весь отлично теперь пойти в java-код «за-clean-up-ий он и весь выглядеть примерно как в kotlin за исключение точка с запятая и слово new — ну от они вы не избавиться public static void useanalytics { analyticssendnew event"onlynameevent" final map<string object> props = new hashmap<> propsputuserid 1235 propsput"mycustomattr" true analyticssendnew event"customevent" props boolean hasplugins = analyticsgethasplugins analyticsaddpluginanalyticsinstancegetemptyplugin // dry-run //  } следующий шаг мы видеть этот стрёмный назвать геттер gethasplugins с два префикс сразу я конечно не большой знаток английский язык но я кажется здесь что-то другой подразумеваться почему так происходить как знать плотно общаться с kotlin для проперть название геттер и сеттер генерироваться по правило javabeans это значит что геттер в общий случай быть с префикс get сеттер с префикс set но есть один исключение если у вы булев пол и в он название есть префикс is то и геттер быть с префикс is это можно увидеть на пример вышеупомянутный поль isinited к сожаление далеко не всегда булев поль должный называться через is isplugins не совсем удовлетворять бы тот что мы хотеть семантически показать имя как же мы быть а быть мы несложно для это есть свой аннотация как вы уже понять я сегодня быть часто это повторять аннотация @jvmname позволять задать любой имя который мы хотеть естественно поддерживать java добавить её @jvmstatic val hasplugins @jvmname"hasplugin" get = pluginsisnotempty проверить что у мы получиться в java метод gethasplugins большой нет а вот hasplugins вполне себя есть это решить наш проблема опять-таки один аннотация сейчас весь аннотация порешать как видеть здесь мы навесить аннотация прямо на геттер с чем это связать с тем что под пропертя лежать много всего и непонятно к что применяться @jvmname если перенести аннотация на сам val hasplugins то компилятор не понять к что её применять однако в kotlin есть и возможность специфицировать место применение аннотация прямо в она можно указать цель геттер файл целиком параметр делегат пол проперти receiver extension-функция сеттер и параметр сеттер в наш случай интересный геттер и если сделать вот так быть тот же самый эффект как когда мы навешивать аннотация на get @getjvmname"hasplugins" @jvmstatic val hasplugins get = pluginsisnotempty соответственно если у вы нет кастомный геттер то вы мочь навесить прямо на ваш проперти и весь быть оk следующий момент который немного мы смущать — это «analyticsinstancegetemptyplugin тут дело уже даже не в английский а просто почему ответ примерно такой же но сперва небольшой введение для тот чтобы сделать из поль константа у вы есть два путь если константа вы определять как примитивный тип либо как string и ещё она внутри объект то вы мочь использовать ключевой слово const и тогда не быть сгенерировать геттер-сеттер и прочее это быть обычный константа — private final static — и она быть заинлайнен то есть абсолютно обычный java-штука но если вы хотеть сделать константа из объект который отличный от строка то у вы не выйти использовать для это слово const вот у мы есть val emptyplugin = emptyplugin по он очевидно сгенерироваться тот страшный геттер мы мочь аннотация @jvmname переименовать убрать этот префикс get но весь равно это остаться метод — с скобка значит старое решение не подойти искать новое и тут для это аннотация @jvmfield который говорить «не хотеть здесь геттер не хотеть сеттер сделать я пол поставить её перед val emptyplugin и проверить что весь действительно так kotlin bytecode viewer показывать выделить тот кусок на который вы сейчас стоять в файл мы сейчас стоять на emptyplugin и вы видеть что здесь какой-то инициализация написать в конструктор дело в тот что геттер-то большой нет и доступ к он только на запись идти а если нажать decompile видеть что появиться «public static final emptyplugin emptyplugin это именно то что мы и добиваться славно проверять что весь весь радовать в частность компилятор самый главный кто нужно ублажить — это компилятор generics давать немного оторваться от код и посмотреть на дженерик это довольно острый тема или скользкий кома что большой не нравиться в java есть свой сложность но kotlin отличаться в один очередь мы волновать вариантность что это такой вариантность — это способ перенос информация о иерархия тип с базовый тип на производный например на контейнер или на дженерик вот у мы есть класс animal и dog с вполне очевидный связь dog — это подтип animal — надтип стрелка идти от подтип а какой связь быть у они производный давать рассмотреть несколько кейс один — это iterator определять что есть надтип а что есть подтип мы быть руководствоваться правило подстановка барбара лиск сформулировать он можно так«подтип должный требовать не большой а предоставлять не маленький в наш ситуация единственный что делать iterator — отдавать мы типизировать объект например animal если мы где-то принимать iterator мы вполне мочь засунуть туда iterator и из метод next получить animal потому что собака — это тоже animal мы предоставлять не маленький а большой потому что собака — это подтип повториться из это тип мы только читаемый поэтому здесь сохраняться зависимость между тип и подтип и такой тип называться ковариантный другой кейс action action — это функция который не возвращать ничто принимать один параметр и мы только писать в action то есть он принимать у мы собака или животный такой образ здесь мы уже не предоставлять а требовать и требовать мы должный не большой это значит что зависимость у мы меняться «не большой у мы animal animal маленький чем собака и такой тип называться контравариантный есть ещё три кейс — например arraylist из который мы и читаемый и писать поэтому в дать случай мы нарушать один из правило на запись требовать большой собака а не животный такой тип никак не связать отношение и они называться инвариантный так вот в java когда её проектировать ещё до версия 15 где появиться дженерик по умолчание сделать массив ковариантный это значит что вы мочь присвоить массив объект массив строка потом передать он куда-то в метод где нужный массив объект и попробовать туда запихнуть объект хотя это массив строка весь свалиться у вы научиться на горький опыт что так делать нельзя при проектирование дженерик они решить «коллекция мы сделать инвариантный ничто не быть с они делать и в итог получаться что в такой казалось бы очевидный штука весь должный быть ок а на самый дело не ок // java list<dog> dogs = new arraylist<> list<animal> animals = dogs но мы же нужно как-то определять что всё-таки мы мочь если мы только читаемый из это лист почему бы не сделать возможный передача сюда лист собака поэтому есть возможность с помощь wildcard охарактеризовать то какой же вариантность быть у это тип list<dog> dogs = new arraylist<> list< extends animal> animals = dogs как вы видеть вариантность этот указываться на место использование там где мы присваивать собака поэтому это называться use-site variance какой негативный сторона у это есть негативный сторона в тот что вы должный везде где использовать ваш api указывать этот страшный wildcard и это весь очень плодиться в код а вот в kotlin почему-то такой штука работать из коробка и не нужно ничто указывать val dogs list<dog> = arraylist val animals list<animal> = dogs с чем это связать с тем что лист на самый дело разный list в java подразумевать запись а в kotlin он read-only не подразумевать поэтому в принцип мы мочь сразу сказать что отсюда только читаемый поэтому мы мочь быть ковариантный и это задаваться именно в объявление тип ключевой слово out заменять wildcard interface list<out e>  collection<e> это называться declaration-site variance такой образ мы в один место весь указать и там где использовать мы большой не затрагивать этот тема и это ништяк снова к код поехать обратно в наш пучина вот у мы есть метод addplugins он принимать list @jvmstatic fun addplugins plugs list<plugin> { plugsforeach { addpluginit } } а мы передавать он как видно list<emptyplugin> ну просто закастиль весь это дело <source lang="java"> final list<emptyplugin> pluginstoset = arraysaslistnew loggerplugin"alog" new segmentplugin благодаря тот что list в kotlin ковариантный мы мочь без проблема передать сюда лист наследник плагин весь сработать компилятор не возражать но из-за тот что у мы есть declaration-site variance где мы весь указать мы не мочь тогда на этап использование контролировать связь с java а что же быть если мы реально хотеть туда лист plugin не хотеть туда никакой наследник никакой модификатор для это нет но есть что правильно есть аннотация а аннотация называться @jvmsuppresswildcards то есть по умолчание мы считать что здесь тип с wildcard тип ковариантный @jvmstatic fun addpluginsplugs list<@jvmsuppresswildcards plugin> { plugsforeach { addpluginit } } говорить suppresswildcards мы suppress'ий весь этот вопросик и наш сигнатура фактически меняться даже более тот я показать как весь выглядеть в байткод удалить пока из код аннотация вот наш метод вы наверняка знаете что существовать type erasure и у вы в байткод нет никакой информация о тот что же там за вопросик-то быть ну и вообще дженерик но компилятор за это следить и подписывать в комментарий к байткод а это у мы с вопросик тип теперь мы снова вставить аннотация и видеть что это у мы тип без вопросик теперь наш предыдущий код перестать компилироваться именно по причина тот что мы отрубить wildcards вы мочь в это убедиться сам мы разобрать ковариантный тип теперь обратный ситуация мы считать что list у мы с вопрос очевидно предположить что когда этот лист возвращаться из getplugins он тоже быть с вопрос а что это значит это значит что мы не смочь в он записать потому что тип ковариантный а не контравариантный давать взглянуть что происходить в java final list<plugin> plugins = analyticsgetplugins displaypluginsplugins analyticsgetpluginsaddnew emptyplugin никто не возмущаться что в последний строчка мы что-то записывать а это значит что кто-то здесь не право если заглянуть в байткод то убедиться в верность свой подозрение мы никакой аннотация не навешивать а тип почему-то без вопрос сюрприз основать вот на что kotlin постулировать себя как язык прагматичный поэтому когда весь это проектировать собирать статистика как вообще использоваться wildcards в java оказаться что на вход чаща всего вариантность разрешать то есть делать тип ковариантный ну полезно везде где мы хотеть list иметь возможность засунуть туда лист любой наследник от plugin а вот там где мы возвращать наоборот мы хотеть иметь чистый тип как есть лист plugin так он и быть возвратить и здесь мы воочию видеть пример это это кажется немного контринтуитивно зато порождать в ваш код маленький чудный аннотация потому что это наиболее частый usecase и если вы не пользоваться какой-то прикол весь быть работать из коробка но в это случай мы видеть что такой ситуация не для мы потому что мы не хотеть чтобы туда можно быть что-то записать и также мы не хотеть чтобы это можно быть сделать из java в kotlin здесь list — это read only-тип и мы туда ничто не мочь записать а прийти клиент наш библиотека из java и напихать туда весь подряд — кома это понравиться поэтому мы собираться зафорсить чтобы этот метод возвращать list с wildcard и мы мочь это сделать понятно как добавить аннотация @jvmwildcard мы говорить сгенерировать мы тип с вопрос весь достаточно просто теперь посмотреть что происходить в java в это место java говорить «что ты делать мы мочь здесь даже привести к правильный тип list< extends plugin> но она весь равно говорить «что ты делать и в принцип этот ситуация мы пока что устраивать но найтись script kiddie который сказать «я же видеть исходник это же опенсорс я знать что там arraylist и я вы похач и весь сработать потому что там действительно arraylist и он знать что туда можно записывать arraylist<plugin> analyticsgetpluginsaddnew emptyplugin поэтому конечно клёвый аннотация навешивать но весь равно нужно использовать defensive-копирование который давным-давно известно сорянин без он никуда если вы хотеть чтобы script kiddies вы не похачили @jvmstatic fun getplugins list<@jvmwildcard plugin> = plugintoimmutablelist добавить только что аннотация @jvmsuppresswildcard можно навешивать как на параметр тогда только он быть о это знать так и на функция так и на весь класс тогда расширяться он зона действие вроде бы весь хорошо с наш аналитика мы разобраться а теперь другой сторона с который мы мочь подойти плагин мы хотеть реализовать плагин на сторона java как хороший пацан мы репортить он исключение @override public void send@notnull event event throws ioexception здесь же весь видно interface plugin { fun init /** @throws ioexception if sending failed */ fun sendevent event //  } в kotlin же нет checked exception и мы говорить в документация сюда можно кидать ну мы и кидать кидать кидать а java не нравиться почему-то говорить «а нет throws почему-то в ваш сигнатура месье а как тут добавить-то тут же kotlin ну вы знаете ответ… есть аннотация @throws который именно это и делать она менять throws-часть в сигнатура метод мы говорить что мочь кинуть сюда ioexсeption open class emptyplugin  plugin { @throwsioexceptionclass override fun sendevent event {} //  } и ещё добавить это дело заодно в интерфейс interface plugin { fun init /** @throws ioexception if sending failed */ @throwsioexceptionclass fun sendevent event //  } и теперь что теперь наш плагин написать на java где у мы есть информация о exception весь довольный весь работать компилироваться в принцип с аннотация на это более-менее весь но есть ещё два нюанс тот как использовать @jvmname один интересный мы весь этот аннотация добавлять для тот чтобы в java быть красиво а вот здесь… package util fun list<int>printreversedsum { printlnthisfoldright0 { it acc -> it + acc } } @jvmname"printreversedconcatenation" fun list<string>printreversedsum { printlnthisfoldrightstringbuilder { it acc -> accappendit } } предположим на java мы здесь весь равно убрать аннотация опачка теперь ide показывать ошибка в оба функция как вы считать с чем это связать да без аннотация они генерироваться с одинаковый имя но здесь же написать что один на list другой на list верно type erasure мы даже мочь проверить это дело вы уже в курс как я понять что весь top-level функция генерироваться в статический контекcт и вот без этот аннотация мы постараться сгенерировать printreversedsum от list а ниже ещё один тоже от list потому что kotlin-компилятор знать о дженерик а java-байткод не знать поэтому это единственный случай когда аннотация из пакет kotlinjvm нужный не для тот чтобы в java быть хорошо и удобно а для тот чтобы ваш kotlin собраться задавать новое имя — раз работать с строка то использовать concatenation — и весь работать хорошо теперь весь компилироваться и два юзкейс он связать вот с чем у мы есть extension-функция reverse inline fun stringreverse = stringbuilderthisreversetostring inline fun <reified t> reversedclassname = tclassjavasimplenamereverse inline fun <t> iterable<t>foreachreversedaction t -> unit { for element in thisreversed actionelement } этот reverse компилироваться в статический метод класс который называться reverserkt private static void useutils { systemoutprintlnreverserktreverse"test" sumsktprintreversedsumaslist1 2 3 4 5 sumsktprintreversedconcatenationaslist"1" "2" "3" "4" "5" } это я думать не новость для вы нюанс в тот что чувак использовать наш библиотека в java мочь заподозрить что-то неладный мы просочить деталь имплементация наш библиотека на сторона юзер и хотеть замести свой след как мы мочь это делать как уже понятно аннотация @jvmname о который я сейчас рассказывать но есть один нюанс для начало задать она такой имя который хотеть не палиться и важный сказать что мы применять этот аннотация на файл переименовать мы надо именно файл @filesuppress"nothingtoinline" @filejvmname"reverserutils" теперь компилятор в java не нравиться reverserkt но это ожидать заменять на reverserutils и весь довольный и такой «юзкейс 21 — частый случай когда вы хотеть метод несколько ваш top-level файл собрать под один класс под один фасад например про вы не хотеть чтобы метод вышеприведённый sumskt вызываться из sumskt а хотеть чтобы это весь тоже быть про reversing и дёргаться из reverserutils тогда добавлять и туда этот чудный аннотация @jvmname писать «reverserutils в принцип весь ок можно даже попробовать это дело скомпилировать но нет хотя заранее среда не предупреждать но при попытка компиляция мы сказать что «вы хотеть сгенерировать два класс в один пакет с один имя ата-тот что нужно сделать добавить последний в это пакет аннотация @jvmmultifileclass говорящий что содержимое несколько файл быть превращаться в один класс то есть для это всего быть один фасад добавлять в оба случай "@filejvmmultifileclass" и можно заменять sumskt на reverserutils весь довольный — поверьте я с аннотация закончить мы поговорить с вы о это пакет о весь аннотация в принцип уже из они название понятно для что использоваться каждый есть хитрый кейс когда нужно например @jvmname использовать даже просто в kotlin kotlin-специфичный но скорее всего это не весь что вы хотеть бы узнать ещё важный отметить как работать с kotlin-специфичный вещь например inline-функция они в kotlin инлайниться и казалось бы а быть ли они вообще доступный из java в байткод оказываться быть весь быть хорошо и метод реально доступный для java хотя если вы писать например kotlin-only проект это не совсем хорошо сказываться на ваш dex count limit потому что в kotlin они не нужный а реально в байткод быть далёкий надо отметить reified type parameters такой параметр специфичный для kotlin они доступный только для инлайна-функция и позволять воротить такой хаки который в java с рефлексия недоступный так как это kotlin-only штука она доступный только для kotlin и в java вы не смочь использовать функция с reified к сожаление javalangclass если мы хотеть немного порефлексировать а библиотека наш и для java то и её надо поддержать давать посмотреть пример есть у мы такой «свой retrofit быстро написать на коленка я вообще не понимать что парень так долго писать class retrofit private constructor val baseurl string val client client  { fun <t  any> createservice class<t> t {} fun <t  any> createservice kclass<t> t { return createservicejava } } есть метод который работать с класс java есть метод который работать с котлиновский kclass вы не нужно делать два разный реализация вы мочь использовать extension-проперти который из kclass доставать class из class доставать kclass он называться kotlin в принцип очевидно это весь быть работать но это немного неидиоматичный в kotlin-код вы не передавать kclass вы писать с использование reified-тип поэтому хороший метод переделать на вот такой inline fun <reified t  any> create t { return createtclassjavajava весь шикардос теперь пойти в kotlin и посмотреть как этот штука использоваться там val api = retrofitcreateapiclass превратиться в val api = retrofitcreate<api> никакой явный class не вылезать это типичный использование reified-функция и весь быть супер-пупереть unit если ваш функция возвращать unit то она прекрасно компилироваться в функция который возвращать void в java и обратно вы мочь работать с это взаимозаменяемый но весь это заканчиваться в тот место где у вы лямбда начинать возвращать юнит если кто-то работать с scala то в scala есть вагон и маленький тележка интерфейс который возвращать какой-то значение и такой же вагон с тележка интерфейс который не возвращать ничто то есть с void а в kotlin это нет в kotlin есть только 22 интерфейс который принимать разный набор параметр и что-то возвращать такой образ лямбда который возвращать unit быть возвращать не void а unit и это накладывать свой ограничение как выглядеть лямбда который возвращать unit вот посмотреть на она в это фрагмент код познакомиться inline fun <t> iterable<t>foreachreversedaction t -> unit { for element in thisreversed actionelement } использование её из kotlin весь хорошо мы использовать даже method reference если мочь и читаться отлично глаз не мозолить private fun usemisc { listof1 2 3 4foreachreversedprintln printlnreversedclassname<string> } что происходить в java в java происходить вот такой байд private static void usemisc { final list<integer> list = aslist1 2 3 4 reverserutilsforeachreversedlist integer -> { systemoutprintlninteger return unitinstance } из-за тот что мы должный возвращать что-то здесь это как void с большой буква мы не мочь просто взять и забить на он мы не мочь использовать здесь метод референс который возвращать void к сожаление и это наверное пока один штука который реально мозолить глаз после весь наш манипуляция с аннотация к сожаление вы прийтись возвращать инстанс unit отсюда можно null весь равно он никто не нужный в смысл возвращать значение никто не нужно поехать далёкий typealiases — это тоже довольно специфичный штука это просто алиас или синоним они доступный только из kotlin и в java к сожаление вы быть использовать то что под этот алиас либо это портянка трижды вложить дженерик либо какой-то вложить класс java-программист привыкнуть с это жить а теперь интересный visibility а точнее internal visibility вы наверняка знаете что в kotlin нет package private если вы писать без какой-либо модификатор это быть public зато есть internal internal — это такой хитрый штука что мы сейчас на она даже посмотреть в retrofit у мы есть internal-метод validate internal fun validate retrofit { println" internal fun validate was called " return this } он не мочь быть вызвать из kotlin и это понятно что происходить с java мочь ли мы вызвать validate возможно для вы не секрет что internal превращаться в public если вы не верить я поверьте kotlin bytecode viewer это действительно public но с такой страшный сигнатура который намекать человек что это наверное не совсем так быть задумать что в публичный api пролезать вот такой портянка если у кто-то форматирование на 80 символ сделать то такой метод мочь даже не влезть в один строчка в java у мы сейчас так final api api = retrofit validate$productionsourcesformodulelibrarymain createapiclass apisendmessage"hello from java" } давать попробовать скомпилировать это дело так по крайний мера это не скомпилироваться уже неплохо на это можно быть бы остановиться но let me explain this to you что если я сделать вот так final api api = retrofit validate$library createapiclass apisendmessage"hello from java" } тогда компилироваться и возникать вопрос «почему так что я мочь сказать… magic поэтому очень важный если вы засовывать что-то критический в internal это плохо потому что это просочиться в ваш публичный api и если script kiddie быть вооружённый kotlin bytecode viewer то быть плохо не использовать ничто очень важный в метод с internal visibility если вы хотеться ещё немного радость то рекомендовать два вещий чтобы быть комфортный работать с байткод и читать он рекомендовать доклад от женить вартанов есть бесплатный видео несмотря на то что это с мероприятие skillsmatter очень круто и довольно старый серия из три стать от кристоф бейлс про то в что превращаться разный kotlin-фич там весь классно написать что-то неактуальный сейчас но в целое весьма доходчиво весь тоже с kotlin bytecode viewer и весь такой спасибо если доклад понравиться обратить внимание 8-9 декабрь в москва состояться новый mobius и там тоже быть много интересный уже известный информация о программа — на сайт и билет можно приобрести там же 
руководство по java 9 для тот кома приходиться работать с legacy-код добрый вечер коллега ровно месяц назад мы получить контракт на перевод книга "modern java" от издательство manning который должный стать один из наш самый заметный новинка в будущее год проблема «modern и «legacy в java настолько острый что необходимость такой книга довольно назреть масштаб бедствие и способ решение возникать проблема в java 9 кратко описать в статья уэйный ситрина wayne citrin перевод который мы и хотеть вы сегодня предложить раз в несколько год с выход новый версия java докладчик на javaone начинать смаковать новое языковой конструкция и api хвалить они достоинство а ретивое разработчик тем время не терпеться внедрить новое возможность такой картина далёкий от реальность – она совершенно не учитывать что большинство программист занятый поддержка и доработка уже существующий приложение а не писать новое приложение с нуль большинство приложение – в особенность коммерческий — должный быть обратно совместимый с более ранний версия java в который не поддерживаться весь этот новое супер-пупереть возможность наконец большинство заказчик и конечный пользователь особенно в сегмент больший предприятие настороженно относиться к радикальный обновление java-платформа предпочитать выждать пока она окрепнуть поэтому как только разработчик собираться попробовать новый возможность он сталкиваться с проблема вы бы стать использовать у себя в код метод интерфейс по умолчание возможно – если вы счастливчик и ваш приложение не требоваться взаимодействовать с java 7 или ниже хотеть использовать класс javautilconcurrentthreadlocalrandom для генерация псевдослучайный число в многопоточный приложение не выйти если ваш приложение должный работать одновременно на java 6 7 8 или 9 с выход новое релиз разработчик занятой поддержка унаследовать код чувствовать себя как ребёнок вынужденный таращиться на витрина кондитерский магазин внутрь они не пускать поэтому они удел — разочарование и фрустрация итак есть ли в новый релиз java 9 что-нибудь для программист занятой поддержка унаследовать код что-то способный облегчить имя жизнь к счастие — да что приходиться делать при поддержка legacy-код то появление java 9 конечно можно впихнуть возможность новый платформа в унаследовать приложение в который нужно соблюдать обратный совместимость в частность всегда есть возможность воспользоваться преимущество новый api однако мочь получиться немного некрасиво например можно применить поздний связывание если вы хотеть получить доступ к новый api когда ваш приложение также требоваться работать с старое версия java не поддерживать этот api допустить вы требоваться использовать класс javautilstreamlongstream появиться в java 8 и вы хотеть применить метод anymatchlongpredicate это класс но приложение должный быть совместимый с java 7 можно создать вспомогательный класс вот так public classlongstreamhelper { private static class longstreamclass private static class longpredicateclass private static method anymatchmethod static { try { longstreamclass = classforname"javautilstreamlongstream" longpredicateclass = classforname"javautilfunctionlongpredicate" anymatchmethod = longstreamclassgetmethod"anymatch" longpredicateclass } catch classnotfoundexception e { longstreamclass = null longpredicateclass = null anymatchmethod = null } catch nosuchmethodexception e { longstreamclass = null longpredicateclass = null anymatchmethod = null } public static boolean anymatchobject thelongstream object thepredicate throws notimplementedexception { if longstreamclass == null throw new notimplementedexception try { boolean result = boolean anymatchmethodinvokethelongstream thepredicate return resultbooleanvalue } catch throwable e { // lots of potential exceptions to handle let’s simplify throw new notimplementedexception } } } есть способ упростить этот операция либо сделать она более общий либо более эффективный – идея вы уловить вместо тот чтобы вызывать thelongstreamanymatchthepredicate как вы поступить бы в java 8 можно вызвать longstreamhelperanymatchthelongstream thepredicate в люба версия java если вы иметь дело с java 8 – это сработать но если с java 7 – то программа выбросить исключение notimplementedexception почему это некрасиво потому что код мочь чрезмерно усложниться если требоваться обращаться к множество api на самый дело даже сейчас с единственный api это уже неудобно кроме тот такой практика и не типобезопасный поскольку в код нельзя прямо упомянуть longstream или longpredicate наконец такой практика гораздо менее эффективный из-за издержка связанный с рефлексия а также из-за дополнительный блок try-catch следовательно хотя и можно так сделать это не слишком интересно и чреватый ошибка по невнимательность да вы мочь обращаться к новый api а ваш код при это сохранять обратный совместимость но с новый языковой конструкция вы это не удаться например допустить что мы нужно использовать лямбда-выражение в код который должный оставаться обратно-совместимый и работать в java 7 вы не повезти компилятор java не позволить указать версия исходный код выше целевой так если задать уровень соответствие исходный код 18 тот java 8 а целевой уровень соответствие быть 17 java 7 то компилятор вы это не позволить вы помочь разноверсионный jar-файл сравнительно недавно появиться ещё один отличный возможность использовать новый возможность java позволять при это приложение работать с старое версия java где такой приложение не поддерживаться в java 9 такой возможность предоставляться как для новый api так и для новый языковой конструкция java речь о разноверисонный jar-файл разноверсионный jar-файл почти не отличаться от старое добрый jar-файл но с один важный оговорка в новый jar-файл появиться своеобразный «ниша куда можно записывать класс использовать новый возможность java 9 если вы работать с java 9 то jvm найти этот «ниша стать использовать класс из нея и игнорировать одноимённый класс из основной часть jar-файл однако при работа с java 8 или ниже jvm неизвестно о существование этот «ниша она игнорировать она и использовать класс из основной часть jar-файл с выход java 10 появиться новый аналогичный «ниша для класс использовать наиболее актуальный возможность java 10 и так далее в jep 238 – предложение на доработка java где описать ращновенсионный jar-файл приводиться простой пример допустить у мы есть jar-файл с четыре класс работать в java 8 или ниже jar root - aclass - bclass - cclass - dclass теперь представимый что после выход java 9 мы переписывать класс a и b чтобы они мочь использовать новое возможность специфичный для java 9 затем выходить java 10 и мы вновь переписывать класс a чтобы он мочь использовать новое возможность java 10 при это приложение по-прежнему должный нормальный работать с java 8 новый разноверсионный jar-файл выглядеть так jar root - aclass - bclass - cclass - dclass - meta-inf versions - 9 - aclass - bclass - 10 - aclass jar-файл не только приобрести новый структура теперь в он манифест указать что этот файл разноверсионный когда вы запускать этот jar-файл на java 8 jvm он игнорировать раздел \meta-inf\versions поскольку даже не подозревать о немой и не искать он использоваться лишь оригинальный класс a b c и d при запуск под java 9 использоваться класс находиться в \meta-inf\versions\9 причём они использоваться вместо оригинальный класс a и b но класс в \meta-inf\versions\10 игнорироваться при запуск под java 10 использоваться оба ветка \meta-inf\versions в частность версия a от java 10 версия b от java 9 и использовать по умолчание версия c и d итак если в ваш приложение вы нужный новый processbuilder api из java 9 но нужно обеспечить чтобы приложение продолжать работать и под java 8 просто записать в раздел \meta-inf\versions\9 jar-файл новое версия ваш класс использовать processbuilder а старое класс оставить в основной часть архив использовать по умолчание именно так простой всего использовать новое возможность java 9 не жертвовать при это обратный совместимость в java 9 jdk есть версия инструмент jarexe поддерживать создание разноверсионный jar-файл такой поддержка также обеспечивать и другой инструмент не входящая в jdk java 9 модуль повсюду модуль система модуль java 9 также известный под название project jigsaw – это несомненно крупный изменение в java 9 один из цель модуляризация — усилить действующий в java механизм инкапсуляция чтобы разработчик мочь указывать какой api предоставляться другой компонент и мочь рассчитывать что jvm быть навязывать инкапсуляция при модуляризация инкапсуляция получаться сильный чем при применение модификатор доступ public/protected/private у класс или член класс два цель модуляризация – указать какой модуль необходимый для работа другой модуль и ещё до запуск приложение заблаговременно убедиться что весь необходимый модуль на место в такой смысл модуль сильный традиционный механизм classpath поскольку путь classpath заблаговременно не проверяться и возможный ошибка из-за отсутствие необходимый класс такой образ некорректный classpath мочь быть обнаружить уже тогда когда приложение успеть проработать достаточно долго либо после тот как оно быть много раз запустить весь система модуль большой и сложный и она подробный обсуждение выходить за рамка этот статья вот хороший подробный объяснение здесь я уделить внимание именно тем аспект модуляризация который помогать разработчик при поддержка унаследовать приложение модуляризация – хороший штука и разработчик должный стараться разбивать новый код на модуль когда это только возможно даже если остаток приложение пока не модуляризовать к счастие это легко сделать благодаря спецификация о работа с модуль во-первых jar-файл становиться модуляризовать и превращаться в модуль с появление в немой файл module-infoclass скомпилировать из module-infojava у корень файл jar module-infojava содержимый метаданные в частность название модуль пакет который экспортироваться тe становиться видный извне какой модуль требовать данный модуль и некоторый иной информация информация в module-infoclass видный лишь в случай когда jvm искать она – то есть система трактовать модуляризовать jar-файл точно как обычный если работать с старое версия java предполагаться что код быть скомпилировать для работа с более старый версия java строго говорить требоваться немного похимичить и весь равно указывать в качество целевой версия module-infoclass именно java 9 но это реально такой образ у вы должный остаться возможность запускать модуляризовать jar-файл с java 8 и ниже при условие что в иной отношение они также совместимый с более ранний версия java также отметить что файл module-infoclass можно с оговорка помещать в версионировать область разноверсионный jar-файл в java 9 существовать как classpath так и путь к модуль and a module path classpath работать как обычно если поставить модуляризовать jar-файл в classpath он тратоваться как люба другой jar-файл то есть если вы модуляризовать jar-файл а ваш приложение ещё не готовый обращаться с он как с модуль он можно поставить в classpath он быть работать как всегда ваш унаследовать код должный вполне успешно с он справиться также отметить что коллекция весь jar-файл в classpath считаться частью единственный безымянный модуль такой модуль считаться самый обычный однако весь информация он экспортировать другой модуль и мочь обращаться к любой другой модуль такой образ если у вы ещё нет модуляризованный java-приложение но есть некий старое библиотека который тоже пока не модуляризовать и вероятно никогда не быть – можно просто положить весь этот библиотека в classpath и весь система быть нормальный работать в java 9 есть путь к модуль работать наряду с classpath при использование модуль из это путь jvm мочь проверять как в время компиляция так и в время выполнение весь ли необходимый модуль на место и сообщать о ошибка если какой-то модуль не хватать весь jar-файл в classpath как член безымянный модуль доступный модуль перечисленный в модульный путь – и наоборот не составлять труд перенести jar-файл из classpath в путь модуль – и пользоваться весь преимущество модуляризация во-первых можно добавить файл module-infoclass в файл jar а затем поставить модуляризовать jar-файл в путь модуль такой новоиспечённый модуль весь равно смочь обращаться к весь остаться jar-файл в classpath jar поскольку они входить в безымянный модуль и оставаться в доступ также возможно что вы не хотеть модуляризовать jar-файл либо что jar-файл принадлежать не вы а кто-то ещё так что модуляризовать он сам вы не мочь в такой случай jar-файл весь равно можно поставить в путь модуль он стать автоматический модуль автоматический модуль считаться модуль даже если в немой нет файл module-infoclass этот модуль одноимённый тот jar-файл в который содержаться и другой модуль мочь явно затребовать он он автоматически экспортировать весь свой публично доступный api и читать то есть требовать весь прочий именовать модуль а также безымянный модуль такой образ немодуляризовать jar-файл из classpath можно превратить в модуль вообще ничто для это не делать унаследовать jar-файл автоматически превращаться в модуль просто в они не хватать некоторть информация который позволять бы определить весь ли нужный модуль на место либо определить что не хватать не каждый немодуляризовать jar-файл можно переместить в путь модуль и превратить он в автоматический модуль существовать правило пакет мочь входить в состав всего один именовать модуль то есть если пакет находиться более чем в один jar-файл то всего один jar-файл с это пакет в состав можно превратить в автоматический модуль остальной мочь остаться в classpath и войти в состав безымянный модуль на один взгляд описать здесь механизм кажется сложный но на практика он весьма простой на самый дело речь в дать случай лишь о тот что можно оставить старое jar-файл в classpath или переместить они в путь модуль можно разбить они на модуль или не делать это а когда ваш старое jar-файл быть модуляризовать можно оставить они в classpath или переместить в путь модуль в большинство случай весь должный попросту работать как и ранний ваш унаследовать jar-файл должный прижиться в новый модульный система чем большой вы модуляризовать код тем большой информация о зависимость требоваться проверять а недоставать модуль и api быть обнаруживаться на гораздо более ранний этап разработка и возможно избавить вы от больший кусок работа java 9 «делать сам модульный jdk и jlink один из проблема с унаследовать java-приложение заключаться в тот что конечный пользователь мочь не работать с подходящий среда java один из способ гарантировать работоспособность java-приложение – предоставить среда выполнение вместе с приложение java позволять создавать приватный многократно распространять jre который можно распространять в предел приложение здесь рассказать как создать приватный jre как правило браться иерархия файл jre устанавливать вместе с jdk нужный файл сохраняться а также сохраняться опциональный файл с тем функционал который мочь понадобиться в ваш приложение процесс немного хлопотный необходимый поддерживать иерархия установочный файл быть при это внимательный поэтому вы не пропускать ни один файл ни один каталог сам по себя это не повредить однако всё-таки хотеться избавиться от всего лишний поскольку этот файл занимать место да легко поддаться и совершить такой ошибка так что почему бы не перепоручить этот работа jdk в java 9 можно создать самодостаточный среда добавлять к приложение – и в этот среда быть весь необходимый для работа приложение большой не прийтись волноваться что на пользовательский компьютер оказаться не тот среда для выполнение java не прийтись беспокоиться о тот что вы сам неправильно собрать приватный jre ключевой ресурс для создание такой самодостаточный исполняемый образ – это модульный система модуляризовать теперь можно не только собственный код но и сам java 9 jdk теперь библиотека класс java – это коллекция модуль из модуль же состоять и инструмент jdk система модуль требовать указывать модуль базовый класс который необходимый в ваш код и при это вы указывать необходимый элемент jdk чтобы собрать весь это вместе в java 9 предусмотреть специальный новый инструмент под название jlink запустить jlink вы получать иерархия файл – именно тот что нужный для запуск ваш приложение ни большой ни маленький такой набор быть гораздо маленький стандартный jre причём он быть платформо-специфичный то есть подбираться для конкретный операционный система и машина поэтому если вы захотеть создать такой исполняемый образ для другой платформа потребоваться запустить jlink в контекст установка на каждый конкретный платформа для который вы нужный такой образ также обратить внимание если запустить jlink с приложение в который ничто не модуляризовать у инструмент просто не быть нужный информация позволять ужать jre поэтому jlink ничто не остаться кроме как упаковать целовать jre даже в такой случай вы быть немного удобный jlink сам упаковать для вы jre поэтому мочь не волноваться о тот как правильно скопировать файловый иерархия с jlink становиться легко упаковать приложение и весь что необходимый для он запуск – и мочь не волноваться что сделать что-нибудь неправильно инструмент упаковать только тот часть среда исполнение который требоваться для работа приложение то есть унаследовать java-приложение гарантированно получить такой среда в который оно оказаться работоспособный встреча старое и новое один из проблема возникать при поддержка унаследовать java-приложение заключаться в тот что вы оказываться лишить весь плюшка появляться при выход новый версия в java 9 как и в предшествовать версия появиться целый куча великолепный новый api и языковой возможность но разработчик научить горький опыт мочь предположить что попросту не смочь они воспользоваться не нарушить обратный совместимость с более ранний версия java следовать отдать должное проектировщик java 9 по-видимому они это учесть и хорошо поработать чтобы предоставить этот новое возможность и тем разработчик который приходиться поддерживать старое версия java разноверсионный jar-файл позволять разработчик применять новое возможность java 9 и выносить они в отдельный часть jar-файл где более ранний версия java они не заметить такой образ разработчик легко писать код для java 9 оставить старый код для java 8 и ниже и предоставить среда исполнение выбор – какой класс она смочь запустить благодаря модуль java разработчик простой проверять зависимость достаточно писать весь новое jar-файл в модульный вид а старый код оставлять немодуляризовать система очень щадить она ориентировать на постепенный миграция и практически всегда поддерживать работа с унаследовать код который «слыхом не слыхивать о модульный система благодаря модульный jdk и jlink можно с лёгкость создавать исполняемый образ и гарантированно обеспечивать приложение такой среда исполнение в который быть весь необходимый для работа ранее такой процесс быть чреватый множество ошибка но современный инструментарий java позволять он автоматизировать – и весь просто работать в отличие от предыдущий релиз java в java 9 вы мочь свободно пользоваться весь новый возможность а если иметь дело с старое приложение и должный гарантировать он поддержка – то смочь удовлетворить потребность весь ваш пользователь независимо от тот гореть ли они желание обновляться до самый актуальный версия java 
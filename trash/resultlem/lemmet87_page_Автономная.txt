автономный кроссплатформенный монолитный программа на java я любить desktop-приложение признаваться в это нынче похоже стыдный чем в связь с иностранный разведка но это так нет это не значит что я не любить интернетом-технология более тот некоторый я не только уважать а даже более-менее знать но тем не менее я скучать по тем время когда программа писаться на один компьютер потом компилироваться и запускаться на другой разный компьютер тогда везде почти быть один система — windows с один и тот же api почти не быть проблема совместимость на уровень приложение никто не материть разработчик браузер — весь беречь нерв на разработчик winapi который умудряться создавать конфликт даже внутри нея один но это я конечно иронизировать а если серьёзно — иногда и сейчас хотеться написать просто desktop-приложение да так чтобы работать оно на весь популярный система трудно если подумать и покопать то не очень ещё я любить язык высокий уровень с аккуратный архитектура и строгий типизация мой фаворит — java и c# оба они предоставлять разработчик множество преимущество по сравнение с c++ оба избавлять от ряд забота чем приходиться платить тем что таскать за себя тяжёлый колода который называться oracle jvm net или mono весь три колода весить сотня мегабайт и лицензия иметь такой что каждый пользователь вынужденный качать этот штука сам не путать при это разрядность свой компьютер а главный — программа на java не мочь быть совместимый с весь версия jvm разом не так ли и вот — мы приходить к тот что просто скинуть программка друг или миллион друг и не заботиться о тот что она у он не запуститься не выходить приходиться делать хитрый сетапа вбивать костыль и это я ещё не упомянуть net — однажды я видеть у друг сразу 3 установленный версия причём весь три быть нужный разный приложениям… стоп а давать написать программа на java но так чтобы она не требовать установка на машина какой-либо jvm чтобы один касание собираться под windows linux и os x и чтобы при это занимать совсем чуть-чуть так чтобы никто даже не понять что она написать скажем не на c невозможно совсем наоборот и нет я иметь в вид не gcj который лишать java весь она прелесть рефлексия быть работать и даже сторонний jar вы смочь запускать разумеется я не волшебник я только найти один волшебный артефакт называться он avian лежать по адрес ossreadytalkcom/avian и представлять себя легковесный но полноценный сторонний реализация jvm о который oracle возможно даже не слышать он поддерживать куча платформа и архитектура иметь лицензия «брать и делать что хотеть и — нет я не иметь ни маленький отношение к это проект я даже не контрибьютор я только научиться имя пользоваться и хотеть поделиться это могучий знание с уважаемый обитатель хабра стоить также отметить что он являться jit-компилятор то есть иметь конкурентно-высокий производительность хотя я пока что не измерять она avian можно встроить в ваш приложение вместе с он весьма урезанный но терпимый по функционал стандартный библиотека класс причём «потяжелеть программа всего только на мегабайт с гак давать собрать такой программа вместе 0 среда для построение мы прежде всего понадобиться утилит командный строка unix-разработчик в частность — компилятор g++ тут сложный всего прийтись windows-пользователь ранний я под windows использовать mingw32 с она замечательный среда msys эмулировать unix-терминал компилятор входящая в mingw32 32-битный что в некоторый род ограничивать получить программа в комментарий я подсказать что уже давно существовать удобный mingw-w64 который регулярно обновляться и в который есть не только msys но даже и git здесь и далее я спрятать платформозависить инструкция под спойлер для удобство windowsчтоба скачать mingw идти на sourceforgenet/projects/mingwbuilds и там скачивать два архив x64-xxx-release-posix-seh-revx7z и external-binary-packages/msys+7za+wget+svn+git+mercurial+cvs-revx7z после тот как они скачать распаковывать оба из они в удобный мы директория далее необходимый указать среда msys где находиться mingw для это идти в msys/etc и там в файл fstab прописывать путь к /mingw так как это показать в файл fstabsample у я получиться вот так c/mingw64 /mingw после установка всего перечисленный вы открывать терминал msys для это необходимый запустить файл msys\msysbat ряд с он лежать два иконка весь дальнейший действие мы быть делать из это терминал так как он во-первых поддерживать формат unix-команда и unix-путь а во-вторых в немой прописать весь необходимый параметр окружение os xпод os x вы прийтись скачать xcode 4 и в он настройка в раздел downloads установить command line tools затем вы просто открывать окно терминал через launcher linuxть linux основать на debian просто открыть терминал и писать > sudo apt-get install build-essential после это необходимый закрыть окно терминал и открыть он снова чтобы загрузиться новое параметр среда итог в каждый операционный система должный быть то что вы вводить в командный строка > g++ и в ответ видеть что-то вроде g++ fatal error no input files такой сообщение означать что компилятор готовый к бой и жаждать получить исходный файл 1 avian для начало предложить наш g++ собрать avian открывать ossreadytalkcom/avian выбирать ссылка status на открыться страница скачивать avian 06 несмотря на скромный номер версия программа совершенно стабильный в всякий случай я ни раз не удаться уронить она а в они багтрекер значиться весьма заковыристый баг означать высокий стабильность тот что есть распаковать исходник avian скачать мы в некоторый папка пусть это быть ~/projects > cd ~/projects под windows папка "~" в среда msys присоединяться не к домашний папка пользователь а к папка c\mingw64\msys\home\username в наш случай раз мы хотеть максимально дистанцироваться от платформа это даже преимущество допустить скачать архив называться avian-06tarbz2 и лежать в ~/downloads тогда распаковывать он в текущий папка набрать > tar -xjf ~/downloads/avian-06tarbz2 в windows путь необходимый указывать в формат mingw с прямая слёша в вид /c/users/username/downloads/avian-06tarbz2 разумеется вы мочь воспользоваться один из сто альтернативный способ распаковать архив — главный чтобы он попасть в текущий папка в итог в она появиться распаковать из архив подпапка avian зайти в нея > cd avian теперь можно попробовать запустить команда make но если запустить сборка прямо сейчас скорее всего мы получить сообщение о тот что не найти zlib что-нибудь вроде zlibh no such file or directory windowsпод windows прийтись слегка попотеть и воспользоваться метод предложить автор avian а именно — подсунуть библиотека zlib из они специальный вспомогательный репозитарий win64 для это вы потребоваться установленный в система git к счастие git входить в установленный мы сборка msys к сожаление на момент написание этот статья сборка сделать кривой — в она не хватать файл msys-crypto-098dll который прийтись найти в google и положить ряд с он бесполезный брат msys-crypto-100dll который этот сборка укомплектовать далее необходимый из папка avian выполнить команда > git clone git//ossreadytalkcom/win64git /win64 который положить ряд с папка avian папка win64 с весь библиотека который мочь понадобиться avian-у в частность с zlib os xпод os x насколько я помнить этот библиотека устанавливаться автоматически возможно с инструментарий разработчик который мы уже поставить linuxпод linux этот проблема решаться простой > sudo apt-get install zlib1g-dev однако установить zlib и снова набрать make мы получить ещё один ошибка — сборщик avian не находить программа /bin/javac java-разработчик вероятно узнать этот программа — это компилятор java так как avian — только виртуальный машина компилятор мы по-прежнему использовать официальный — от oracle при сборка самый vm он нужный для тот чтобы собрать из исходный java-файл класс маленькая стандартный библиотека avian такой например как system arraylist или hashmap соответственно на машина разработчик весь равно должный стоять jdk — как при сборка avian так и при сборка приложение который быть он использовать причём ставить желательно jdk7 с который совместимый avian 06 пользователь ваш приложение она как и jre быть уже не нужный собственно ради это и стараться windowsть windows идти на сайт oracle и качать нужный дистрибутив а затем устанавливать os xв os x как и в windows идти на сайт oracle и качать нужный дистрибутив а затем устанавливать linuxть linux обходиться привычный мантра > sudo apt-get install openjdk-7-jdk возможно в ваш дистрибутив не быть openjdk или пакет быть называться как-то иначе но linux есть linux — искать и обряскать для тот чтобы увидеть куда вы только что положить ваш java-окружение для разработчик make читать переменный среда javahome который мы сейчас надо правильно задать этот же самый переменный с тем же значение потребоваться мы впоследствии для тот чтобы собирать наш собственный проект windowsваш путь в mingw под windows скорее всего быть что-то вроде /c/program\ files/java/jdk17007/ вы он указывать при установка jdk7 os xпод os x ваш jdk7 установиться в /library/java/javavirtualmachines/jdk17017jdk/contents/home linux я в linux это выглядеть так > update-java-alternatives -l java-170-openjdk-amd64 1071 /usr/lib/jvm/java-170-openjdk-amd64 > export javahome=/usr/lib/jvm/java-170-openjdk-amd64 и вот наконец звёздный час — мы собирать avian > make если вы весь проделать правильно вы увидеть последовательность строчка вид compiling build/<имявашейплатформы>/<кака-то файл> а затем linking build/<имявашейплатформы>/<кака-то файл> по окончание сборочный процесс мы получить много файл в папка build/<имявашейплатформы> но заинтересовать мы отсюда только classpathjar — тот самый маленький библиотека базовый класс который вы быть использовать в свой программа существовать возможность собрать avian с использование библиотека openjdk но во-первых как я понимать у нея менее добрый лицензия а во-вторых она существенно тяжёлый binarytoobjectexe — необходимый для встраивание avian в ваш приложение утилит назначение который быть раскрытый поздний libaviana — самый главный файл это и есть собственно встраивать виртуальный машина у я он занимать аж 23 мегабайт но не пугаться он заметно похудеть после некоторый несложный и что важный совершенно безвредный и автоматический манипуляция быть который также быть раскрытый поздний 2 кроссплатформенный независимый монолитный привет на java мы скомпилировать весь необходимый сторонний код теперь заняться создание свой собственный задача в тот чтобы сделать программа который быть написать на java который при это быть содержимый как можно маленький платформозависить закладка и который быть собираться в один exe-файл не требовать специальный установка сам по себя и работать на люба «чистый система без установка какой-либо зависимость 21 немного про jni начать пожалуй с теория обсудить как jvm взаимодействовать с система любой виртуальный машина создаваться в один очередь для тот чтобы абстрагироваться от внешний среда поэтому неудивительно что самый узкий место в реализация vm являться как раз вызов системный функция современный программа не мочь даже «чихнуть без участие ос читать/писать на диск — системный функция вывод текст в консоль — системный функция нарисовать окошко на экран — а вы сам как думать фактически единственный что приложение мочь делать «внутри себя — это расчёт и принятие решение именно этот действие — арифметика и логика — являться функция vm как только надо сделать что-то ещё она звать внешний среда но как в случай java для это существовать jni java native interface быть он весьма простой программа написать на java содержимый в себя заголовок функция пометить модификатор native например package packagename { class classname { void native foo } } такой функция пониматься компилятор java как функция вызывать из загрузить библиотека обычный не виртуальный код в один из этот библиотека должный быть что-то тип extern "c" jniexport void jnicall javapackagenameclassnamefoojnienv * env jobject caller { … } при вызов в java-код функция foo мы фактически вызывать функция из native-библиотека передать она указатель на среда jnienv — объект позволять «общаться с дать и код внутри vm и указатель на объект из который вызвать функция — jobject caller если бы функция быть статический вместо дескриптор объект здесь бы быть дескриптор класс jclass callerclass человек хорошо знакомый с java но не изучать jni можно объяснить этот принцип взаимодействие так jni позволять внешний native-код выполнять рефлексия над программа на java если хотеть изучить этот технология дробный милость просить в специальный раздел на официальный сайт oracle 22 jni «наборота зачем быть весь этот ликбез затем что в данный момент перед мы стоить весьма занятный почти обратный задача мы надо запустить native-исполняемый файл который быть статически слинкованый с библиотека libaviana быть содержимый jvm прямо внутри себя помимо это он быть содержимый внутри себя весь необходимый java-класс включая и «точка вход — класс вид class application { public static void mainstring args { … } } звучать это весь довольно пугающе однако задача этот вполне простой необходимый написать довольно несложный код на c который вытащить библиотека класс avian с добавить в нея наш класс application изнутри собственный бинарный файл и скормить она jvm вместе с параметр командный строка с помощь весь тот же jni затем мы линковать этот c-файл специальный образ чтобы весь оказаться на свой место и наслаждаться результат 23 новый проект и библиотека сейчас мы притащить и разложить по полочка весь нужный мы для дальнейший работа компонента то что я быть описывать здесь — это мой собственный подход разумеется вы вольный сделать весь иначе так как вы заблагорассудиться но если вы хотеть в итог получить в точность то что я выложить на github ссылка быть в конец постараться делать весь в точность создавать папка crossbase где захотеть я создать она в projects ряд с avian и win32 > mkdir crossbase && cd crossbase внутри создавать подпапка libs > mkdir lib && cd lib внутри создавать подпапка с имя ваш текущий os имя должный быть «linux «win32 или «osx > mkdir win-x8664 && cd win-x8664 в этот папка необходимый скопировать libaviana который мы собрать ранее у я это выглядеть так > cp ///avian/build/windows-i386/libaviana / кроме тот в система windows где нет zlib в этот же папка прийтись скопировать ещё и libza > cp ///win-x8664/lib/libza / такой образ мы собрать минимум необходимый мы библиотека это хватить для простой программа помимо библиотека мы понадобиться classpathjar который также быть собранный вместе с avian > cd  > mkdir java && cd java > cp ///avian/build/windows-i386/classpathjar / и теперь пришлый время раскрыть назначение таинственный binarytoobject он нужный мы чтобы преобразовать наш jar-файл в специальный объектный файл который затем быть передать линковщик и добавить имя в наш программа так как этот процедура должный выполняться при каждый сборка он тоже надо утащить в наш новый проект > cd / мы снова в папка crossbase где мы создать lib > mkdir -p tools/win-x8664 && cd tools/win-x8664 имя win-x8664 назначить внутренний папка по тот же принцип что и в прошлый раз кидать сюда binarytoobject в windows он разумеется иметь расширение exe > cp ///avian/build/windows-i386/binarytoobject/binarytoobjectexe / можно запустить он и увидеть usage usage c\users\imizus\projects\crossbase\crossbase\tools\win32\binarytoobjectexe <input file> <output file> <start name> <end name> <platform> <architecture> [<alignment> [{writable|executable}]] 24 код программа а теперь приступить к написание код создать новый исходный файл на c++ вы мочь воспользоваться любой текстовый редактор какой вы нравиться я использовать eclipse в который можно редактировать и c++ и java в рамка один проект хотя для это он прийтись немного настроить > mkdir -p src/cpp && cd src/cpp внутри создавать файл maincpp с следующий содержание привести он целиком а потом объяснить что там к что #include <stdinth> #include <stringh> #ifdef mingw32 #include <windowsh> #endif #include <jnih> #if defined mingw32 # define export declspecdllexport #else # define export attribute visibility"default" \ attribute used #endif #if  defined x8664 && defined mingw32 # define symbolx binarybootjar##x #else # define symbolx binarybootjar##x #endif extern "c" { extern const uint8t symbolstart[] extern const uint8t symbolend[] export const uint8t* bootjarunsigned* size { *size = symbolend - symbolstart return symbolstart } } // extern "c" int mainint argc const char** argv { #ifdef mingw32 // for windows getting command line as a wide string int wac = 0 wchart** wav wav = commandlinetoargvwgetcommandlinew &wac #else // for other os getting command line as a plain string encoded in utf8 int wac = argc const char** wav = argv #endif javavminitargs vmargs vmargsversion = jniversion12 vmargsnoptions = 1 vmargsignoreunrecognized = jnitrue javavmoption options[vmargsnoptions] vmargsoptions = options options[0]optionstring = constcast<char*>"-xbootclasspath[bootjar]" javavm* vm void* env jnicreatejavavm&vm &env &vmargs jnienv* e = staticcast<jnienv*>env jclass c = e->findclass"crossbase/application" if not e->exceptioncheck { jmethodid m = e->getstaticmethodidc "main" "[ljava/lang/stringv" if not e->exceptioncheck { jclass stringclass = e->findclass"java/lang/string" if not e->exceptioncheck { jobjectarray a = e->newobjectarraywac - 1 stringclass 0 if not e->exceptioncheck { for int i = 1 i < wac ++i { #ifdef mingw32 // for windows sending wide string to java int arglen = wcslenwav[i] jstring arg = e->newstringjchar* wav[i] arglen #else // for other os sending utf8-encoded string to java int arglen = strlenwav[i] jstring arg = e->newstringutfchar* wav[i] #endif e->setobjectarrayelementa i - 1 arg } e->callstaticvoidmethodc m a } } } } int exitcode = 0 if e->exceptioncheck { exitcode = -1 e->exceptiondescribe } vm->destroyjavavm return exitcode } mingw32 — символ препроцессор который как неожиданно автоматически задаваться внутри среда mingw32 он позволять мы отличить windows который как вы думать уже успеть заметить сильно непохожий на весь прочий система в частность только под windows мы понадобиться специальный системный api который мы подключать строка #include <windowsh> на остальной платформа мы обходиться стандартный библиотека posix и ansi c++ зачем понадобиться стать ясно чуть поздний быть просматривать код по порядок #if defined mingw32 # define export declspecdllexport #else # define export attribute visibility"default" \ attribute used #endif этот код знак и понятный весь кто писать кроссплатформенный динамический библиотека с использование gcc быть он в тот что в разный операционный система по-разному описываться функция который должный быть экспортировать из библиотека «прич тут динамический библиотека ведь мы же исполняемый файл собирать — спросить вы в ответ я напомнить что взаимодействие avian с платформозависить код осуществляться через механизм jni подразумевать вызов функция из библиотека иной слово для ваш java-код исполняемый файл это не только пусковой программа а ещё и динамический библиотека функция следующий часть — это странноватый магия #if  defined x8664 && defined mingw32 # define symbolx binarybootjar##x #else # define symbolx binarybootjar##x #endif extern "c" { extern const uint8t symbolstart[] extern const uint8t symbolend[] export const uint8t* bootjarunsigned* size { *size = symbolend - symbolstart return symbolstart } } // extern "c" давать разобраться мы декларировать некий экспортный функция посмотреть на extern "c" и директива export который мы только что ввести имя функция — bootjar запомнить это имя и посмотреть что она делать если мысленно разобрать директива препроцессор то увидеть что она вычислять расстояние между некий binarybootjarstart и binarybootjarend в mingw32 они не быть иметь подчерк вначале сам этот символ декларировать как extern то есть они должный подставить линковщик загадочный деятельность не правда ли на самый дело как мы увидеть ниже весь довольно просто если знаешь что делать так как avian разрабатываться для встраивание он в приложение автор предусмотреть возможность добавление библиотека класс непосредственно в исполняемый файл с последующий она загрузка оттуда для это надо всего лишь преобразовать библиотека в объектный файл да-да я тоже поначалу удивиться но это очень элегантный идея в объектный файл содержимый наш jar когда мы он создать быть декларировать 2 символ указывать на начать binarybootjarstart и конец binarybootjarend это jar-файл а функция bootjar быть использовать avian-ом чтобы узнать где он начинаться и какой длина иметь забегать вперёд сказать что имя этот функция передаваться строка options[0]optionstring = constcast<char*>"-xbootclasspath[bootjar]" наконец-то мы дойти до точка вход — функция main в она задача входить считать строка параметр загрузить avian передать он библиотека класс вызвать функция main из класс crossbaseapplication передать она параметр командный строка красиво вылететь с ошибка если что-либо из вышеперечисленный не удаться поехать с начало фцнкции #ifdef mingw32 // for windows getting command line as a wide string int wac = 0 wchart** wav wav = commandlinetoargvwgetcommandlinew &wac #else // for other os getting command line as a plain string encoded in utf8 int wac = argc const char** wav = argv #endif здесь как всегда отличиться windows когда повсеместно быть принять решение переходить от старое неудобный однобайтный кодировка к более сложный весь ос переслать к удобный utf-8 а любимый детище microsoft перейти на фиксировать двухбайтный при это они вообще не позаботиться о тот какой кодировка использоваться например в имя файл но кодировка мы сейчас тоже не очень заботить мы надо передать строка параметр в java в который тоже принять двухбайтный char поэтому для windows мы вызывать api-функция ради который мы и тащить windowsh который выдать мы строка параметр в правильный двухбайтный кодировка так мы получить возможность например открывать файл с кириллица в название в весь прочий система мы просто читаемый параметр из аргумент функция main далее следовать создание виртуальный машина java javavminitargs vmargs vmargsversion = jniversion12 vmargsnoptions = 1 vmargsignoreunrecognized = jnitrue javavmoption options[vmargsnoptions] vmargsoptions = options options[0]optionstring = constcast<char*>"-xbootclasspath[bootjar]" javavm* vm void* env jnicreatejavavm&vm &env &vmargs jnienv* e = staticcast<jnienv*>env ещё мы вытаскивать указатель на объект jnienv который быть использовать чтобы командовать только что создать java-машина дальнейший код читаться как стихнуть маяковский если только немного знать jni jclass c = e->findclass"crossbase/application" if not e->exceptioncheck { jmethodid m = e->getstaticmethodidc "main" "[ljava/lang/stringv" if not e->exceptioncheck { jclass stringclass = e->findclass"java/lang/string" if not e->exceptioncheck { jobjectarray a = e->newobjectarraywac - 1 stringclass 0 if not e->exceptioncheck { for int i = 1 i < wac ++i { #ifdef mingw32 // for windows sending wide string to java int arglen = wcslenwav[i] jstring arg = e->newstringjchar* wav[i] arglen #else // for other os sending utf8-encoded string to java int arglen = strlenwav[i] jstring arg = e->newstringutfchar* wav[i] #endif e->setobjectarrayelementa i - 1 arg } e->callstaticvoidmethodc m a } } } } int exitcode = 0 if e->exceptioncheck { exitcode = -1 e->exceptiondescribe } взять класс crossbase/application если смочь найти в немой статический метод main с сигнатура [ljava/lang/stringv если смочь достать из стандартный библиотека класс java/lang/string если смочь создать массив объект это класс они и быть параметр если смочь то в весь операционный система создавать java-строка из каждый параметр задать в кодировка utf-8 а в windows создавать напрямую использовать двухбайтный представление если мы что-нибудь не смочь выдавать ошибка пользователь вот собственно и весь «пусковой механизм теперь мы надо создать наш программа на java она как минимум должный содержимый класс crossbaseapplication с метод public static void mainstring args создать в наш папка crossbase/src подпапка java в она — подпапка crossbase это — имя пакет а внутри создать файл applicationjava следующий содержание package crossbase public class application { public static void mainstring args { systemoutprintln"this is a crossplatform monolith application with java code inside freedom to java apps" for int i = 0 i < argslength i++ { systemoutprintln"args[" + i + "] = " + args[i] } } } если вы хоть немного знаете java то думать комментарий здесь излишний сказать только что в стандартный библиотека класс avian нету средство форматирование строка который никто не мешать тихонько утянуть к пример из openjdk 25 сборка теперь перейти к задача сборка наш проект я использовать make потому что он есть всегда и везде где есть gcc а ещё он достаточно мощный чтобы написать на немой почти любой автоматизированный система сборка нет правда можно по палец перечислить что я не удаваться сделать на make и это едва ли быть жизненно важный вещий наш makefile быть лежать прямо в папка crossbase и выглядеть он быть вот так uname = $shell uname arch = $shell uname -m src = src bin = bin obj = obj javasourcepath = $src/java javaclasspath = $bin/java cppsourcepath = $src/cpp objects = $obj debugoptimize = -o3 #-o0 -g ifeq $uname darwin # os x platformarch = darwin x8664 platformlibs = osx-x8664 platformgeneralincludes = -i"$javahome/include" -i"$javahome/include/darwin" platformgenerallinkeroptions = -framework carbon platformconsoleoption = exeext= stripoptions=-s -x rdynamic=-rdynamic else ifeq $uname $arch linux x8664 # linux on pc platformarch = linux x8664 platformlibs = linux-x8664 platformgeneralincludes = -i"$javahome/include" -i"$javahome/include/linux" platformgenerallinkeroptions = -lpthread -ldl platformconsoleoption = exeext= stripoptions=--strip-all rdynamic=-rdynamic else ifeq $os windowsnt # windows platformarch = windows x8664 platformlibs = win-x8664 platformgeneralincludes = -i"$javahome/include" -i"$javahome/include/win32" platformgenerallinkeroptions = -static -lmingw32 -lmingwthrd -lws232 -mwindows -static-libgcc -static-libstdc++ platformconsoleoption = -mconsole exeext=exe stripoptions=--strip-all rdynamic= endif javafiles = $shell cd $javasourcepath find  -name \*java | awk '{ sub/\//"" } 1' javaclasses = $addprefix $javaclasspath/$addsuffix class$basename $javafiles cppfiles = $shell cd $cppsourcepath find  -name \*cpp | awk '{ sub/\//"" } 1' cppobjects = $addprefix $objects/$addsuffix o$basename $cppfiles all $bin/crossbase $javaclasspath/%class $javasourcepath/%java @echo $platformgeneralincludes if [  -d "$dir $@" ] then mkdir -p "$dir $@" fi "$javahome/bin/javac" -sourcepath "$javasourcepath" -classpath "$javaclasspath" -d "$javaclasspath" $< $obj/%o $src/cpp/%cpp @echo $platformgeneralincludes mkdir -p $obj g++ $debugoptimize -djniimplementation -c $platformgeneralincludes $< -o $@ $bin/crossbase $javaclasses $cppobjects mkdir -p $bin @echo $platformgeneralincludes # extracting libavian objects  \ cd $obj \ mkdir -p libavian \ cd libavian \ ar x //lib/$platformlibs/libaviana \  # making the java class library cp lib/java/classpathjar $bin/bootjar \  \ cd $bin \ "$javahome/bin/jar" u0f bootjar -c java  \  # making an object file from the java class library tools/$platformlibs/binarytoobject $bin/bootjar $obj/bootjaro binarybootjarstart binarybootjarend $platformarch \ g++ $rdynamic $debugoptimize -llib/$platformlibs $obj/bootjaro $cppobjects $obj/libavian/*o $platformgenerallinkeroptions $platformconsoleoption -lm -lz -o $@ strip $stripoptions $@$exeext clean rm -rf $obj rm -rf $bin phony all быть осторожный не путать табуляция с пробел в make табуляция выделяться команда внутри правило сборка а пробел синтаксический элемент не являться присмотреться немного как он работать единственный более-менее мозгодробительный конструкция — назначение вот этот переменный javafiles = $shell cd $javasourcepath find  -name \*java | awk '{ sub/\//"" } 1' javaclasses = $addprefix $javaclasspath/$addsuffix class$basename $javafiles cppfiles = $shell cd $cppsourcepath find  -name \*cpp | awk '{ sub/\//"" } 1' cppobjects = $addprefix $objects/$addsuffix o$basename $cppfiles здесь мы с помощь unix-команда find отыскивать весь файл java в папка $javasourcepath этот файл мы предстоять компилировать далее мы откусывать от они расширение и заменять он на class а пусть заменять на $javaclasspath получать такой образ имя файл класс который надо получить тот имя цель аналогично мы поступать с файл cpp и o далее в makefile мы видеть следующий правило сборка $javaclasspath/%class $javasourcepath/%java @echo $platformgeneralincludes if [  -d "$dir $@" ] then mkdir -p "$dir $@" fi "$javahome/bin/javac" -sourcepath "$javasourcepath" -classpath "$javaclasspath" -d "$javaclasspath" $< $obj/%o $src/cpp/%cpp @echo $platformgeneralincludes mkdir -p $obj g++ $debugoptimize -djniimplementation -c $platformgeneralincludes $< -o $@ этот правило объяснять как скомпилировать исходный файл в целевой и наконец взглянуть на цель $bin/crossbase $javaclasses $cppobjects  здесь мы видеть зависимость от весь найти файл то есть makefile написать такой образ чтобы собирать весь java и cpp файл предложить он в правильный папка остальной существенный момент -static-libgcc и -static-libstdc++ необходимый в mingw чтобы собирать файл содержимый в себя стандартный библиотека c и c++ в противный случай он быть слинкованый с они динамически и потребовать таскать за себя пара dll -mconsole нужный в система windows чтобы система выдать программа консольный ввод-вывод при запуск этот параметр для gui-приложение надо убрать опция -rdynamic не поддерживаться gcc под windows в сила особенность платформа пробежаться вскользь по основный правило сборка — $bin/crossbase $javaclasses $cppobjects сперва мы распаковывать весь объектный файл из libaviana чтобы впоследствии передать они линковщик поимённо поведение странный но не бессмысленный в windows это решать какой-то странный проблема с линковка я не разобраться достаточно хорошо далее мы брать наш classpathjar добавлять к он наш скомпилировать класс из bin/java и паковать весь вместе в bin/bootjar затем мы вызывать binarytoobject который создавать из наш bootjar объектный файл obj/bootjaro с символ binarybootjarstart и binarybootjarend который мы импортировать в maino и наконец мы линковать весь это безобразие вместе и наконец выполнять волшебный команда strip в параметр который на этот раз отличиться os x где они не такой как в mingw и в linux назначение команда — выкинуть из исполняемый файл всякий левый символ до она отработка crossbase весить более 9 мегабайт после — менее полтора 3 момент триумф зайти в папка crossbase/bin запускать из консоль наш crossbase передать он параметр > /crossbase привет хабра this is a crossplatform monolith application with java code inside freedom to java apps args[0] = привет args[1] = хабра получиться у мы проект лежать на мой github-е 4 итог и смысл я трудно оценить польза от этот статья если я хотя бы получить за нея инвайта это быть значить что она по крайний мера не безынтересный сказать только что при кажущийся сложность этот метод прекрасно окупаться по сравнение с написание программа скажем на чистый c++ java становиться очень удобный при разрастание проект хотя бы до пара десяток класс даже если быть предельно аккуратный при написание код на c++ весь равно оставаться лазейка для чудовищно сложновылавливать ошибка поэтому управлять код не требовать суперпроизводительность я бы весь советовать писать на java код же требовать максимальный скорость можно написать на c++ а затем очень легко и аккуратно обернуть c++ класс java класс возможно я ещё написать как сделать это красиво и не напороться на грабли изначально я планировать сделать в статья глава посвятить добавление к это «бутерброд кроссплатформенный пользовательский интерфейс swt тот который использоваться в eclipse но потом решить что она быть слишком уж длинный и увесистый если господин читатель интересно написать о это отдельно благодарить за внимание ps получить от хабровчанин много отзыв я доработать статья и программа спасибо весь за совет и поправка 
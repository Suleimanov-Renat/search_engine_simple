инстанцировать javalangclass конструктор javalangclass являться один из самый охранять сущность в язык java в спецификация чётко сказать что объект тип class мочь создавать только сам jvm и что мы тут делать нечего но так ли это на самый дело предлагать погрузиться в глубина reflection api и не только и выяснить как там весь устроить и насколько трудно быть обойти иметься ограничение эксперимент я провозить на 64-битный jdk 180151 с дефолтный настройка про java 9 быть в самый конец статья уровень 1 простой начать с самый наивный попытка и пойти по нарастать сперва посмотреть враг в лицо private classclassloader loader { classloader = loader } ничто особенный этот конструктор себя не представлять компилятор не делать для он никакой исключение и в байткод конструктор тоже присутствовать поэтому попробовать поступить так же как мы бы поступить с любой другой класс constructor<class> constructor = classclassgetdeclaredconstructorclassloaderclass constructorsetaccessibletrue class<> clazz = constructornewinstanceclassloadergetsystemclassloader вполне ожидать данный код не быть работать и выдать следующий ошибка exception in thread "main" javalangsecurityexception cannot make a javalangclass constructor accessible at javalangreflectaccessibleobjectsetaccessible0 at javalangreflectaccessibleobjectsetaccessible at samplemain с один же попытка мы попасть на первое предупреждение из метод setaccessible0 оно захардкодить специально для конструктор класс javalangclass private static void setaccessible0accessibleobject obj boolean flag throws securityexception { if obj instanceof constructor && flag == true { constructor<> c = constructor<> obj if cgetdeclaringclass == classclass { throw new securityexception"cannot make a javalangclass" + " constructor accessible" } } objoverride = flag } не проблема ведь ключевой строка в это метод являться последний — установка поль override в значение true это легко сделать использовать грубый сила field overrideconstructorfield = accessibleobjectclassgetdeclaredfield"override" overrideconstructorfieldsetaccessibletrue overrideconstructorfieldsetconstructor true уровень 2 сложный естественно установка флаг override — это не единственный ограничение но теперь мы мочь хотя бы продвинуться чуть далёкий в работа метод newinstance достаточно далеко чтобы спланировать дальнейший действие в этот раз ошибка быть следующий exception in thread "main" javalanginstantiationexception can not instantiate javalangclass at sunreflectinstantiationexceptionconstructoraccessorimplnewinstance at javalangreflectconstructornewinstance at samplemain мы занести прямиком в класс пакет sunreflect а мы знать что основный магия должный происходить именно там самый время заглянуть в реализация newinstance класс constructor и узнать как мы туда попасть public t newinstanceobject  initargs throws  {  constructoraccessor ca = constructoraccessor // read volatile if ca == null { ca = acquireconstructoraccessor } @suppresswarnings"unchecked" t inst = t canewinstanceinitargs return inst } из реализация становиться понятно что constructor делегировать весь работа по инстанцирование другой объект тип constructoraccessor он инициализироваться ленивый образ и в дальнейший не меняться внутренность метод acquireconstructoraccessor описывать не стать сказать лишь что в результат он приводить к вызов метод newconstructoraccessor объект класс sunreflectreflectionfactory и именно для конструктор класс javalangclass а ещё для абстрактный класс данный метод возвращать объект instantiationexceptionconstructoraccessorimpl он не уметь ничто инстанцировать а только бросаться исключение на каждый обращение к он весь это означать лишь один правильный constructoraccessor прийтись инстанцировать сам уровень 3 нативный время узнать какой вообще тип бывать объект constructoraccessor помимо описать выше bootstrapconstructoraccessorimpl использоваться для инстанцирование класс который сам являться реализация constructoraccessor вероятно спасать какой-то код от бесконечный рекурсия штука узкоспециализированный трогать я её не быть generatedconstructoraccessor самый интересный реализация о который я рассказать подробно но поздний связка nativeconstructoraccessorimpl и delegatingconstructoraccessorimpl то что возвращаться по умолчание и поэтому рассмотреться я в один очередь delegatingconstructoraccessorimpl попросту делегировать свой работа другой объект храниться у он в пол плюс данный подход в тот что он позволять подменить реализация на лёт именно это на самый дело и происходить — nativeconstructoraccessorimpl для каждый конструктор отрабатывать максимум столько раз сколько указать в системный свойство sunreflectinflationthreshold 15 по умолчание после что подменяться на generatedconstructoraccessor справедливость ради стоить добавить что установка свойство sunreflectnoinflation в значение "true" по суть сбрасывать inflationthreshhold в ноль и nativeconstructoraccessorimpl переставать создаваться в принцип по умолчание это свойство иметь значение "false" итак для самый обычный класс при самый обычный обстоятельство мы бы получить объект nativeconstructoraccessorimpl а значит именно он и попробовать создать вручную class<> nativecaclass = classforname"sunreflectnativeconstructoraccessorimpl" constructor<> nativecaconstructor = nativecaclassgetdeclaredconstructorconstructorclass nativecaconstructorsetaccessibletrue constructoraccessor constructoraccessor = constructoraccessor nativecaconstructornewinstanceconstructor здесь нет никакой подвох объект создаваться без лишний ограничение и весь что мы оставаться так это с он помощь инстанцировать javalangclass class<> clazz = class<> constructoraccessornewinstance new object[]{classloadergetsystemclassloader} но тут ждать сюрприз # # a fatal error has been detected by the java runtime environment # # sigsegv 0xb at pc=0x00007f8698589ead pid=20537 tid=0x00007f8699af3700 # # jre version javatm se runtime environment 80151-b12 build 180151-b12 #  кажется jvm не ожидать от пользователь столь нелогичный действие особенно после весь предупреждение тем не менее данный результат можно по право считать достижение — завалить jvm ни раз не воспользоваться класс пакет sunmisc уровень 4 магический нативный вызов не работать — значит теперь нужно разобраться с generatedconstructoraccessor на самый дело это не просто класс а целое семейство класс для каждый конструктор в рантайм генерироваться свой уникальный реализация именно поэтому в один очередь использоваться нативный реализация генерировать байткод и создавать из он класс дело затратный сам процесс генерация класс запрятать в метод generateconstructor класс sunreflectmethodaccessorgenerator вызвать он вручную не составить труд class<> methodaccessorgeneratorclass = classforname"sunreflectmethodaccessorgenerator" constructor<> methodaccessorgeneratorconstructor = methodaccessorgeneratorclassgetdeclaredconstructor methodaccessorgeneratorconstructorsetaccessibletrue object methodaccessorgenerator = methodaccessorgeneratorconstructornewinstance method generateconstructor = methodaccessorgeneratorclass getdeclaredmethod"generateconstructor" classclass class[]class class[]class intclass generateconstructorsetaccessibletrue constructoraccessor constructoraccessor = constructoraccessor generateconstructorinvokemethodaccessorgenerator constructorgetdeclaringclass constructorgetparametertypes constructorgetexceptiontypes constructorgetmodifiers как и в случай с nativeconstructoraccessorimpl тут нет подводный камень — данный код отработать и сделать ровно то что от он ждать но давать задуматься на минутка ну сгенерировать мы какой-то класс откуда у он взяться право на вызов приватный конструктор такой быть не должный поэтому мы просто обязать сдампить сгенерировать класс и изучить он код сделать это несложно — вставать отладчик в метод generateconstructor и в нужный момент дампим нужный мы массив байт в файл декомпилировать он версия выглядеть следующий образ после переименование переменный public class generatedconstructoraccessor1 extends constructoraccessorimpl { public object newinstanceobject[] args throws invocationtargetexception { class clazz classloader classloader try { clazz = new class if argslength = 1 { throw new illegalargumentexception } classloader = classloader args[0] } catch nullpointerexception | classcastexception e { throw new illegalargumentexceptionetostring } try { clazz<init>classloader return clazz } catch throwable e { throw new invocationtargetexceptione } } } такой код естественно обратно не скомпилироваться и это есть два причина вызов new class без скобочка он соответствовать инструкция new который выделять память под объект но конструктор у он не вызывать вызов clazz<init>classloader — это как раз вызов конструктор который в такой явный вид в язык java невозможный дать инструкция разнести для тот чтобы находиться в разный try-блок почему сделать именно так я не знать вероятно это быть единственный способ обрабатывать исключение так чтобы они полностью соответствовать спецификация язык если закрыть глаз на нетипичный обработка исключение то в весь остальной данный класс абсолютно нормальный но весь ещё непонятно откуда у он вдруг право на вызов приватный конструктор оказываться весь дело в суперкласс abstract class constructoraccessorimpl extends magicaccessorimpl implements constructoraccessor { public abstract object newinstanceobject[] args throws instantiationexception illegalargumentexception invocationtargetexception } в jvm есть известный костыль под название sunreflectmagicaccessorimpl всякий он наследник обладать неограниченный доступ к любой приватный данные любой класс это именно то что нужно раз класс магический то он помочь получить инстанс javalangclass проверять class<> clazz = class<> constructoraccessornewinstance new object[]{classloadergetsystemclassloader} и опять получать исключение exception in thread "main" javalangillegalaccesserror javalangclass at sunreflectgeneratedconstructoraccessor1newinstance at samplemain вот это уже действительно интересно судить по весь обещать магия не произойти или я ошибаться стоить рассмотреть ошибка внимательный и сравнить её с тем как должный себя вести метод newinstance быть проблема в строка clazz<init>classloader мы бы получить invocationtargetexception на дело же иметь illegalaccesserror то есть до вызов конструктор дело не дошлый с ошибка отработать инструкция new не позволить выделить память под объект javalangclass здесь наш полномочие весь окончить уровень 5 современный reflection не помочь решить проблема мочь быть дело в тот что reflection старый и слабый и вместо он стоить использовать молодая и сильный methodhandles думать да как минимум стоить попробовать и как только я решить что reflection не нужный он тут же пригодиться methodhandles — это конечно хорошо но с помощь он принять получать лишь тот дать к который есть доступ а если понадобиться приватный конструктор то прийтись выкручиваться по старинка итак мы нужный methodhandleslookup с приватный доступ к класс javalangclass на этот случай есть очень подходящий конструктор private lookupclass<> lookupclass int allowedmodes {  } вызвать он constructor<methodhandleslookup> lookupconstructor = methodhandleslookupclassgetdeclaredconstructorclassclass intclass lookupconstructorsetaccessibletrue methodhandleslookup lookup = lookupconstructor newinstanceclassclass methodhandleslookupprivate получить lookup можно получить объект methodhandle соответствующий требовать мы конструктор methodhandle handle = lookupfindconstructorclassclass methodtypemethodtypeclassclass classloaderclass после запуск это метод я быть откровенно удивлённый — lookup делать вид что конструктор вообще не существовать хотя он точно присутствовать в класс exception in thread "main" javalangnosuchmethodexception no such constructor javalangclass<init>classloaderclass/newinvokespecial at javalanginvokemembernamemakeaccessexception at javalanginvokemembername$factoryresolveorfail at javalanginvokemethodhandles$lookupresolveorfail at javalanginvokemethodhandles$lookupfindconstructor at samplemainsamplejava59 caused by javalangnosuchfielderror method resolution failed at javalanginvokemethodhandlenativesresolve at javalanginvokemembername$factoryresolve at javalanginvokemembername$factoryresolveorfail  3 more странно то что причина исключение — nosuchfielderror загадочно в этот раз ошибиться именно я но далеко не сразу это понять спецификация findconstructor требовать чтобы тип возвращать значение быть void несмотря на то что у результат methodtype быть ровно такой как я описать весь потому что метод <init> отвечать за конструктор действительно возвращать void по исторический причина так или иначе путаница можно избежать ведь у lookup есть два метод для получение конструктор и он называться unreflectconstructor methodhandle handle = lookupunreflectconstructorconstructor данный метод уж точно корректно отработать и вернуть тот handle который должный момент истина запускать метод инстанцирование class<> clazz = class<> handle invokeclassloadergetsystemclassloader думать вы уже догадаться что ничто хороший не произойти но давать хоть глянуть на ошибка сейчас это что-то новенький exception in thread "main" javalangillegalaccessexception javalangclass at sunmiscunsafeallocateinstance at javalanginvokedirectmethodhandleallocateinstance at javalanginvokelambdaform$dmh/925858445newinvokespecialll at javalanginvokelambdaform$mh/523429237invokemt at samplemain по умолчание stacktrace отображаться укоротить поэтому я добавить -xx+unlockdiagnosticvmoptions -xx+showhiddenframes в параметр запуск так становиться простой понять в какой странный место мы попасть не быть углубляться в то какой класс генерировать methodhandles да это и не принципиально важный совсем другой — мы наконец-то докопаться до использование sunmiscunsafe и даже он не в сила создать объект javalangclass метод allocaeinstance использоваться в тот место где нужно создать объект но не вызывать у он конструктор такой бывать полезно например при десериализация объект по суть это тот же инструкция new но не обременить проверка право доступ почти не обременить как мы только что увидеть раз даже unsafe не смочь я оставаться лишь прийти к печальный заключение аллоцировать новый объект javalangclass невозможно интересно выходить — думать что запретить конструктор а запретить аллокация попробовать это дело обойти уровень 6 небезопасный предлагать создать пустой объект и взглянуть из что же он состоять для это взять unsafe и аллоцировать новенький javalangobject field theunsafefield = unsafeclassgetdeclaredfield"theunsafe" theunsafefieldsetaccessibletrue unsafe unsafe = unsafe theunsafefieldgetnull object object = unsafeallocateinstanceobjectclass на текущий jvm результат быть область память в 12 байт выглядеть вот так то что вы здесь видеть это "заголовок объекта" по большой счёт он состоять из два часть — 8 байт markword который мы не интересовать и 4 байт classword который важный какой образ jvm узнавать класс объект она делать это путём чтение область classword который хранить указатель на внутренний структура jvm описывать класс значит если в данный место записать другой значение то и класс объект измениться дальнейший код очень очень плохой никогда так не делать systemoutprintlnobjectgetclass unsafeputintobject 8l unsafegetintobjectclass 8l systemoutprintlnobjectgetclass мы прочитать classword объект objectclass и записать он в classword объект object результат работа следующий class javalangobject class javalangclass с натяжка можно считать что javalangclass мы аллоцировать мы молодец теперь надо вызвать конструктор вы мочь смеяться но сейчас мы быть с помощь asm генерировать класс уметь вызывать нужный конструктор естественно при это нужно унаследоваться от magicaccessorimpl так начинаться создание класс константа импортировать статически так короче classwriter cw = new classwritercomputeframes | computemaxs cwvisitv18 accpublic "sun/reflect/myconstructorinvocator" null "sun/reflect/magicaccessorimpl" null так он создаваться конструктор methodvisitor init = cwvisitmethodaccpublic "<init>" "v" null null initvisitcode initvisitvarinsnaload 0 initvisitmethodinsninvokespecial "sun/reflect/magicaccessorimpl" "<init>" "v" false initvisitinsnreturn initvisitmaxs-1 -1 initvisitend а так создаваться метод void constructclass<> classloader который внутри себя вызывать конструктор у объект class<> methodvisitor construct = cwvisitmethodaccpublic "construct" "ljava/lang/classljava/lang/classloaderv" null null constructvisitcode constructvisitvarinsnaload 1 constructvisitvarinsnaload 2 constructvisitmethodinsninvokespecial "java/lang/class" "<init>" "ljava/lang/classloaderv" false constructvisitinsnreturn constructvisitmaxs-1 -1 constructvisitend класс готовый остаться загрузить инстанцировать и вызвать нужный метод byte[] bytes = cwtobytearray class<> mycustominvocator = unsafedefineclassnull bytes 0 byteslength classloadergetsystemclassloader null object ci = mycustominvocatornewinstance method constructmethod = mycustominvocatorgetdeclaredmethod"construct" classclass classloaderclass class<> clazz = class<> object constructmethodinvokeci clazz classloadergetsystemclassloader и это работать точнее так повезти что работать можно проверить запустить следующий код systemoutprintlnclazzgetclassloader вывод быть такой sunmisclauncher$appclassloader@18b4aac2 о тот в какой область память записаться этот classloader и откуда потом прочитаться я тактично умолчать и как ожидаться вызов практически любой другой метод на дать объект приводить к немедленный крах jvm а в остальной — цель выполнить что там в java 9 в java 9 весь почти так же можно проделать весь тот же действие но с несколько оговорка в параметр компилятор надо добавить --add-exports javabase/jdkinternalreflect=sample где sample — это имя ваш модуль в параметр запуск надо добавить --add-opens javabase/jdkinternalreflect=sample --add-opens javabase/javalang=sample --add-opens javabase/javalangreflect=sample --add-opens javabase/javalanginvoke=sample --add-opens javabase/jdkinternalreflect=javabase в зависимость модуль надо добавить requires jdkunsupported у конструктор javalangclass поменяться сигнатура надо учесть так же стоить учесть что sunreflect перенести в jdkinternalreflect и что класс myconstructorinvocator теперь надо грузить тем же загрузчик что у magicaccessorimpl classloadergetsystemclassloader уже не сработать у он не быть доступ ещё исправить странный баг с nosuchfielderror теперь на он место nosuchmethoderror который там и должный быть мелочь но приятно в целое в java 9 нужно намного сильный постараться чтобы выстрелить себя в нога даже если именно это и являться главный цель думать это и к хороший вывод при желание в java можно творить абсолютно безумный вещий это забавно reflection api не так уж и сложно устроенный magicaccessorimpl мочь не весь sunmiscunsafe мочь не весь но почти java 9 ещё сильный стараться вы обезопасить не стоить слишком серьёзно воспринимать весь описать сам по себя задача инстанцирование javalangclass совершенно бессмысленный здесь важный знание получить в процесс её решение спасибо за внимание 
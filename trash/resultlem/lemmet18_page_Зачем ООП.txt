зачем ооп продолжать про ооп налицо поверхностный понимание я попробовать сжато ответить на вопрос «зачем осознавать грандиозность замысел давать так задуматься над вопрос «зачем ооп ответ дать в несколько слово выразить максимально емко весь польза ооп не нажимать «читать далёкий пока не ответить для себя разумеется правильный ответ никто не знать но два самый главное польза следующий 1 упрощение понимание человек 2 локализация влияние код 1 упрощение понимание — человек ведь наш человеческий язык так и устроенный помнить шутка про «утка что такой «стул «вота это стул на немой сидеть это одновременно и поведение и предмет человек привыкнуть обозначать класс предмет схожий поведение один слово который определять он поведение что же удивительный в тот что этот практика перекочевать в программирование ведь гораздо простой рассуждать о стек чем о «этом набор дать и код который отдавать один последний занести объект 2 локализация влияние давать представимый себя неправильный разработка приложение например есть структура с дать пользователь и есть структура запись журнал при сохранение на диск с они нужно работать одинаково — рассматривать они как непрерывный блок дать однако этот работа не быть проделать не быть выявить поведение значит в любой место у мы дублироваться код запись в файл системный вызов и тд начинать расширять — хотеть транзакционный запись как быть она нужно прикрутить она к весь место где есть запись на диск и тд через какой-то время расширение приложение становиться слишком дорогостоящий получать то что называть «монолитный приложение это плохо вроде бы весь это понимать внимание — вопрос а что являться «антимонолитный приложение остановиться подумать какой она — идеальный архитектура весь просто — она легко расширяться в рамка поставить задача как это достигнуть правильный ответ такой — нужно выделить одинаковый поведение и запрограммировать он в один место следующий вопрос — одинаковый поведение «чего компонент класс объект а это важный неважно как назвать что такой бд объект класс модуль компонент это неважно важный то что мы разрешить иметь собственный состояние для реализация поведение по управление внешний хранение дать и «освободить свой код от это поведение вы уже наверное догадаться к что я клонить к тот что принцип который я называть «принцип ооп разделение поведение и разрешение иметь свой состояние естественный образ возникать при решение люба мало-мальски сложный задача это важный и я повторить только разделение специализация поведение позволять создавать архитектура который легко расширяться разделение поведение означать появление собственный локальный состояние и следовательно возникать какой-то сущность хранить состояние «локальность состояние означать что влияние код ограничить рамка сущность назвать сущность объект в смысл экземпляр класс а поведение — класс это и есть ооп механизм реализация оставаться на совесть или бессовестность создатель язык и компилятор где-то есть автоматический деструктор где-то — нет где-то есть приватный дать класс где-то нет где-то есть наследование а где-то он надо сооружать где-то есть явный класс а где-то объект мочь быть какой угодный где-то есть интерфейс где-то нет это не ооп это механизм реализация ооп — это архитектура приложение главный принцип ооп — расширяться класс выявить локализовать поведение и создать для это класс и ещё это не для новичок использование объект не являться ооп если программист мочь вызвать mathrandom он не становиться ооп-программист но разработка в стиль ооп — это не аз не начало программирование чтобы выявить поведение — нужно иметь опыт нужно понимать что такой «специализация поведение как быть новичок изучать хорошо спроектировать приложение в тот область который интересный 
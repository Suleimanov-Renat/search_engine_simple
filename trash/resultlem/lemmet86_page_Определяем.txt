определять весь класс который использовать приложение на java без сомнение каждый кто в свой резюме указывать опыт разработка на java хоть раз в жизнь писать строка public static void mainstring[] args компилировать они и запускать на выполнение команда наподобие java helloworld но многие ли знать что происходить внутри jvm от момент выполнение этот команда до тот как управление передаваться метод main как java находить и загружать необходимый пользователь класс возникнуть однажды производственный задача заставить автор разобраться в это вопрос результат изыскание под кат сразу стоить оговориться что статья не претендовать на полнота охват весь существующий jvm тестирование проводиться только на sun hotspot jvm постановка задача в один прекрасный день заказчик потребоваться выяснить какой класс использовать он приложение приложение быть уже хорошо знакомый автор и представлять себя гремучий смесь из код различный расовый принадлежность реализовать к честь разработчик система по больший часть грамотно и к место механизм наследование поздний связывание и динамический компиляция поэтому информация о действительно использовать класс мочь существенно помочь в рефакторинг приложение задача поставить следующий образ в процесс работа приложение должный формироваться файл содержимый имя весь класс непосредственно использовать приложение оно к слово состоять из два основный часть сервер приложение на который разместить веб-интерфейс приложение и сервер обработка отдельный сервер на который различный периодический задача запускаться с помощь скрипт ant разумеется информация о класс необходимый собирать с оба часть приложение приступить к поиск решение поставить задача и заодно разобраться с механизм загрузка класс в java переопределение системный загрузчик класс один направление который пришлый в голова при решение дать задача быть воспользоваться возможность расширение механизм загрузка класс в java на данный тема написать достаточно много стать тот число и на русский язык ссылка в конец статья быть данный механизм в следующий наследник абстрактный класс javalangclassloader использоваться для непосредственный загрузка класс о чем красноречивый свидетельствовать сигнатура метод class loadclassstring name данный метод должный найти массив байт являться байт-код искомое класс и передать он метод protected class defineclassstring name byte[] b int off int len который превратить он в экземпляр класс javalangclass такой образ реализовать свой загрузчик разработчик мочь загружать из любой место откуда можно получить массив байт разработчик фреймворка декларироваться хитрый механизм иерархия и наследование загрузчик при это наследование здесь следовать понимать не в термин наследование класс в ооп а как отдельный иерархия организовать с помощь метод getparent класс classloader при старт jvm создаваться вершина этот иерархия из три основный загрузчик базовый bootstrap classloader отвечать за загрузка базовый класс фреймворка загрузчик расширение extension classloader отвечать за загрузка класс из lib/ext и системный загрузчик system classloader отвечать за загрузка пользовательский класс далее разработчик вольный продолжать этот иерархия от системный загрузчик и ниже по умолчание в hotspot jvm в качество системный загрузчик использоваться класс sunmisclauncher$appclassloader однако он можно легко переопределить с помощь системный свойство javasystemclassloader ключ командный строка java -djavasystemclassloader=имяклассазагрузчик декларироваться правило делегирование загрузка люба загрузчик прежде чем пытаться загрузить люба класс сначала должный обратиться к свой родитель и только если тот не смочь загрузить искомый класс попытаться загрузить он сам к сожаление красота и удобство данный правило компенсироваться необязательность он исполнение с последствие неисполнение это правило автор ещё предстоять столкнуться однако на дать этап уже появиться один концепция решение поставить задача реализовать собственный загрузчик класс заменять системный который при вызов метод loadclass быть просто записывать имя класс в файл и передавать запрос на загрузка класс настоящий системный загрузчик при условие соблюдение описать выше правило делегирование это должный позволить отловить весь загружать пользовательский класс даже если они загружаться другой загрузчик заставить весь jvm запускать на машина использовать данный загрузчик класс как системный для реализация два пункт необходимый решить следующий задача сделать класс видимый для весь запускать jvm включать класс в весь classpath множество компонент приложение неудобно трудоёмкий и нерационально с точка зрение расширение система тем более что существовать более красивый решение — поместить класс загрузчик в папка lib/ext jre класс в этот папка становиться доступный автоматически без внесение они в classpath как отмечаться выше они загружаться загрузчик расширение при старт jvm задать для весь jvm системный свойство javasystemclassloader — из командный строка это можно сделать так java -djavasystemclassloader=имяклассазагрузчик hellowolrd непосредственно заставить весь jvm запускаться с необходимый параметр -djavasystemclassloader как оказаться для это тоже существовать изящный решение — нужно использовать специальный переменный окружение значение который автоматически добавляться к параметр запуск люба jvm в процесс поиск быть найти два переменный который мочь бы отвечать за данный возможность javaopts и javatooloptions однако ни один из стать не давать чёткий ответ на вопрос в чем же отличие этот два переменный ответ на данный вопрос быть решить найти опытный путём в ход эксперимент быть установить что по настоящий «волшебный являться переменный javatooloptions значение который автоматически добавляться к параметр запуск люба запускать hotspot jvm а javaopts — это результат негласный соглашение разработчик различный java приложение данный переменный в явный вид использовать многие скрипт например startupsh/startupbat для запуск apache tomcat однако никто не гарантировать что данный переменный быть использовать весь разработчик скрипт итак дело сделать загрузчик скомпилировать и поместить в lib/ext значение переменный окружение javatooloptions задать запускать приложение работать открывать лог и видим… скудный список из десятка класс включая системный и ещё несколько сторонний класс вот тут-то и прийтись вспомнить о необязательность выполнение правило делегирование загрузка а так же заглянуть в исходный код apache ant и tomcat как оказаться в этот приложение использоваться собственный загрузчик класс это с один сторона отчасти и позволить имя обрести свой мощный функционал однако по тем или иной причина разработчик этот продукт решить не придерживаться рекомендовать правило делегирование загрузка и написать они загрузчик далеко не всегда обращаться к свой родитель перед тем как загрузить очередной класс именно поэтому наш системный загрузчик почти ничто не знать о класс загружать tomcat-ом и ant-ом такой образ описать способ не позволять отловить весь требовать класс особенно учитывать разнообразие использовать сервер приложение — кто знать как отнестись к правило делегирование загрузка разработчик использовать заказчик сервер приложение попытка номер два применять инструментация класс порой для решение задача не достаточно один знание или умение иногда для достижение цель необходимый интуиция и чуточку везение сейчас автор уже и не вспомнить в ответ на какой поисковый запрос о загрузчик класс поисковый гигант выдать ссылка на статья о механизм инструментация класс как оказаться данный инструмент предназначить для изменение байт код java класс в время они загрузка к пример jprofiler с помощь данный механизм встраиваться в класс для замер производительность стоп что значит в время они загрузка то есть данный механизм знать о каждый загрузить класс да знать и как оказаться даже хороший чем загрузчик класс — метод byte[] transformclassloader loader string classname class<> classbeingredefined protectiondomain protectiondomain byte[] classfilebuffer интерфейс classfiletransformer вызываться у реализовать он класс-трансформатор при загрузка любой класс этот метод и оказаться тем бутылочный горлышко через который проходить люба загружать класс за исключение совсем небольшой количество системный теперь задача сводиться к следующий написать свой класс-трансформатор реализовать метод classfiletransformertransform который правда не быть осуществлять никакой трансформация а быть всего лишь записывать имя загрузить класс в файл и снова нужно сделать так чтобы написать мы класс подключаться к любой запускать java приложение исходный код класс-трансформатор представить ниже package comtest import javaiofile import javalanginstrumentinstrumentation import javalanginstrumentclassfiletransformer import javasecurityprotectiondomain import javalanginstrumentillegalclassformatexception public class loggingclassfiletransformer implements classfiletransformer { public static void premainstring agentarguments instrumentation instrumentation { instrumentationaddtransformernew loggingclassfiletransformer } /** * данный метод вызываться для любой загрузить класс * @param classname имя загружать класс для запись в лог * @return неизмененный classfilebuffer содержимый байт-код класс */ public byte[] transformclassloader loader string classname class<> classbeingredefined protectiondomain protectiondomain byte[] classfilebuffer throws illegalclassformatexception { logclassname return classfilebuffer } // сохранять лог в папка lib/ext private static final file logfile = new filesystemgetproperty"javaextdirs"splitfilepathseparator[0]+"/loggingclassfiletransformerlog" public static synchronized void logstring text { // запись в файл //  } } здесь необходимый пояснить механизм использование класс-трансформатор чтобы подключить такой класс к приложение мы понадобиться так называть premain класс тот класс содержимый метод public static void premainstring paramstring instrumentation paraminstrumentation из название метод понятно что он вызываться до вызов метод main в этот момент можно подключить к приложение класс-трансформатор с помощь метод addtransformer интерфейс javalanginstrumentinstrumentation такой образ привести выше класс одновременно являться и класс-трансформатор и premain-класс чтобы данный класс можно быть использовать он необходимый поместить в jar файл манифест который файл meta-inf/manifestmf содержимый параметр premain-class указывать на полный имя premain-класс в наш случай premain-class comtestloggingclassfiletransformer затем необходимый указать полный путь к дать архив с помощь параметр -javaagent при запуск jvm тут мы на помощь снова приходить переменный javatooloptions итак класс написать скомпилировать упаковать вместе с манифест в jar переменный окружение javatooloptions=-javaagent"путь к loggingclassfiletransformerjar" задать приложение запустить лог собранный profit upd3 хабраюзер grossws предложить ещё один способ использовать инструментация — aspectj «актуальный если надо дёшево инструментировать весь класс в свой часть приложение не затрагивать окружение но это немного другой задача upd путь три простой как лом спасибо хабраюзер spiff и apangin который в личка напомнить про ещё один способ который быть я испробовать но быть незаслуженно забытый тк в конечный итог не подойти данный способ основать на запуск jvm с параметр -verboseclass или --xx+traceclassloading при использование любой из этот параметр в стандартный поток вывод jvm сыпаться сообщение вид [loaded javautildate from shared objects file] однако у данный способ несмотря на он простота есть один существенный недостаток — сложно контролировать формат выводить сообщение а так же направление вывод а рассматривать приложение и без тот выводить достаточно отладочный информация в stdout и возможность отфильтровать из это поток нужный сообщение и перенаправить они в отдельный файл для весь экземпляр jvm запускать на сервер представляться весьма проблематичный upd2 хабраюзер apangin данный способ быть допилить до следующий вариант запуск jvm java -xx+traceclassloading -xx+unlockdiagnosticvmoptions -xx+logvmoutput -xxlogfile=java*log -xx-displayvmoutput helloworld вместо * автоматически подставиться pid после запуск такой команда сформироваться файл с имя например java580log примерно следующий содержание <xml version='10' encoding='utf-8'> <hotspotlog version='160 1' process='580' timems='1334248301214'> <vmversion> <name> java hotspottm client vm </name> <release> 206-b01 </release> <info> java hotspottm client vm 206-b01 for windows-x86 jre 16031-b05 built on feb 3 2012 184409 by "javare" with ms vc++ 71 vs2003 </info> </vmversion> <vmarguments> <args> -xx+traceclassloading -xx+unlockdiagnosticvmoptions -xx+logvmoutput -xxlogfile=java*log -xx-displayvmoutput </args> <command> test </command> <launcher> sunstandard </launcher> <properties> javavmspecificationname=java virtual machine specification javavmversion=206-b01 javavmname=java hotspottm client vm javavminfo=mixed mode sharing javaextdirs=c\program files\java\jre6\lib\extc\windows\sun\java\lib\ext javaendorseddirs=c\program files\java\jre6\lib\endorsed sunbootlibrarypath=c\program files\java\jre6\bin javalibrarypath=c\windows\system32c\windows\sun\java\binc\windows\system32c\windowsc\program files\pc connectivity solution\c\program files\rockwell software\rscommonc\windows\system32c\windowsc\windows\system32\wbemc\program files\java\jdk16006\binc\hibernatec\windows\system32\windowspowershell\v10c\program files\tortoisesvn\binc\program files\nmapc\progra~1\common~1\muveet~1\030625c\progra~1\common~1\muveet~1\030625 javahome=c\program files\java\jre6 javaclasspath= sunbootclasspath=c\program files\java\jre6\lib\resourcesjarc\program files\java\jre6\lib\rtjarc\program files\java\jre6\lib\sunrsasignjarc\program files\java\jre6\lib\jssejarc\program files\java\jre6\lib\jcejarc\program files\java\jre6\lib\charsetsjarc\program files\java\jre6\lib\modules\jdkbootjarc\program files\java\jre6\classes javavmspecificationvendor=sun microsystems inc javavmspecificationversion=10 javavmvendor=sun microsystems inc sunjavacommand=test sunjavalauncher=sunstandard </properties> </vmarguments> <tty> <writer thread='1504'/> [loaded javalangobject from shared objects file]  <writer thread='3092'/> <destroyvm stamp='0281'/> <ttydone stamp='0283'/> </tty> <hotspotlogdone stamp='0283'/> </hotspotlog> в стандартный поток вывод при это ничто новое не писаться благодаря опция -xx-displayvmoutput главное достоинство данный способ являться он простота не факт что такой формат файл подойти бы заказчик но это уже вопрос дискуссионный и он не входить в рамка дать статья заключение итак какой вывод можно сделать после окончание работа над проект механизм загрузка класс в java — интересный и весьма полезный возможность фреймворка который мочь пригодиться для решение определённый круг задача однако стоить помнить что основный задача который можно решить с помощь данный механизм это именно найти и загрузить класс из место откуда он не мочь загрузить другой для сбор информация о загрузить класс данный механизм мочь быть малопригодный инструментация класс в java — другой мощный механизм по работа с класс и как раз таки он задача — произвольный работа с класс как с подопытный кролик нужно ли вы получить информация о время работа метод или просто узнать имя только что загрузить класс — данный механизм прийти на помощь java в целое — открытый и способствовать творчество платформа приложение с открытый исходный код на это как и на любой друг язык — полезный не только свой функциональность но и ценный идея который можно почерпнуть изучать на они исходный код да и отсутствие исходный код зачастую не являться проблема для приложение на java существовать много средство позволять отобразить исходный код практически любой скомпилировать java класс с они помощь вы мочь с лёгкость проанализировать код практически любой класс и метод даже из ядро фреймворка например из файл rtjar разумеется за исключение нативный метод в работа над это и многий другой проект автор пригодиться бесплатный утилит java decompiler позволять увидеть исходный код практически любой скомпилировать класс java особенно завораживать возможность увидеть тот часть исходный код ядро java который сам написать на java если например открыть файл rtjar лежать в папка lib jre список использовать источник статья о загрузчик класс в java habrahabrru/post/103830 voitukkievua/2008/01/14/java-plugins blogsoraclecom/vmrobot/entry/%d0%be%d1%81%d0%bd%d0%be%d0%b2%d1%8b%d0%b4%d0%b8%d0%bd%d0%b0%d0%bc%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b9%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b8%d0%ba%d0%bb%d0%b0%d1%81%d1%81%d0%be%d0%b2%d0%b2 другой полезный ссылка stackoverflowcom/questions/3933300/difference-between-java-opts-and-java-tool-options — вопрос о переменный javaopts и javatooloptions docsoraclecom/javase/142/docs/api/java/lang/classloaderhtml#getsystemclassloader — как переопределить системный загрузчик wwwsqlru/forum/actualthreadaspxtid=858652 — именно дать тема натолкнуть на идея о использование instrumentation вместо загрузчик класс wwwexampledepotcom/egs/javalang/propcmdlinehtml — как установить значение системный свойство java из командный строка docsoraclecom/javase/142/docs/guide/extensions/spechtml — как получить путь к папка lib/ext wwwjavalobbyorg/java/forums/t19309html — в статья привести пример простейшее класс-трансформатор todayjavanet/pub/a/today/2008/04/24/add-logging-at-class-load-time-with-instrumentationhtml — в статья решаться похожий задача по принудительный ведение логово в весь загружать класс javadecompilerfreefr — домашний страница проект java decompiler wwworaclecom/technetwork/java/javase/tech/vmoptions-jsp-140102html — описание некоторый параметр запуск hotspot jvm q-reduxblogspotcom/2011/01/inspecting-hotspot-jvm-optionshtml — ещё один статья про редко использовать параметр запуск hotspot jvm habrahabrru/post/140133 — статья про особенность загрузчик класс в некоторый сервер приложение 
личный опыт переход с низкоуровневый разработка на c к программирование на java статья отражать личный опыт автор – заядлый программист микроконтроллер который после многолетний опыт микроконтроллерный разработка на язык с и немного на с++ довестись участвовать в крупный java-проект по разработка по для тв-приставка под управление android в ход это проект удаться собрать заметка о интересный различие язык java и c/c++ оценить разный подход к написание программа статья не претендовать на роль справочник в она не рассматриваться эффективность и производительность java-программа это скорее сборник личный наблюдение если не указать иной то речь идти о версия java se 7 различие в синтаксис и управлять конструкция если говорить кратко – различие минимальный синтаксис очень похожий блок код также формироваться пара фигурный скобка {} правило составление идентификатор – такой же как и для язык c/с++ список ключевой слово почти такой же как в язык c/с++ встроить тип дать – подобный таковой в c/с++ массив – весь также объявляться с помощь квадратный скобка управлять конструкция if-else while do-while for switch тоже почти полностью идентичный примечательно что в java остаться знакомый c-программист метка тот который использоваться с ключевой слово goto и применение который категорически не рекомендоваться однако из java исключить возможность переход на метка с помощь goto метка следовать использовать только для выход из вложить цикл outer for int i = 0 i < 5 i++ { inner for int j = 0 j < 5 j++ { if i == 2 break inner if i == 3 continue outer } } для улучшение читаемость программа в java добавить интересный возможность разделять разряд длинный число символ подчёркивание int value1 = 1500000 long value2 = 0xaabbccdd внешне программа на java не сильно отличаться от программа на знакомый c главный визуальный отличие – java не допускать «свободно расположить в исходный файл функция переменный определение новый тип структура константа и прочее java – объектно-ориентированный язык поэтому весь программный сущность должный принадлежать какой-либо класс ещё один значительный отличие – отсутствие препроцессор о этот два различие дробный рассказать ниже объектный подход в язык c когда мы писать на язык c большой программа по суть мы приходиться работать с объект роль объект здесь выполнять структура который описывать некий сущность «реальный мир // объявление структура – «класс struct data { int field char *str /*  */ } также в c есть метод обработка «объект-структура – функция однако функция по суть не объединить с дать да они обычно помещать в один файл но в «типовой функция каждый раз необходимый передавать указатель на обрабатывать объект int processstruct data *ptr int arg1 const char *arg2 { /*  */ return resultcode } пользоваться «объект можно только после выделение память для он хранение data *data = mallocsizeofdata в программа на c обычно определять функция который отвечать за начальный инициализация «объект перед один он использование void initstruct data *data { data->field = 1541 data->str = null } тогда жизненный цикл «объект в c обычно такой /* выделить память для "объекта" */ struct data *data = mallocsizeofdata /* инициализировать "объект" */ initdata /* изменить состояние "объекта" */ processdata 0 "string" /* освободить память занимать "объектом" когда он уже не нужный */ freedata теперь перечислимый возможный ошибка время выполнение который мочь быть допустить программист в жизненный цикл «объект забыть выделить память для «объект указать неверный объесть выделять память забыть проинициализировать «объект забыть освободить память после окончание использование объект выявить подобный ошибка мочь быть крайне сложно так как они не определяться компилятор и проявляться в время работа программа более тот они эффект мочь быть очень разнообразный и сказываться на другой переменный и «объект программа объектный подход java сталкиваться с ооп – объектно-ориентированный программирование вы наверняка слышать о один из кит ооп – инкапсуляция в java в отличие от c дать и метод они обработка объединить вместе и представлять себя «истинный объект в термин ооп это называть инкапсуляция класс – это описание объект ближний аналог класс в c – определение новое тип с помощь typedef struct в термин java тот функция который принадлежать класс называть метод // описание класс class entity { public int field // пол дать public string str // пол дать // метод public int processint arg1 string arg2 { /*  */ return resultcode } // конструктор public entity { field = 1541 str = "value" } } в основа идеология язык java лежать утверждение «всё есть объект поэтому не удивительно что java запрещать создавать как метод функция так и поль дать переменный отдельно от класс даже привычный метод main с который начинаться выполнение программа должный принадлежать один из класс описание класс в java – это аналог объявление структура в c описать класс вы ничто не создавать в память объект данный класс появляться в момент свой создание оператор new создание объект в java – это аналог выделение память в язык c но в отличие от последний в время создание автоматически вызываться специальный метод – конструктор объект конструктор брать на себя роль начальный инициализация объект – аналог функция init рассмотреть ранее имя конструктор обязательно должный совпадать с имя класс конструктор не мочь возвращать значение жизненный цикл объект в программа на java выглядеть следующий образ // создать объект выделить память и инициализировать вызвать конструктор entity entity = new entity // изменить состояние объект entityprocess123 "argument" заметить что количество возможный ошибка в программа на java значительно маленький чем в программа на c да по-прежнему можно забыть создать объект перед один использование что впрочем привести к легко отлаживать исключение nullpointerexception но то что касаться остальной ошибка присущий программа на c ситуация коренной образ меняться в java отсутствовать оператор sizeof компилятор java сам рассчитывать объесть память для хранение объект следовательно невозможно указать неверный размер выделять область инициализация объект происходить в момент создание невозможно забыть о проведение инициализация память занимать объект не нужно освобождать этот работа выполнять сборщик мусор невозможно забыть удалить объект после использование – маленький вероятность появление эффект «утечка память итак весь в java являться объект тот или иной класс исключение являться примитив который быть добавить в язык для улучшение производительность и потребление память дробный о примитив – ниже память и сборщик мусор в java сохранить знакомый c/c++-программист понятие куча и стек при создание объект оператор new память для хранение объект заимствоваться из куча однако ссылка на объект ссылка – аналог указатель если создать объект не входить в состав другой объект размещаться в стек в куча храниться «тело объект а в стек – локальный переменный ссылка на объект и примитивный тип если куча существовать на протяжение выполнение программа и доступный для весь поток программа то стек относиться к метод и существовать только в время он выполнение а также недоступный для другой поток программа в java нет необходимость и даже более тот – нельзя вручную освободить память занимать объект этот работа выполнять сборщик мусор в автоматический режим среда выполнение следить можно ли из текущий место программа достигнуть каждый объект в куча переходить по ссылка от объект к объект если нет – то такой объект признаваться «мусор и становиться кандидат на удаление важный отметить что сам удаление происходить не в момент когда объект «перестать быть нужный – решение о удаление принимать сборщик мусор и удаление мочь откладываться сколько угодный вплоть до момент окончание работа программа разумеется работа сборщик мусор требовать накладный расход процессорный время но взамен он избавлять программист от большой головной боль связанный с необходимость освобождать память после окончание использование «объект фактически мы «брать память когда мы это нужно и пользоваться она не думать что она надо после себя освобождать говорить о локальный переменный следовать вспомнить подход java к они инициализация если в c/c++ неинициализированный локальный переменный содержимый случайный значение то компилятор java попросту не позволить оставить она неинициализированный int i // неинициализированный переменный systemoutprintln"" + i // ошибка компиляция ссылка – замена указатель в java отсутствовать указатель соответственно у java-программист нет возможность совершить один из множество ошибка возникать при работа с указатель когда вы создавать объект вы получать ссылка на этот объект // переменный entity – ссылочный тип entity entity = new entity в язык c у программист быть выбор как передавать скажем структура в функция можно быть передавать по значение // передача структура по значение int funcdata data а можно быть – передавать через указатель // передача структура через указатель void processdata *data передача по значение гарантировать что функция не изменить дать в структура но быть неэффективный с точка зрение быстродействие – в момент вызов функция создаваться копия структура передача через указатель гораздо более эффективный фактически в функция передаваться адрес в память где расположить структура в java оставить только один способ передача объект в метод – по ссылка передача по ссылка в java – аналог передача через указатель в c копирование клонирование память не происходить фактически передаваться адрес размещение данный объект однако в отличие от указатель язык c ссылка java нельзя инкрементировать/декрементировать «бегать по элемент массив с помощь ссылка на он в java не получиться весь что можно сделать с ссылка это присвоить она другой значение безусловно отсутствие указатель как таковой уменьшать количество возможный ошибка однако в язык остаться аналог нулевой указатель – нулевой ссылка обозначать ключевой слово null нулевой ссылка – это головной боль java-программист тк вынуждать перед использование ссылка на объект либо проверить она на null либо обрабатывать исключение nullpointerexception если это не делать то произойти крах программа итак весь объект в java передаваться через ссылка примитивный же тип дать int long char – передаваться по значение дробный о примитив – ниже особенность ссылка в java доступ к любой объект в программа осуществляться через ссылка – это однозначно положительно сказываться на производительность но мочь преподнести сюрприз новичок // создать объект пусть ссылка entity1 указывать не он entity entity1 = new entity entity1field = 123 // создать ссылка entity2 который указывать на объект entity1 // новый объект не создаваться память не выделяться entity entity2 = entity1 // теперь ссылка entity1 и entity2 указывать на один и тот же объект в память entity2field = 777 // теперь entity1field равно 777 systemoutprintlnentity1field аргумент метод и возвращать значение – весь передаваться через ссылка кроме преимущество в это крыться недостаток по сравнение с язык c/с++ где мы мочь явно запретить функция менять значение передать через указатель с помощь квалификатор тип const void funcconst struct data* data { // ошибка компиляция // попытка запись в объект доступный только для чтение data->field = 0 } то есть язык c позволять отследить этот ошибка на этап компиляция в java так же есть ключевой слово const но оно зарезервировать для будущий версия и сейчас вообще не использоваться он роль в некоторый степень призвать выполнять ключевой слово final однако оно не позволять защитить передаваемый в метод объект от изменение public class main { void funcfinal entity data { // компилятор не выдавать ошибка // не смотреть на final значение поль успешно обнуляться datafield = 0 } } весь дело в тот что ключевой слово final в дать случай применяться к ссылка а не к объект на который этот ссылка указывать если применить final к примитив то компилятор вести себя так как и ожидаться void funcfinal int value { // ошибка на стадия компиляция value = 0 } ссылка java очень похожий на ссылка язык c++ примитив java каждый объект java помимо полый дать содержимый вспомогательный информация если мы хотеть оперировать например отдельный байт и каждый байт представить объект то в случай массив байт накладный расход память мочь многократно превысить полезный объесть чтобы java оставаться достаточно эффективный и в случай описать выше в язык быть добавить поддержка примитивный тип – примитив примитив вид разрядность битый возможный аналог в c byte целочисленный 8 char short 16 short char 16 wchart int 32 int long long 64 long float число с плавать точка 32 float double 64 double boolean логический - int c89 / bool c99 весь примитив иметь свой аналог в язык c однако стандарт c не определять точный размер целочисленный тип вместо это фиксироваться диапазон значение который мочь хранить данный тип зачастую программист хотеть обеспечить одинаковый разрядность для разный машина что приводить к появление в программа тип наподобие uint32t хотя весь библиотечный функция как раз таки требовать аргумент тип int этот факт никак нельзя отнести к преимущество язык целочисленный примитив в java в отличие от c иметь фиксировать разрядность такой образ можно не заботиться о реальный разрядность машина на который выполняться java-программа а также о порядок байт «сетевой или «интеловский этот факт помогать реализовать принцип «написать однажды – выполняться везде кроме это в java весь целочисленный примитив – знаковый в язык отсутствовать ключевой слово unsigned это исключать трудность при совместный использование знаковый и беззнаковый переменный в один выражение присущий язык c в завершение порядок байт в многобайтный примитив в java фиксировать младший байт по младший адрес little-endian обратный порядок к недостаток реализация операция с примитив в java можно отнести тот факт что здесь как и в программа на c/c++ мочь произойти переполнение разрядный сетка причём никакой исключение при это не возбуждаться int i1 = 2147483640 int i2 = 2147483640 int r = i1 + i2 // r = -16 итак дать в java представить два вид сущность объект и примитив примитив нарушать концепция «всё есть объект но в некоторый ситуация слишком эффективный чтобы они не использовать наследование наследование являться ещё один кит ооп о который вы наверняка слышать если ответить кратко на вопрос «зачем наследование вообще нужно то ответ быть «повторный использование код допустить вы программировать на c и у вы есть хорошо написать и отладить «класс – структура и функция для она обработка далее возникать необходимость создать подобный «класс но с расширить функциональность причём базовый «класс весь ещё оставаться нужный в случай язык c для решение такой задача у вы есть единственный путь – композиция речь идти о создание новый расширить структура-класс который должный содержимый указатель на базовый «класс-структура struct base { int field1 char *field2 } void basemethodstruct base *obj int arg struct extended { struct base *base int auxfield } void extendedmethodstruct extended *obj int arg { basemethodobj->base 123 /*  */ } java как объектно-ориентированный язык позволять расширять функциональность иметься класс с помощь механизм наследование // базовый класс class base { protected int basefield private int hidden public void basemethod { } } // производный класс - расширять функциональность базовый class extended extends base { public void extendedmethod { // полный доступ к public и protected поль и метод базовый класс basefield = 123 basemethod // ошибка доступ к private поль запретить hidden = 123 } } необходимый отметить что java ни в кой раз не запрещать использовать композиция как способ расширение функциональность уже написать класс более тот в многий ситуация композиция оказываться предпочтительный наследование благодаря наследование класс в java выстраиваться в иерархический структура каждый класс обязательно иметь один и только один «родитель и мочь иметь сколько угодный «ребёнок в отличие от c++ класс в java не мочь наследовать более чем от один родитель такой образ решаться проблема «ромбовидный наследование при наследование производный класс получать в свой расположение весь public и protected поль и метод свой базовый класс а также базовый класс свой базовый класс и так далее вверх по иерархия наследование на вершина иерархия наследование находиться общий прародитель весь java класс – класс object единственный кто не иметь родитель динамический идентификация тип один из ключевой момент язык java являться поддержка динамический идентификация тип rtti если говорить простой слово то rtti позволять подставлять объект производный класс там где требоваться ссылка на базовый // ссылка на базовый класс base link // ссылка на базовый класс присвоить объект производный класс link = new extended иметь ссылка в время выполнение программа можно определить истинный тип объект на который дать ссылка ссылаться – с помощь оператор instanceof if link instanceof base { // false } else if link instanceof extended { // true } переопределение метод под переопределение метод или функция пониматься замена он или она тело на этап выполнение программа программист c известный возможность язык изменить поведение функция в время выполнение программа речь идти о использование указатель на функция например в состав структура можно включить указатель на функция и присваивать указатель различный функция менять алгоритм обработка дать этот структура struct object { // указатель на функция void *processstruct object * int data } void dividebytwostruct object *obj { obj->data = obj->data / 2 } void squarestruct object *obj { obj->data = obj->data * obj->data } struct object obj objdata = 123 objprocess = dividebytwo objprocess&obj // 123 / 2 = 61 objprocess = square objprocess&obj // 61 * 61 = 3721 в java как и в другой язык ооп переопределение overriding метод неразрывно связать с наследование производный класс получать доступ к public- и protected-метод базовый класс кроме тот что он мочь они вызывать можно изменить поведение один из метод базовый класс не менять при это он сигнатура для это достаточно определить в производный класс метод с точно такой же сигнатура // производный класс - расширять функциональность базовый class extended extends base { // переопределенный метод public void method { /*  */ } // этот же метод не переопределить // eго сигнатура отличаться от метод базовый класс // это самостоятельный метод производный класс public void methodint i { /*  */ } } очень важный чтобы сигнатура имя метод возвращать значение аргумент с точность совпадать если имя метод совпадать а аргумент отличаться то происходить перегрузка overloading метод дробный о который ниже полиморфизм как инкапсуляция и наследование три кит ооп – полиморфизм – также иметь в некоторый род аналог в процедурно-ориентировать язык c допустить у мы есть несколько «класс-структура с который требоваться выполнять однотипный действие причём функция выполнять это действие должный быть универсальный – должный «уметь работать с любой «класс в качество аргумент возможный решение выглядеть так /* идентификатор класс */ enum ids { ida idb } struct classa { int id /*  */ } void ainitclassa obj { obj->id = ida } struct classb { int id /*  */ } void binitclassb obj { obj->id = idb } /* klass - указатель на classa classb  */ void commonfuncvoid *klass { /* получить идентификатор */ int id = int *klass switch id { case ida classa *obj = classa * klass /*  */ break case idb classb *obj = classb * klass /*  */ break } /*  */ } решение выглядеть громоздко но цель достигнуть – универсальный функция commonfunc принимать в качество аргумент «объект любой «класс обязательный условие – «класс-структура в первое пол должный содержимый идентификатор по который определяться действительный «класс объект такой решение возможно благодаря использование аргумент с тип «void * однако такой функция можно передать указатель любой тип например «int * ошибка компиляция это не вызвать но в время выполнение программа быть вести себя непредсказуемый теперь рассмотреть как полиморфизм выглядеть в java впрочем как и в любой друг язык ооп пусть у мы есть множество класс который должный однотипный обрабатываться некоторые метод в отличие от решение для язык с представить выше этот полиморфный метод обязать входить в состав весь класс данный множество и весь он версия обязать иметь одинаковый сигнатура class a { public void method {/*  */} } class b { public void method {/*  */} } class c { public void method {/*  */} } далее необходимый заставить компилятор вызывать именно тот версия метод который принадлежать соответствующий класс void executorsetofclass klass { klassmethod } то есть метод executor который мочь быть где угодный в программа должный «уметь работать с любой класс из множество a b или c надо какой-то образ «сказать компилятор что setofclass обозначать наш множество класс здесь и пригождаться наследование – необходимый сделать весь класс из множество производный некоторый базовый класс который быть содержимый полиморфный метод abstract class base { abstract public void method } class a extends base { public void method {/*  */} } class b extends base { public void method {/*  */} } class c extends base { public void method {/*  */} } тогда метод executor быть выглядеть так void executorbase klass { klassmethod } и теперь он можно передавать в качество аргумент люба класс который являться наследник base благодаря динамический идентификация тип executornew a executornew b executornew c в зависимость от тот объект какой класс передать в качество аргумент быть вызвать метод принадлежащий это класс ключевой слово abstract позволять исключить тело метод сделать он абстрактный выражаться термин ооп фактически мы говорить компилятор что этот метод должный быть обязательно переопределить в класс наследник если это не так возникать ошибка компиляция класс содержимый хотя бы один абстрактный метод также называть абстрактный компилятор требовать помечать такой класс также ключевой слово abstract структура проект на java в java весь файл с исходный код иметь расширение *java отсутствовать как заголовочный файл *h так и прототип функция или класс каждый файл с исходный код java должный содержимый хотя бы один класс имя класс принять записывать начинать с заглавный буква несколько файл с исходный код мочь объединяться в пакет package для это должный быть выполнить следующий условие файл с исходный код должный находиться в один директория в файловый система имя этот директория должный совпадать с имя пакет в начало каждый файл с исходный код должный быть указанный пакет к который этот файл относиться например package comcompanypkg чтобы обеспечить уникальность имя пакет в предел земной шар предлагаться использовать «перевернуть доменный имя компания однако это не являться требование и в локальный проект можно использовать любой имя рекомендоваться также задавать имя пакет в нижний регистр так они можно легко отличить от имя класс сокрытие реализация ещё один аспект инкапсуляция – разделение интерфейс и реализация если интерфейс доступный для внешний часть программа внешний по отношение к модуль или класс то реализация скрытый в литература часто проводить аналогия с чёрный ящик когда снаружи «не видный внутренний реализация но «видный то что подаваться на вход ящик и что он выдавать на выход в язык c сокрытие реализация выполнять внутри модуль помечать функция который не должный быть видный извне ключевой слово static прототип функция который составлять интерфейс модуль выноситься в заголовочный файл под модуль в язык c пониматься пара файл с исходный код с расширение *c и заголовочный с расширение *h в java также есть ключевой слово static но оно не влиять на «видимость метод или поль извне для управление «видимость предназначить 3 модификатор доступ private protected public поль и метод класс пометить как private доступный только внутри он самый поль и метод protected доступный также наследник класс модификатор public означать что пометить элемент доступный извне класс то есть являться частью интерфейс также возможно отсутствие модификатор в это случай доступ к элемент класс ограниченный пакет в который данный класс находиться рекомендовать в процесс написание класс изначально помечать весь поль класс как private и расширять право доступ по мера возникновение необходимость перегрузка метод один из раздражать черта стандартный библиотека c являться наличие целое зоопарк функция выполнять по суть один и тоже но различаться тип аргумент например fabs fabsf fabsl – функция для получение абсолютный значение для double float и long double тип соответственно java а также с++ поддерживать механизм перегрузка метод – внутри класс мочь быть несколько метод с полностью идентичный имя но различаться между себя тип и количество аргумент по количество аргумент и они тип компилятор сам выбрать нужный версия метод – очень удобно и улучшать читаемость программа в java в отличие от c++ нельзя перегружать оператор исключение составлять оператор «+ и «+= который изначально перегрузить для строка string символ и строка в java в язык c приходиться работать с нуль-терминальный строка представить указатель на один символ char *str // строка ascii символ wchart *strw // строка из "широких" символ такой строка обязать завершаться нулевой символ если он случайно «затереть то строка быть считаться последовательность байт в память до первое нулевой символ то есть если в память после строка размещаться другой переменный программа то после модификация такой повредить строка они значение мочь быть и скорее всего быть исказить конечно же c-программист не обязать использовать классический нуль-терминальный строка а применить сторонний реализация но тут надо иметь ввиду что весь функция из стандартный библиотека требовать в качество свой аргумент именно нуль-терминальный строка кроме это стандарт c не определять использовать кодировка этот момент также должный контролировать программист в java примитивный тип char а также «обёртка character о «обёртка – ниже представлять один символ согласно стандарт unicode использоваться кодировка utf-16 соответственно один символ занимать в память 2 байт что позволять закодировать практически весь символ использовать в настоящее время язык символ можно задавать по они unicode char ch1 = '\u20bd' если unicode символ превышать максимальный 216 для тип char то такой символ должный быть представить тип int в строка же он быть занимать 2 символ по 16 битый но опять-таки символ с код превышать 216 использоваться крайне редко строка java реализовать встроить класс string и хранить 16-битный символ char в класс string собрать весь или почти весь что мочь потребоваться для работа с строка здесь не надо думать о тот что строка должный обязательно заканчиваться нуль здесь невозможно незаметно «затереть этот нулевой завершать символ или обратиться к память за предел строка и вообще работать с строка в java программист не задумываться о тот в какой вид строка храниться в память как говориться выше java не допускать перегрузка оператор как в с++ однако класс string являться исключение – только для он изначально перегрузить оператор слияние строка «+ и «+= string str1 = "hello " + "world" string str2 = "hello " str2 += "world" примечательно что строка в java неизменный – быть один раз создать они не допускать свой изменение когда мы пытаться поменять строка например так string str = "hello world" strtouppercase systemoutprintlnstr // быть вывести "hello world" tо исходный строка на самый дело не меняться вместо это создаваться изменить копия исходный строка который в свой очередь так же являться неизменный string str = "hello world" string str2 = strtouppercase systemoutprintlnstr2 // быть вывести "hello world" такой образ каждый изменение строка в реальность оборачиваться создание новое объект на самый дело в случай слияние строка компилятор мочь оптимизировать код и использовать класс stringbuilder о который быть рассказать поздний бывать что в программа необходимый часто изменять один и тот же строка в такой случай в цель оптимизация быстродействие программа и потребление память можно предотвратить создание новый объект-строка для этот цель следовать использовать класс stringbuilder string sourcestring = "hello world" stringbuilder builder = new stringbuildersourcestring buildersetcharat4 '0' buildersetcharat8 '0' builderappend"" string changedstring = buildertostring systemoutprintlnchangedstring // быть вывести "hell0 w0rld" отдельно стоить сказать о сравнение строка типичный ошибка начинающий java-программист это сравнение строка с помощь оператор «== // если пользователь ввести "yes" // ошибка if usersinput == "yes" { // если строка равный } такой код формально не содержимый ошибка на стадия компиляция или ошибка время выполнение но работать он иначе чем это можно быть бы ожидать так как весь объект и строка в тот число в java представить ссылка то сравнение оператор «== давать сравнение ссылка а не значение объект то есть результат быть true только если 2 ссылка действительно ссылаться на один и тот же строка если же строка – разный объект в память и необходимый сравнить они содержимое то надо использовать метод equals if usersinputequals"yes" { // строка действительно равный } самый удивительный что в некоторый случай сравнение с помощь оператор «== работать правильно string somestring = "abc" anotherstring = "abc" // быть вывести "true" systemoutprintlnsomestring == anotherstring так происходить из-за тот что в действительность ссылка somestring и anotherstring указывать на один и тот же объект в память компилятор помещать одинаковый строковый литерал в пул строка – происходить так называть интернирование тогда каждый раз когда в программа появляться такой же строковый литерал использоваться ссылка на строка из пул интернирование строка как раз-таки и возможно благодаря свойство неизменность строка хотя сравнение содержимое строка допускаться только метод equals в java есть возможность корректно использовать строка в switch-case конструкция начинать с версия java 7 string str = new string //  switch str { case "stringvalue1" //  break case "stringvalue2" //  break } любопытно что люба объект java можно преобразовать в строка соответствующий метод tostring определить в базовый для весь класс класс object подход к обработка ошибка программировать на c вы мочь встречать следующий подход к обработка ошибка каждый функция какой-либо библиотека возвращать тип int если функция выполнить успешно то этот результат равный 0 если же результат отличный от нуль – это свидетельствовать о ошибка чаща всего код ошибка передавать через возвращать функция значение так как функция мочь вернуть лишь один значение и оно уже занятый код ошибка то действительный результат функция приходиться возвращать через аргумент в вид указатель например так int functionstruct data **result const char *arg { int errorcode /*  */ return errorcode } кстати это один из случай когда в программа на c возникать необходимость в использование указатель на указатель иногда использовать другой подход функция возвращать не код ошибка а непосредственно результат свой выполнение обычно в вид указатель ошибочный ситуация индицироваться при это нулевой указатель тогда библиотека обычно содержимый отдельный функция который возвращать код последний ошибка struct data* functionconst char *arg int getlasterror так или иначе при программирование на c код выполнять «полезный работа и код отвечать за обработка ошибка перемежать друг друг что явно не делать программа легко читаемый в java при желание можно использовать подход описать выше однако здесь можно применить совершенно иной способ работа с ошибка – обработка исключение впрочем как и в c++ преимущество обработка исключение состоять в тот что в это случай «полезный код и код отвечать за обработка ошибка и нештатный ситуация логически отделить друг от друг достигаться это с помощь конструкция try-catch в секция try размещаться «полезный код а в секция catch – код обработка ошибка // при открытие файл мочь возникнуть ошибка try filereader reader = new filereader"path\\to\\filetxt" { // при чтение файл - также возможный ошибка while readerread = -1{ //  } } catch ioexception ex { // весь ошибка обрабатываться здесь } бывать ситуация когда правильно обработать ошибка в место она возникновение не представляться возможный в такой случай в сигнатура метод помещать указание что метод мочь вызывать данный вид исключение public void func throws exception { //  } теперь вызов данный метод должный обязательно быть обрамить в блок try-catch или вызывающий метод также должный быть пометить что он мочь вызывать это исключение отсутствие препроцессор как бы ни быть удобный знакомый c/c++-программист препроцессор в язык java он отсутствовать разработчик java вероятно решить что он использоваться только для обеспечение переносимость программа а так как java выполняться везде почти то и препроцессор в она не нужный компенсировать отсутствие препроцессор можно использование статический поль-флаг и проверять он значение в программа где это необходимый если же речь идти о организация тестирование то здесь возможно применение аннотация в совокупность с отражение рефлексия массив – это тоже объект при работа с массив на c выход индекс за граница массив представлять себя очень коварный ошибка компилятор ни кой образ не сообщить о она а в время выполнение программа не быть остановить с соответствующий сообщение int array[5] array[6] = 666 скорее всего программа продолжить выполнение но значение переменный который располагаться следом за массив array в пример выше оказаться искажённый отладка подобный род ошибка мочь оказаться не простой дело в язык java программист защитить от подобный род труднодиагностировать ошибка при попытка выйти за граница массив возбуждаться исключение arrayindexoutofboundsexception если не быть запрограммировать перехват исключение с помощь конструкция try-catch программа аварийный завершаться а в стандартный поток ошибка отправляться соответствующий сообщение с указание файл с исходный код и номер строка где произойти выход за граница массив то есть диагностика подобный ошибка становиться тривиальный дело такой поведение java-программа стать возможный благодаря тот что массив в java представить объект массив java не мочь менять размер он размер жёстко задаваться в момент выделение память в время выполнение же получить размер массив простой простой int[] array = new int[10] int arraysize = arraylength // 10 если говорить о многомерный массив то по сравнение с язык c в java открываться интересный возможность организовать «лестничный массив для случай двумерный массив размер каждый отдельный строка мочь отличаться от остальной int[][] array = new int[10][] for int i = 0 i < arraylength i++ { array[i] = new int[i + 1] } как и в c элемент массив располагаться в память один за другой поэтому доступ к массив считаться самый эффективный если же требоваться выполнять операция вставки/удаление элемент или создавать более сложный структура дать то необходимый использовать коллекция такой как множество set список list карта map за отсутствие указатель и невозможность инкрементировать ссылка доступ к элемент массив возможный с помощь индекс коллекция зачастую функциональность массив оказываться недостаточно – тогда необходимый использовать динамический структура дать так как стандартный библиотека c не содержимый готовый реализация динамический структура дать то приходиться пользоваться реализация в исходный код или в вид библиотека в отличие от c стандартный библиотека java содержимый богатый набор реализация динамический структура дать или коллекция выражаться термин java весь коллекция делиться на 3 больший класс список множество и карта список – динамический массив – позволять добавлять/удалять элемент множество не обеспечивать порядок добавить элемент но гарантировать отсутствие дубликат элемент карта или ассоциативный массив оперировать пара «ключ – значение причём значение ключ уникально – в карта не мочь быть 2 пара с одинаковый ключ для список множество и карта существовать множество реализация каждый из который оптимизировать для определённый операция например список реализовать класс arraylist и linkedlist причём arraylist обеспечивать хороший производительность при доступ к произвольный элемент а linkedlist – более эффективный при вставке/удаление элемент в середина список в коллекция мочь храниться только полноценный java-объект фактически – ссылка на объект поэтому создать непосредственно коллекция примитив int char byte и др нельзя в это случай следовать использовать соответствующий класс-«обёртка примитив класс-«обёртка byte byte short short char character int integer long long float float double double boolean boolean к счастие программировать на java нет необходимость следить за точный совпадение примитивный тип и он «обёртка если метод получать аргумент например тип integer то он можно передавать тип int и наоборот где требоваться тип int сметь можно использовать integer это стать возможный благодаря наличие в java встроить механизм упаковки/распаковка примитив из неприятный момент следовать упомянуть что стандартный библиотека java содержимый старое класс коллекция который быть неудачно реализовать в один версия java и который не следовать использовать в новый программа речь идти о класс enumeration vector stack dictionary hashtable properties обобщение коллекция обычно использовать как обобщённый тип дать быть обобщение в это случай заключаться в тот что мы задавать основной тип коллекция например arraylist а в угловой скобка указывать тип-параметр который в дать случай определять тип хранить в список элемент list<integer> list = new arraylist<integer> это позволять компилятор отследить попытка добавление в такой список объект иной тип нежели указанный тип-параметр list<integer> list = new arraylist<integer> // ошибка компиляция listadd"first" очень важный что в время выполнение программа тип-параметр стираться и нет никакой разница между например объект класс arraylist<integer> и объект класс arraylist<string>как следствие нет возможность узнать тип элемент коллекция в время выполнение программа public boolean containsintegerlist list { // ошибка компиляция if list instanceof list<integer> { return true } return false } частичный решение мочь быть следующий подход брать один элемент коллекция и определять он тип public boolean containsintegerlist list { if listisempty && listget0 instanceof integer { return true } return false } но такой подход не сработать если список пустой в это план обобщение java значительно уступать обобщение c++ обобщение java фактически служить для «отсечение часть потенциальный ошибка на стадия компиляция перебор весь элемент массив или коллекция программировать на с часто приходиться перебирать весь элемент массив for int i = 0 i < size i++ { /*  */ } ошибиться здесь простой простой достаточно указать неверный размер массив size или поставить «<= вместо «< в java помимо «обычный форма оператор for существовать форма для перебор весь элемент массив или коллекция в другой язык часто называть foreach list<integer> list = new arraylist<> //  for integer i  list { //  } здесь мы гарантировать перебрать весь элемент список исключить ошибка присущий «обычный форма оператор for коллекция разнородный элемент так как весь объект наследоваться от коренной object то в java есть интересный возможность создавать список с различный фактический тип элемент list list = new arraylist<> listaddnew string"first" listaddnew integer2 listaddnew double30 узнать фактический тип элемент список можно использовать оператор instanceof for object o  list { if o instanceof string { //  } else if o instanceof integer { //  } else if o instanceof double { //  } } перечисление сравнивать c/c++ и java невозможно не заметить насколько функциональный в java реализовать перечисление здесь перечисление – это полноценный класс а элемент перечисление – объект это класс это позволять один элемент перечисление задать в соответствие несколько полый любой тип enum colors { // объявление каждый элемент перечисление - это вызов конструктор red byte0xff byte0x00 byte0x00 green byte0x00 byte0xff byte0x00 blue byte0x00 byte0x00 byte0xff white byte0xff byte0xff byte0xff black byte0x00 byte0x00 byte0x00 // поль перечисление private byte r g b // приватный конструктор private colorsbyte r byte g byte b { thisr = r thisg = g thisb = b } // метод перечисление public double getluma { return 02126 * r + 07152 * g + 00722 * b } } как полноценный класс перечисление мочь иметь метод а с помощь приватный конструктор можно задавать значение полый отдельный элемент перечисление штатный присутствовать возможность получить строковый представление элемент перечисление порядковый номер а также массив весь элемент colors color = colorsblack string str = colortostring // "black" int i = colorordinal // 4 colors[] array = colorsvalues // [red green blue white black] и наоборот – по строковый представление можно получить элемент перечисление а также вызывать он метод colors red = colorsvalueof"red" // colorsred double redluma = redgetluma // 02126 * 255 естественно перечисление можно использовать в конструкция switch-case вывод безусловно язык c и java предназначить для решение совершенно разный задача но если всё-таки сравнить процесс разработка по на этот два язык то по субъективный впечатление автор язык java значительно превосходить c по удобство и скорость написание программа немалый роль в обеспечение удобство играть среда разработка ide автор работать с ide intellij idea программировать на java не приходиться постоянно «бояться допустить ошибка – зачастую среда разработка подсказать что надо исправить а иногда сделать это за вы если же возникнуть ошибка время выполнение то в лог всегда указанный тип ошибка и место она возникновение в исходный код – борьба с такой ошибка становиться тривиальный дело секунда-программист для переход на java не надо прилагать нечеловеческий усилие и весь благодаря тот что синтаксис язык измениться незначительно если этот опыт быть интересный читатель в следующий статья мы рассказать о опыт использование механизм jni запуск нативный c/c++-код из java-приложение механизм jni незаменимый когда требоваться управлять разрешение экран bluetooth-модуль и в другой случай когда возможность сервис и менеджер android оказываться недостаточно 
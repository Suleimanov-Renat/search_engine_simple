корректный получение доступ к default метод интерфейс через рефлексия в java 8 9 10 примечание переводчик развитие фреймворка cuba порождать большой количество r&d проект в ход один такой проект выясниться что мы нужно вызывать default метод интерфейс из проксить класс наткнуться на очень полезный статья я кажется что опыт изложить в она быть как минимум интересный как максимум — полезный широкий круг разработчик когда дело касаться доступ к default метод интерфейс в java через рефлексия гугление не очень помогать например решение на stackoverflow работать только в определённый ситуация и не на весь версия java в этот статья быть рассмотреть различный подход к вызов default метод интерфейс через рефлексия это мочь быть нужно например при создание прокси-класс tldr если вы не терпеться то весь способ вызов default метод описать в этот статья доступный по этот ссылка а также этот проблема уже решить в наш библиотека joor проксирование интерфейс с default метод полезный api javalangreflectproxy существовать достаточно давно с он помощь мы мочь делать клевый штука например import javalangreflectproxy public class proxydemo { interface duck { void quack } public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { systemoutprintln"quack" return null }  duckquack } } этот код просто выводить quack в это пример мы создать экземпляр проксить который реализовать api интерфейс duck с использование invocationhandler который по суть просто лямбда вызывать для каждый метод интерфейс duck интересный начаться когда мы захотеть добавить реализация метод в интерфейс и делегировать вызов в этот метод interface duck { default void quack { systemoutprintln"quack" } } скорее всего захотеться написать такой код import javalangreflectproxy public class proxydemo { interface duck { default void quack { systemoutprintln"quack" } } public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { methodinvokeproxy return null }  duckquack } } но это всего лишь сгенерировать длиннющий стек вложить исключение и это не связать с вызов реализация метод в интерфейс так просто запретить делать exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quackunknown source at proxydemomainproxydemojava20 caused by javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0native method at sunreflectnativemethodaccessorimplinvokenativemethodaccessorimpljava62 at sunreflectdelegatingmethodaccessorimplinvokedelegatingmethodaccessorimpljava43 at javalangreflectmethodinvokemethodjava498 at proxydemolambda$0proxydemojava15  2 more caused by javalangreflectundeclaredthrowableexception at $proxy0quackunknown source  7 more caused by javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0native method at sunreflectnativemethodaccessorimplinvokenativemethodaccessorimpljava62 at sunreflectdelegatingmethodaccessorimplinvokedelegatingmethodaccessorimpljava43 at javalangreflectmethodinvokemethodjava498 at proxydemolambda$0proxydemojava15  8 more caused by javalangreflectundeclaredthrowableexception at $proxy0quackunknown source  13 more caused by javalangreflectinvocationtargetexception at sunreflectnativemethodaccessorimplinvoke0native method at sunreflectnativemethodaccessorimplinvokenativemethodaccessorimpljava62 at sunreflectdelegatingmethodaccessorimplinvokedelegatingmethodaccessorimpljava43 at javalangreflectmethodinvokemethodjava498 at proxydemolambda$0proxydemojava15  14 more caused by javalangreflectundeclaredthrowableexception at $proxy0quackunknown source  19 more    goes on forever не очень-то полезно использование method handles api так поиск в гугл выдавать мы что нужно использовать methodhandles api ну что давать попробовать import javalanginvokemethodhandles import javalangreflectproxy public class proxydemo { interface duck { default void quack { systemoutprintln"quack" } } public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { methodhandles lookup induckclass unreflectspecialmethod duckclass bindtoproxy invokewitharguments return null }  duckquack } } круто похоже что заработать quack … но нет вызов метод интерфейс с не приватный доступ интерфейс из пример выше быть аккуратно сделать так чтобы у вызывающий код к он быть приватный доступ тот интерфейс быть вложить в вызывающий класс а что если у мы есть не вложить интерфейс import javalanginvokemethodhandles import javalangreflectproxy interface duck { default void quack { systemoutprintln"quack" } } public class proxydemo { public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { methodhandles lookup induckclass unreflectspecialmethod duckclass bindtoproxy invokewitharguments return null }  duckquack } } почти такой же код большой не работать получать исключение illegalaccessexception exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quackunknown source at proxydemomainproxydemojava26 caused by javalangillegalaccessexception no private access for invokespecial interface duck from duck/package at javalanginvokemembernamemakeaccessexceptionmembernamejava850 at javalanginvokemethodhandles$lookupcheckspecialcallermethodhandlesjava1572 at javalanginvokemethodhandles$lookupunreflectspecialmethodhandlesjava1231 at proxydemolambda$0proxydemojava19  2 more фигня выйти если погуглить ещё можно найти следующий решение который получать доступ к внутренность methodhandleslookup через рефлексия import javalanginvokemethodhandleslookup import javalangreflectconstructor import javalangreflectproxy interface duck { default void quack { systemoutprintln"quack" } } public class proxydemo { public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { constructor<lookup> constructor = lookupclass getdeclaredconstructorclassclass constructorsetaccessibletrue constructornewinstanceduckclass induckclass unreflectspecialmethod duckclass bindtoproxy invokewitharguments return null }  duckquack } } и ура мы получать quack у мы получиться сделать это на jdk 8 как насчёт jdk 9 или 10 warning an illegal reflective access operation has occurred warning illegal reflective access by proxydemo file/c/users/lukas/workspace/playground/target/classes/ to constructor javalanginvokemethodhandles$lookupjavalangclass warning please consider reporting this to the maintainers of proxydemo warning use --illegal-access=warn to enable warnings of further illegal reflective access operations warning all illegal access operations will be denied in a future release quack опачка это то что происходить по умолчание если мы запустить программа с флаг --illegal-access=deny java --illegal-access=deny proxydemo ну тогда мы получать и правильно exception in thread "main" javalangreflectinaccessibleobjectexception unable to make javalanginvokemethodhandles$lookupjavalangclass accessible module javabase does not "opens javalanginvoke" to unnamed module @357246de at javabase/javalangreflectaccessibleobjectcheckcansetaccessibleaccessibleobjectjava337 at javabase/javalangreflectaccessibleobjectcheckcansetaccessibleaccessibleobjectjava281 at javabase/javalangreflectconstructorcheckcansetaccessibleconstructorjava192 at javabase/javalangreflectconstructorsetaccessibleconstructorjava185 at proxydemolambda$0proxydemojava18 at $proxy0quackunknown source at proxydemomainproxydemojava28 один из цель проект jigsaw быть как раз именно в тот чтобы не допускать подобный хаковы так а какой решение хороший это import javalanginvokemethodhandles import javalanginvokemethodtype import javalangreflectproxy interface duck { default void quack { systemoutprintln"quack" } } public class proxydemo { public static void mainstring[] a { duck duck = duck proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { duckclass } proxy method args -> { methodhandleslookup findspecial duckclass "quack" methodtypemethodtype voidclass new class[0] duckclass bindtoproxy invokewitharguments return null }  duckquack } } quack отлично это работать в java 9 и 10 а как насчёт java 8 exception in thread "main" javalangreflectundeclaredthrowableexception at $proxy0quackunknown source at proxydemomainproxydemojava25 caused by javalangillegalaccessexception no private access for invokespecial interface duck from proxydemo at javalanginvokemembernamemakeaccessexceptionmembernamejava850 at javalanginvokemethodhandles$lookupcheckspecialcallermethodhandlesjava1572 at javalanginvokemethodhandles$lookupfindspecialmethodhandlesjava1002 at proxydemolambda$0proxydemojava18  2 more вы издеваться да итак у мы есть решение хак который работать в java 8 но не в 9 и 10 и есть решение который работать в 9 и 10 но не в 8 более глубокий исследование ну что я только что попробовать запустить разный код на разный jdk следующий класс пробовать весь вышеперечисленный комбинация он также доступный в вид gist здесь компилировать код с использование jdk 9 или 10 потому что требоваться jdk 9+ api methodhandlesprivatelookupin но компилировать нужно команда указанный ниже чтобы можно быть запустить класс на jdk 8 javac -source 18 -target 18 calldefaultmethodthroughreflectionjava import javalanginvokemethodhandles import javalanginvokemethodhandleslookup import javalanginvokemethodtype import javalangreflectconstructor import javalangreflectmethod import javalangreflectproxy interface privateinaccessible { default void quack { systemoutprintln" -> privateinaccessiblequack" } } public class calldefaultmethodthroughreflection { interface privateaccessible { default void quack { systemoutprintln" -> privateaccessiblequack" } } public static void mainstring[] args { systemoutprintln"privateaccessible" systemoutprintln"-----------------" systemoutprintln proxyprivateaccessibleclassquack systemoutprintln systemoutprintln"privateinaccessible" systemoutprintln"-------------------" systemoutprintln proxyprivateinaccessibleclassquack } private static void quacklookup lookup class<> type object proxy { systemoutprintln"lookupintypeunreflectspecial" try { lookupintype unreflectspecialtypegetmethod"quack" type bindtoproxy invokewitharguments } catch throwable e { systemoutprintln" -> " + egetclass + " " + egetmessage } systemoutprintln"lookupfindspecial" try { lookupfindspecialtype "quack" methodtypemethodtypevoidclass new class[0] type bindtoproxy invokewitharguments } catch throwable e { systemoutprintln" -> " + egetclass + " " + egetmessage } } @suppresswarnings"unchecked" private static <t> t proxyclass<t> type { return t proxynewproxyinstance threadcurrentthreadgetcontextclassloader new class[] { type } object proxy method method object[] arguments -> { systemoutprintln"methodhandleslookup" quackmethodhandleslookup type proxy try { systemoutprintln systemoutprintln"lookupclass" constructor<lookup> constructor = lookupclassgetdeclaredconstructorclassclass constructorsetaccessibletrue constructornewinstancetype quackconstructornewinstancetype type proxy } catch exception e { systemoutprintln" -> " + egetclass + " " + egetmessage } try { systemoutprintln systemoutprintln"methodhandlesprivatelookupin" quackmethodhandlesprivatelookupintype methodhandleslookup type proxy } catch error e { systemoutprintln" -> " + egetclass + " " + egetmessage } return null }  } } вывод вышеприведённый программа java 8 $ java -version java version "180141" javatm se runtime environment build 180141-b15 java hotspottm 64-bit server vm build 25141-b15 mixed mode $ java calldefaultmethodthroughreflection privateaccessible ----------------- methodhandleslookup lookupintypeunreflectspecial -> privateaccessiblequack lookupfindspecial -> class javalangillegalaccessexception no private access for invokespecial interface calldefaultmethodthroughreflection$privateaccessible from calldefaultmethodthroughreflection lookupclass lookupintypeunreflectspecial -> privateaccessiblequack lookupfindspecial -> privateaccessiblequack methodhandlesprivatelookupin -> class javalangnosuchmethoderror javalanginvokemethodhandlesprivatelookupinljava/lang/classljava/lang/invoke/methodhandles$lookupljava/lang/invoke/methodhandles$lookup privateinaccessible ------------------- methodhandleslookup lookupintypeunreflectspecial -> class javalangillegalaccessexception no private access for invokespecial interface privateinaccessible from privateinaccessible/package lookupfindspecial -> class javalangillegalaccessexception no private access for invokespecial interface privateinaccessible from calldefaultmethodthroughreflection lookupclass lookupintypeunreflectspecial -> privateinaccessiblequack lookupfindspecial -> privateinaccessiblequack methodhandlesprivatelookupin -> class javalangnosuchmethoderror javalanginvokemethodhandlesprivatelookupinljava/lang/classljava/lang/invoke/methodhandles$lookupljava/lang/invoke/methodhandles$lookup java 9 $ java -version java version "904" javatm se runtime environment build 904+11 java hotspottm 64-bit server vm build 904+11 mixed mode $ java --illegal-access=deny calldefaultmethodthroughreflection privateaccessible ----------------- methodhandleslookup lookupintypeunreflectspecial -> privateaccessiblequack lookupfindspecial -> privateaccessiblequack lookupclass -> class javalangreflectinaccessibleobjectexception unable to make javalanginvokemethodhandles$lookupjavalangclass accessible module javabase does not "opens javalanginvoke" to unnamed module @30c7da1e methodhandlesprivatelookupin lookupintypeunreflectspecial -> privateaccessiblequack lookupfindspecial -> privateaccessiblequack privateinaccessible ------------------- methodhandleslookup lookupintypeunreflectspecial -> class javalangillegalaccessexception no private access for invokespecial interface privateinaccessible from privateinaccessible/package unnamed module @30c7da1e lookupfindspecial -> privateinaccessiblequack lookupclass -> class javalangreflectinaccessibleobjectexception unable to make javalanginvokemethodhandles$lookupjavalangclass accessible module javabase does not "opens javalanginvoke" to unnamed module @30c7da1e methodhandlesprivatelookupin lookupintypeunreflectspecial -> privateinaccessiblequack lookupfindspecial -> privateinaccessiblequack java 10 $ java -version java version "10" 2018-03-20 javatm se runtime environment 183 build 10+46 java hotspottm 64-bit server vm 183 build 10+46 mixed mode $ java --illegal-access=deny calldefaultmethodthroughreflection  такой же результат как в java 9 заключение понять весь это немного сложноватый в java 8 хороший рабочий подход – хак который влезать в внутренность jdk через доступ к package-private конструктор класс lookup это единственный способ единообразный вызывать метод интерфейс как с приватный доступ так и с не приватный доступ из любой класс в java 9 и 10 хороший способ — использовать lookupfindspecial не работать в java 8 или methodhandlesprivatelookupin метод не существовать в java 8 последний подход нужно использовать если интерфейс находиться в друг модула этот модуль должный предоставлять интерфейс для вызов извне честно сказать это немного запутанно подходящий мем для это rafael winterhalter автор bytebuddy сказать что настоящий” фикс быть в переработать версия proxy api переводlukas eder «ты не знаешь причина тот почему решить большой не разрешать так делать или просто пропустить это скорее всего нет rafael winterhalter«нуть причина это побочный эффект модель безопасность java для класс lookup из methodhandle в идеал в проксить интерфейс должный быть такой lookup предоставлять в вид аргумент конструктор — прима переть но это не рассмотреть я безуспешно предлагать похожий расширение для api трансформация файл класс я не уверенный что это решить весь проблема но нужно действительно сделать так чтобы разработчик не беспокоиться о весь вышесказанный и ясно что этот статья не полный например не тестироваться быть ли этот подход работать если duck импортировать из другой модуль переводjooqназвание и ссылка на статья rafael winterhalter« ты пробовать поместить duck в модуль который экспортировать но не открывать пакет интерфейс готовый поспорить что твой решение для java 9+ не заработать если быть использоваться module path … и это быть тема следующий статья использование joor если вы использовать joor наш библиотека для reflection api она тут то версия 098 быть включать фикс для это githubcom/jooq/joor/issues/49 фикс просто использовать подход с хаком reflection api в java 8 или methodhandlesprivatelookupin для java 9+ можно писать reflectonnew objectasprivateaccessibleclassquack reflectonnew objectasprivateinaccessibleclassquack 
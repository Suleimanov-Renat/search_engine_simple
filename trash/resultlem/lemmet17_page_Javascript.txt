javascript ооп прототип замыкание «класс timerjs здравствовать программист начинающий закончить а также весь сочувствовать как известно ничто не познаваться так хорошо как на собственный опыт главный чтобы опыт быть полезный и в продолжение этот простой мысль я хотеть предложить заняться несколько полезный дело сразу побеседовать на тема «ооп с человеческий лицо разобраться с прототип в javascript коротко и сердито вспомнить что «замыкание это не только ценный мех… удар ток написать на javascript класс timer — этакий планировщик событие для запуск анимация событие любой функция весело провести время предупреждение если вы не ждать от статья ничто веселого… то ошибаться человек с пониженный чувство юмор читать… ещё более рекомендоваться ну-с приступим… заметить что на момент написание статья  привет апокалиптично-гламурный 2012 настоящий ооп в javascript нет но есть приём который можно реализовать основной принцип объектный ориентировать программирование для тот кто только открывать для себя этот безумно интересный тема я свой слово пояснить характерность данный метод часть 1 ооп с человеческий лицо кратенько ооп это вовсе не священный мантра а по суть просто методика организация приложение структурирование код централизация метод и объединение сущность в единый иерархический семейство подобно тот как строиться субмарина и самолёт перенимать опыт плавучесть и летучесть из живой природа ооп приложение также использовать восприятие программный сущность как некий «живой объект перенимать известный мы из реальногоoffline — помнить о такой мир характеристика и свойство другой слово создаваться некий сущность который не только иметь свой свойство и метод но уметь порождать потомок и эволюционировать это называться расширение – extending словно бережный родитель объект передавать имущество по наследство либо получать опыт поколение быть потомок другой родительский сущность – parent такой образ создаваться единый древо поколение в который удобно ориентироваться и массово управлять в отличие от разрозненный библиотека — процедурный метод как видеть — весь как у человек с тот разница что разработчик являть себя бог этот система и мочь переноситься по поколение вносить изменение в самый корн либо в отдельный ветвь развитие война и конфликт устранять новое знание — добавлять или наоборот весь ломаем… трудно быть бог однако сам принцип ооп обязывать разработчик структурировать приложение по правило а не как приспичить что облегчать и систематизировать он поддержка и что впрочем вовсе не мешать при желание запутать код даже в это случае…  на мой взгляд освоение ооп очень помогать именно такой «человеческий восприятие принцип например как и в жизнь существовать строгий родитель который заставлять ребёнок уметь что-либо что сам считать нужный они называть абстрактный класс — abstract помнить как родитель заставлять вы играть на фортепиано или учить стих так вот абстрактный класс также как и многие родитель вовсе и знать не знать зачем ребенку-потомок это быть нужно и как он это быть использовать но уверить что так надо тот такой класс содержимый абстрактный метод который являть себя объявление метод без самый реализация как фантик без конфетка тем самый обязывать потомок этот метод реализовать как и в жизнь где родитель нередко перекладывать на ребёнок свой нереализованный мечты… вот в такой шутливо-серьёзный форма мы затронуть тема абстрактный класс и семейный отношение как способ понять… и то и другой а если серьёзно то разумеется в программирование не должный быть случайный метод и любой метод и свойство являться частью продумать иерархия класс который как генеалогический дерево мочь давать возможность расширять функционал от поколение к поколение а абстрактный класс и ещё более абстрактный – интерфейс  interface — вообще не содержимый реализация  помогать программист не потерять не забыть реализовать общий необходимый для весь потомок умение в жизнь без который особь умереть а с она и приложение кроме шутка с практический сторона при проектирование элемент приложение такой как например товар в магазин объектный представление позволять приблизить они к свойство реальный объект который как и в жизнь инкапсулировать тот содержимый в себя весь необходимый аттрибут цена количество масса срок хранение и прочий необходимый качество но так как и товар мочь быть разный то они классовый модель мочь ветвиться и развиваться наследовать или переопределять общий свойство наследование — пожалуй важный особенность ооп если требоваться новый виток эволюция программист создавать новый класс расширять умение он родитель а иногда и реализовать по новый тот перекрывать метод родитель — override ведь у каждый поколение свой понятие в жизни… если же программист нужный «опыт и понятие прежний поколение — он обращаться к он ничто не потерять в этот структура поэтому крайне важный уметь она пользоваться и хотя пока для javascript нет полноценный ооп спецификация возможность следовать принцип ооп есть и это удобство мы сейчас быть пользоваться конечно в рамка дать статья мы лишь коснуться основа понимание но как известно – лихо беда начать главный зацепиться… итак наш цель сейчас написать некий управляемый сущность который по таймер быть запускать нужный мы процесс «управляемый – это значит такой сущность или условно класс быть заключать в себя – как говорят инкапсулировать метод для управление и свойство содержимый необходимый дать пример из жизнь  свойство – это то что объект знать имя цвета глаз таблица умножение   метод – это то что объект уметь спать есть строить синхрофазотрон  важный если читатель ещё не знать что из себя представлять объект в javascript — то рекомендовать предварительно почитать о это в любой справочник иначе быть возникать трудность понимание создание объект быть происходить через функция который вызываться с директива new именно директива new определять что функция этот не обычный вовсе а специальный функция – конструктор который создавать и возвращать некий объект до тот же как она он возвратить мы мочь это объект присвоить весь что душить пожелать и знание и умение function timer { /* тут быть кодить дальше… */ } var timer = new timer итак мы создать объект timer класс timer но как творческий человек мы мочь захотеть уже при создание наделить свой объект некоторый свойство или не наделять… тот мы хотеть универсальность чтобы при желание можно быть задать «знание и умение или нет но объект при это не умереть бы в мука не уметь например дышать… мы же не зверь но как это сделать для это первое что мы поместить в наш класс — свойство по умолчание который объект принимать бы от природа и блок обработка function timer options  { //public var defaultoptions = { delay 20 //время между вызов таймер в мс каждый вызов - новый кадр stopframe 0 // конечный кадр loop true // флаг цикличность процесс frameelementprefixid 'timer' // префикс аттрибут id элемент для подсветка-визуализация процесс } forvar option in defaultoptions this[option] = options && options[option]==undefined  options[option]  defaultoptions[option] /*тут быть кодить дальше… */ } также в сигнатура функция у мы появиться параметр options это объект вы ведь знаете что такой объект после комментарий //public у мы тоже объект defaultoptions который содержимый необходимый для жизнедеятельность свойство и за он блок код который перебирать весь свойство defaultoptions по имя проверять передать ли они через options и если нет — ставить значение из defaultoptions для присваивание объект значение мы пользоваться this который указывать на текущий создать внутри функция — конструктор помнить про new  такой образ мы мочь создать наш объект так var timer = new timer {delay 500 loop false }  … и указанный свойство быть записать а пропустить — взять из defaultoptions объект спасти универсальность и гибкость получить обратить внимание и на комментарий //public разумеется он иметь тут условный значение как и весь ооп условность в javascript включая понятие класс но быть он в пометка публичный свойство тот доступный из вне к такой свойство можно обратиться напрямую через объект alert timerdelay  как пример из жизнь это очевидный свойство объект который не нуждаться в сокрытие длина хвост у кот бывать также личный свойство — private и защитить — protected для доступ к личный если это позволительно вообще нужно использовать специальный метод в который программист определять что и как и кома можно возвращать защитить — protected это чуть менее личный тк доступный и для самый класс и для он наследник в круг «семья так сказать делаться это для стабильность приложение ведь не весь сор хороший выносить они избы… давать и мы добавить личный свойство — private делаться это создание внутренний переменный внутри функция такой образ область они видимость ограничиваться или иначе — замыкаться самый функция — «никома не сказать если не захотеть о замыкание мы ещё поговорим… а пока вставлять далёкий в функция timer //private var busy = false // флаг "занят" или "процесс идет" currenttime = 0 // текущий время frame = 1 // текущий кадр task = {} // о важный в этот объект быть помещать список задача для выполнение по кадр keyframes=[] // массив индекс ключевой кадр тот тот в который поместить задача  /*тут быть кодить дальше… */ к такой свойство если захотеть мы позволить обращаться через публичный метод как thisgetkeyframes = function  { return keyframes } обратить внимание что этот метод именно публичный тк через this присвоить свойство объект к который можно потом обратиться через точка не забыть про скобка на конец если вызывать именно действие  timergetkeyframes если же мы нужный приватный метод то он подобно приватный переменный также создаваться «обычный объявление внутренний функция function someprivatemethod { /* some code */ } получиться служебный функция который конструктор мочь вызвать для личный цель но из создать конструктор объект этот функция быть недоступный тк не являться он свойство повториться в javascript весь это условность который помогать следовать принцип ооп но не всегда обеспечивать точный реализация например с реализация protected в javascript совсем туго дело в тот что protected частично сочетать в себя свойство и private- для недоступность из объект и public- для доступ из другой класс что в javascript противоречить друг друг так как обеспечиваться область видимость — замыкание как вариант можно создать public метод и внутри он проверять являться ли вызывающий он объект наследник хозяин метод и тп идеальный решение тут нет весь в рамка условность ну вроде с организация доступ чуток разобраться а как насчёт наследование ведь это наиболее важный качество в ооп — способность перенимать и развивать умение и знание свой родитель и тут мы подходить к важный особенность javascript — прототипный наследование этот тема часто вызывать трудность понимание и далее я сделать свой попытка «объяснить весь раз и навсегда простой человечёкий язык часть 2 прототип в javascript итак в javascript существовать понятие прототип скрытый ссылка [[prototype]] объект она же proto и свойство prototype функция чтобы перестать путаться в этот понятие разобрать они по один прототип текущий объект называть некий другой объект из который текущий объект черпать недоставать метод и свойство скрытый ссылка [[prototype]] указывать на прототип текущий объект и по спецификация недоступный для разработка но в некоторый браузер нарущать спецификация она открытый как свойство объект proto что впрочем не давать смысл она пользоваться на прямая тк это не кроссбраузёрный и не корректно prototype — это свойство функция повторять именно функция который использовать для передача значение ссылка [[prototype]] создавать объект люба уважать себя javascript-объект иметь скрытый ссылка [[prototype]] который связывать он с родительский по замысел объект который в свой очередь с свой и тд наверху весь этот цепочка заседать встроить объект javascript этакий верховный прародитель объектный адам иметь весь необходимый встроить метод такой как tostring valueof hasownproperty и тд благодаря это весь объект потомок тоже иметь этот минимально необходимый набор метод позволять выжить в непростой среда javascript объектпотомок2--[[prototype]]--> объектпотомок1--[[prototype]]-->… { tostring  valueof  hasownproperty … } тот даже если просто создать пустой объект var obj = {} не иметь метод и свойство и обратиться к стандарный метод то по цепочка ссылка [[prototype]]  в дать случай минимально короткий цепочка  он взять этот метод из встроить объект javascript var obj = {} //пустой объект objtostring // вызывать метод и получать строка "[object object]" так реализоваться прототипный наследование в javascript — через цепочка ссылка [[prototype]] весь свойство доступный по цепочка прототип быть открытый потомок как кладезь знание и умение что позволять выстраивать настоящее эволюционировать древо класс обратить внимание что прототипный свойство каждый объект храниться не в немой самый а как бы в промежуточный звено цепочка прототип между текущий объект и встроить объект javascript «в начало время этот корнев объект требовать уважение и нарушать он покоить не совсем прилично поэтому для создание собственный прототипный свойство хороший создавать и встраивать в цепочка собственный же объект с ссылка [[prototype]] но как мы помнить [[prototype]] — ссылка закрытый как же мы выстроить свой цепочка не иметь к она доступ тут мы помогать уже знакомый функция-конструктор с ключевой слово new и свойство prototype который вполне себя открытый дело в тот что объект создавать через конструктор получать ссылка [[prototype]] с значение указанный в свойство prototype это конструктор изначально любой функция иметь в свой свойство prototype ссылка на почти пустой объектс единственный свойство constructor указывать обратно на сам функция самафункцияprototype --> { constructor --> самафункция } но мы мочь заменить свойство prototype передавать свой родительский класс тот создавать функция-конструктор мы просто присвоить в она свойство prototype ссылка на объект с нужный мы свойство и новый создавать объект получить ссылка [[prototype]] на этот объект с нужный мы свойство // функция конструктор "класса" var foo = function {} //передавать свойство prototype объект с свойство и метод fooprototype = { hi 'hello' sayhi function{ alert thishi  } } // создавать экземпляр "класса" var obj = new foo // вызывать метод наследовать из прототип objsayhi в пример выше скрытый ссылка [[prototype]] объект obj получать указатель на некий объект иметь свойство hi и метод sayhi такой образ объект obj наследовать это знание и умение для упрощение этот процедура придумать функция function extendchild parent { var f = function { } fprototype = parentprototype childprototype = new f childprototypeconstructor = child childsuperclass = parentprototype } пример она использование смотреть на javascriptru javascriptru/tutorial/object/inheritance#svoystvo-prototype-i-prototip она принимать в агрумент два функция-конструктор — потомок и родитель и делать то что мы уже затронуть создавать служебный функция для передача прототип записывать в она prototype-свойство prototype функция родитель передавать свойство prototype потомок промежуточный объект новое звено цепочка с ссылка [[prototype]] на prototype родитель записывать в constructor функция child вместо исходный конструктор служебный f  записывать в свойство superclass ссылка на родитель на случай возможность обращение к он конструктор и другой исходный метод если они быть переопределить в потомок мочь возникнуть вопрос зачем нужный один три строка почему бы сразу не сделать присвоение childprototype = parentprototype без всякий new f и дело с конец дело в тот что при такой присвоение не быть создать новое промежуточный звено в цепочка наследование в childprototype записаться parentprototype а не промежуточный объект -хранилище с дальнейший ссылка на parentprototype и при попытка записать что либо в childprototype мы грубо ворваться на территория parent нарушать уважение к старший и приемственность поколение вызывать конструктор new f мы создавать для child свой собственный область хранение прототипный знание который он смочь передать потомок добавлять отдельный свойство в прототип конструктор можно ещё и так childprototypesomeproperty = "someproperty" и кстати не нужно пытаться обращаться к prototype как к свойство объект — экземпляр класс у объект нет свойство prototype есть скрытый ссылка [[prototype]] а свойство prototype — нет он конечно можно создать но толк от он в наследование никакой толк есть только от свойство prototype функция-конструктор благодаря она способность передавать указатель в ссылка [[prototype]] создавать объект вот и весь что касаться прототипный наследование правда просто но прототипный наследование не единственно возможный схема хотеть упомянуть также и метод вызов конструктор суперкласс тот класс родитель не даром же мы позаботиться о он запись в свойство прототип  сантиметр function extend  в конструктор timer наш забытый пример мы присваивать объект некоторый свойство через this чтобы передать этот свойство последующий поколение надо в конструктор потомок сделать вызов родительский конструктор в контекст потомок тот function timerplayer { timerplayersuperclassconstructorapply this arguments  } здесь важный помнить что нельзя вызывать через thissuperclassconstructorapply а именно через имя текущий конструктор тут timerplayer потому что иначе если родительский конструктор тоже использовать this и вызывать thissuperclassconstructorapplythis arguments то это превратиться в замкнутый вызов apply в контекст this как потомок что вызвать ошибка вызов родительский конструктор в контекст потомок создать и присвоить потомок весь он свойство и метод причём приватный свойство родитель объявить через var а не через this мочь быть доступный только при наличие позволять они прочитать родительский публичный метод именно это путём мы и продолжать строить наш timer часть 3 javascript-класс timer и он наследие итак у мы уже есть класс что-то знающий но ничто не уметь так что пора добавить он умение что мы желать научить наш класс сделать что-то вроде плеер  start  pause  stop  rewind  settoframe и некоторый менее важный метод представимый что мы они уже написали… итак вставлять далёкий в функция timer thisstart = function{ /* старт */ if busy  return if windowconsole  consolelog 'start currenttime='+currenttime+' frame='+frame busy = true timercall this  } thispause = function { /* пауза */ if windowconsole  consolelog 'pause currenttime='+currenttime+' frame='+frame clearinterval thisintervalid  busy = false } thisstop = function { /* стоп */ if windowconsole  consolelog 'stop currenttime='+currenttime+' frame='+frame clearinterval thisintervalid  busy = false currenttime = 0 frame = 1 thisclearframeline } /* highlighting - визуализация таймер */ thisclearframeline = function { /* очистка линия кадр */ forvar i=1 str='' i<thisstopframe+1 i++ if elfr = documentgetelementbyid thisframeelementprefixid+i   removeclass elfr 'active' } thissetactiveframeelement = function framenumber { /* подсветка активный кадр */ if elfr = documentgetelementbyid thisframeelementprefixid+framenumber   addclasselfr 'active' } thistostring = function { /* строковый представление например для alert использовать для отладка */ var str = '' forvar option in this  str+= option+' '+ typeof this[option]=='function'  'function'  this[option] +'\n' return '{\n'+str+'}' } thissettask = function newtask  { /* присвоение расписание действие объект с список задача по кадр */ task = newtask thisstopframe = 0 keyframeslength = 0 forvar frind in task { if +thisstopframe< +frind  thisstopframe=+frind keyframespush +frind  } } thisgetkeyframes = function  { /* получить приватный свойство keyframes */ return keyframes } thisgettask = function { /* получить приватный свойство task */ return task } thissettoframe = function toframe  { /* установка в позиция кадр */ iftoframe>thisstopframe return frame=toframe currenttime=frame-1*thisdelay forvar frind in task { if +frind>+toframe  break var tasklist = task[ frind ] forvar i=0 i<tasklistlength i++ { var taskitem if taskitem = tasklist[i] taskitemrun } } thisclearframeline thissetactiveframeelement toframe  } thisrewind = function amount  { /* перемотка а какж у мы считать плеер получаться  */ if amount<0 && thisintervalid  amount--/* поправка на работа setinterval */ var toframe = frame+amount toframe = mathmax mathmin toframe thisstopframe 1 thissettoframetoframe } function timer{ /* приватный функция вызов setinterval который запускать задача из список */ var this = this /* сохранять ссылка на контекст наш объект в переменный */ thisintervalid = setinterval function { /* функция который вызывать setinterval через промежуток время thisdelay */ //consolelog 'currenttime='+currenttime+' frame='+frame+''+task if task[ frame ]  { /* проверять если ли задача для текущий кадр если есть */ var tasklist = task[ frame ] /*  забирать в задача-массив в переменный */ forvar i=0 i<tasklistlength i++ { /* и перебирать элемент массив - сам объект иметь свойство-функция run */ var taskitem if taskitem = tasklist[i]  taskitemrun /*  который мы и запускать */ } } /* highlighting */ thissetactiveframeelement frame  /* подсветка кадр */ currenttime+=thisdelay /* передвигать значение текущий время кадр */ frame++ if thisstopframe && frame>thisstopframe  { /* если stopframe не ноль и мы достигнуть он  */ if thisloop  thissettoframe 1  /* если стоить свойство - цикличность то переходить в начать на один кадр и продожать */ else thisstop /* а иначе стоп */ } } thisdelay  } весь с конструктор покончить в целое думать весь понятно нужный метод старт писать публичный метод старт где… thisstart = function{ if busy  return /* выходить если уже стартовать флаг стоить */ /* это для отладка вывод информация в консоль */ if windowconsole  consolelog 'start currenttime='+currenttime+' frame='+frame busy = true /* ставить флаг что стартовать */ timercall this  /* вызывать приватный метод */ } сам функция timer я подробно прокомментировать в целое идея простой function timer{ var this = this thisintervalid = setintervalfunction { /* тут весь и делать использовать this а не this */ } thisdelay  } сперва сохранять ссылка на контекст наш объект в переменный тк внутри функция вызывать в setinterval контекст быть потерянный а переменный остаться в замыкание тот в локальный область видимость возможно для понимание следовать повторитьить узнать про замыкание а мы о они ещё поговорить ниже… далее присваивать наш объект свойство intervalid который возвращаться метод setinterval этот идентификатор позволить мы останавливать выполнение setinterval при пауза или стоп смотреть этот метод отдельный разбор требовать свойство task ведь именно там мы в некий вид хранить задача для выполнение структура он такой { 1[ { run function{} } ] 5[ {}{}{} /**/ ] /**/ } объект массив объект ой хороший бы не говорить а то сам запутался… но весь просто в объект task под нужный номер кадр содержаться массив заданья-объект с свойство run это свойство надо присвоить функция который и вызваться при нужный кадр при необходимость каждый заданий-объект можно добавить ещё свойство на то он и объект также по надобность можно в массив добавлять новый объект-задание пользоваться стандартный метод массив push unshift splice ну и разумеется самый объект task можно присваивать свойство по номер нужный кадр такой образ заполнять task и присваивать наш класс метод settask мы определять что и когда он делать как это можно использовать выполнять различный динамический сценарий на сайт или на клиент оffline создавать анимация создавать «живой учебный пособие или тест завязать на время напоминать о важный событияхчайник вкипеть доставать пользователь всплывать реклама мерзкий и гадкий шутка или просто выводить часик в угол страница более тот у мы уже организоваться простой интерфейс некий маленький api для управление наш таймер и визуализация и сейчас мы он использовать построить панель управление на подобие плеер вставлять на страница html код любимый и родной <button onclick="timerrewind-50">rewind -50</button> <button onclick="timerstart">start</button> <button onclick="timerpause">pause</button> <button onclick="timerstop">stop</button> <button onclick="timerrewind+50">rewind +50</button> на событие onclick кнопочка повесить метод объект timer разумеется перед вызов который объект следовать не забыть создать помнить как — через функция конструктор var timer = new timer однако не плохо бы теперь и сценарий создать чем управлять а иначе — за что бороться попробовать создать простой анимация быть перемещать картинка по страница ну своеобразный «hello world в мир анимация перемещать быть картинка <img id="ball" src="http//wwwsmayliru/data/smiles/transporta-854gif" > напомнить что задача наш таймер вызывать действие какой мы угодный действие при это сам он за это действие не в ответ поэтому что именно делать — это наш задача и мы она сейчас решить написать простенький функция перемещение элемент который передаваться сам элемент по id и два он координата function moveelem elem top left { elemstylecsstext = 'positionrelativetop'+top+'pxleft'+left+'px' } итак теперь этот функция нужно присвоить свойство run объект-задание в массив под номер нужный кадр объект task следить за мысль итак создавать объект-сценарий и один он кадр определять как массив в этот кадр мы положим начальный положение элемент-картинка var frames = {} /* начальный положение */ frames[1]=[] frames[1]push { run function{ moveelem ball 600 600  } }  почему нельзя написать run moveelem ball 600 600  это неправильно потому что синтаксис… moveelem … означать вызов функция а мы она не надо вызывать тут и сейчас а надо поместить в тело свойство-функция run который вызов и сделать а иначе мы бы в run запихать результат выполнить moveelem — undefined поскольку она ничто не возвращать и картинка наш почём зря дёрнуть бы и вуаля первое кадр мы добавить действие который помещать наш картинкувоздушный шарик в некий нижний позиция страница теперь чтобы начать подниматься мы нужно покадровый изменять это состояние тот уменьшать координата top ну и left — с поправка на ветер  для заполнение нужный кадр использовать цикл при желание кстати можно написать собственный метод класс timer — который бы добавлять кадр и действие и распределять бы изменяться параметр действие по кадрам… а пока для пример заполнить цикл кадр с 2 по 600-ть /* действие */ forvar i=2 i<601 i++ frames[i] = [ { run functioni{ return function{ moveelem ball 600-i 600-i  } }i } ] здесь надо также обратить внимание на использование замыкание дело в тот что для передача динамический i тут использоваться обертывание в функциональный выражение который вызываться на место functioni{ /* сюда передаться текущий i как аргумент функция */ }i  если бы мы просто использовать run function{ moveelem ball 600-i 600-i  } то при вызов moveelem i бы браться из глобальный область видимость тот тот который у мы объявить и отработать в цикл forvar i=2 i<601 i++ тот вызываться бы «отработать переменный i равный 600 а вовсе не динамический i который должный постепенно нарастать изменять координата взлетать шарик поэтому мы использовать замыкание на javascript который определять область видимость тот при выполнение функция functioni{ /* сюда передаться текущий i как аргумент функция */ }i  … внутри он создаться свой переменный i как аргумент этот самый функция а вызов на место повторить если забыть  выполнять тело функция где происходить возврат  return  уже наш функция и опять же не return moveelem ball 600-i 600-i  а return function{ moveelem ball 600-i 600-i  } потому что в первое случай вернуться не вызов функция а результат вызов moveelem ball 600-i 600-i  который выполниться тут же и вот уже у мы есть сценарий теперь можно он присвоить и запустить var timer = new timer  timersettask frames  timerstart /* или кнопочка start */ в целое покадровый управление давать обширный возможность для создание интересный и сложный сценарий на дть страница denis-or-lovenarodru/portf/timer я также реализовать пример покадровый линейка наподобие timeline в adobe flash  — кнопочка drawframeline надо заметить что большой количество элемент на страница мочь сильно тормозить браузер при перерисовка они позиция это хорошо заметно в ненаглядный ie если нажать drawframeline с параметр 1 — каждый кадр при желание можно написать целый интерфейс для создание сценарий с расширять возможность и прочий приятность тут уж как говориться кто в что горазд… а теперь заняться наследование построить базовый класс timer мы расширить он создание более продвинуть класс timerplayer ограничить пример продвинутость простой пример — наш дочерний класс принимать навык родительский быть уметь создавать панель управление наш таймер наподобие плеер для это делать три вещий вызов родительский конструктор добавление новый метод передача наследование через функция extend //дочерний класс function timerplayer options  { // вызов родительский конструктор timerplayersuperclassconstructorapplythis arguments // новый метод thisdrawpanel = function panelid objname  { var objname = objname || 'timer' var template ='<button onclick="'+objname+'rewind-50">rewind -50</button>'+ '<button onclick="'+objname+'start">start</button>'+ '<button onclick="'+objname+'pause">pause</button>'+ '<button onclick="'+objname+'stop">stop</button>'+ '<button onclick="'+objname+'rewind+50">rewind +50</button>' documentgetelementbyid panelid innerhtml = template } } //вызов extend extendtimerplayer timer и хотя здесь у мы не происходить прототипный наследование extend мы нужный для выстраивание цепочка на будущее а вдруг захотеть добавить прототипный свойство родитель и для запись superclass и constructor новый метод drawpanel принимать строка id элемент внутри который помещать кнопочка и строка имя объект для подстановка в шаблон html //использовать дочерний класс var timerplayer = new timerplayer timerplayersettask frames2  timerplayerdrawpanel 'controlpanel' 'timerplayer'  вот мы и закончить а мочь только начать наш класс timer и он потомок я хотеть поблагодарить devote за терпеливый консультация и содействие в написание статья до новый встреча и приятный программирование 
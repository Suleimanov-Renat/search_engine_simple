как в java выстрелить себя в нога из лямбда и не промахнуться иногда можно услышать такой разговор никакой принципиальный изменение в java 8 не произойти и лямбда это старое добрый анонимный класс щедро посыпать синтаксический сахар как бы не так предлагать сегодня поговорить в что отличие лямбда от анонимный класс и почему попасть себя в нога стать всё-таки сложный чтобы не отнимать время у тот кто считать что уже освоиться с анонимный функция простенький задачка чем отличаться два фрагмент код ниже public class anonymousclass { public runnable getrunnable { return new runnable { @override public void run { systemoutprintln"i am a runnable" } } } public static void mainstring[] args { new anonymousclassgetrunnablerun } } и два фрагмент public class lambda { public runnable getrunnable { return  -> systemoutprintln"i am a runnable" } public static void mainstring[] args { new lambdagetrunnablerun } } если мочь сходу ответить — решать сам хотеть ли читать далёкий декомпилировать смотреть байт код для оба вариант подробный декомпиляция с флажок -verbose — под спойлер с анонимный класс compiled from "anonymousclassjava" public class anonymousclass { public anonymousclass code 0 aload0 1 invokespecial #1 // method java/lang/object"<init>"v 4 return public javalangrunnable getrunnable code 0 new #2 // class anonymousclass$1 3 dup 4 aload0 5 invokespecial #3 // method anonymousclass$1"<init>"lanonymousclassv 8 areturn public static void mainjavalangstring[] code 0 new #4 // class anonymousclass 3 dup 4 invokespecial #5 // method "<init>"v 7 invokevirtual #6 // method getrunnableljava/lang/runnable 10 invokeinterface #7 1 // interfacemethod java/lang/runnablerunv 15 return } runnableanonymousclassexperimentclass подробный декомпиляцияclassfile /e//src/main/java/anonymousclassclass last modified 17102016 size 518 bytes md5 checksum cf61f38da50d7062537edefea71995dc compiled from "anonymousclassjava" public class anonymousclass minor version 0 major version 52 flags accpublic accsuper constant pool #1 = methodref #8#20 // java/lang/object"<init>"v #2 = class #21 // anonymousclass$1 #3 = methodref #2#22 // anonymousclass$1"<init>"lanonymousclassv #4 = class #23 // anonymousclass #5 = methodref #4#20 // anonymousclass"<init>"v #6 = methodref #4#24 // anonymousclassgetrunnableljava/lang/runnable #7 = interfacemethodref #25#26 // java/lang/runnablerunv #8 = class #27 // java/lang/object #9 = utf8 innerclasses #10 = utf8 <init> #11 = utf8 v #12 = utf8 code #13 = utf8 linenumbertable #14 = utf8 getrunnable #15 = utf8 ljava/lang/runnable #16 = utf8 main #17 = utf8 [ljava/lang/stringv #18 = utf8 sourcefile #19 = utf8 anonymousclassjava #20 = nameandtype #10#11 // "<init>"v #21 = utf8 anonymousclass$1 #22 = nameandtype #10#28 // "<init>"lanonymousclassv #23 = utf8 anonymousclass #24 = nameandtype #14#15 // getrunnableljava/lang/runnable #25 = class #29 // java/lang/runnable #26 = nameandtype #30#11 // runv #27 = utf8 java/lang/object #28 = utf8 lanonymousclassv #29 = utf8 java/lang/runnable #30 = utf8 run { public anonymousclass descriptor v flags accpublic code stack=1 locals=1 argssize=1 0 aload0 1 invokespecial #1 // method java/lang/object"<init>"v 4 return linenumbertable line 1 0 public javalangrunnable getrunnable descriptor ljava/lang/runnable flags accpublic code stack=3 locals=1 argssize=1 0 new #2 // class anonymousclass$1 3 dup 4 aload0 5 invokespecial #3 // method anonymousclass$1"<init>"lanonymousclassv 8 areturn linenumbertable line 3 0 public static void mainjavalangstring[] descriptor [ljava/lang/stringv flags accpublic accstatic code stack=2 locals=1 argssize=1 0 new #4 // class anonymousclass 3 dup 4 invokespecial #5 // method "<init>"v 7 invokevirtual #6 // method getrunnableljava/lang/runnable 10 invokeinterface #7 1 // interfacemethod java/lang/runnablerunv 15 return linenumbertable line 12 0 line 13 15 } sourcefile "anonymousclassjava" innerclasses #2 //class anonymousclass$1 с лямбда compiled from "lambdajava" public class lambda { public lambda code 0 aload0 1 invokespecial #1 // method java/lang/object"<init>"v 4 return public javalangrunnable getrunnable code 0 invokedynamic #2 0 // invokedynamic #0runljava/lang/runnable 5 areturn public static void mainjavalangstring[] code 0 new #3 // class lambda 3 dup 4 invokespecial #4 // method "<init>"v 7 invokevirtual #5 // method getrunnableljava/lang/runnable 10 invokeinterface #6 1 // interfacemethod java/lang/runnablerunv 15 return } lambdaclass подробный декомпиляцияclassfile /e//src/main/java/lambdaclass last modified 17102016 size 1095 bytes md5 checksum f09061410dfbe358c50880576557b64e compiled from "lambdajava" public class lambda minor version 0 major version 52 flags accpublic accsuper constant pool #1 = methodref #10#22 // java/lang/object"<init>"v #2 = invokedynamic #0#27 // #0runljava/lang/runnable #3 = class #28 // lambda #4 = methodref #3#22 // lambda"<init>"v #5 = methodref #3#29 // lambdagetrunnableljava/lang/runnable #6 = interfacemethodref #30#31 // java/lang/runnablerunv #7 = fieldref #32#33 // java/lang/systemoutljava/io/printstream #8 = string #34 // i am a runnable #9 = methodref #35#36 // java/io/printstreamprintlnljava/lang/stringv #10 = class #37 // java/lang/object #11 = utf8 <init> #12 = utf8 v #13 = utf8 code #14 = utf8 linenumbertable #15 = utf8 getrunnable #16 = utf8 ljava/lang/runnable #17 = utf8 main #18 = utf8 [ljava/lang/stringv #19 = utf8 lambda$getrunnable$0 #20 = utf8 sourcefile #21 = utf8 lambdajava #22 = nameandtype #11#12 // "<init>"v #23 = utf8 bootstrapmethods #24 = methodhandle #6#38 // invokestatic java/lang/invoke/lambdametafactorymetafactoryljava/lang/invoke/methodhandles$lookupljava/lang/stringljava/lang/invoke/methodtypeljava/lang/invoke/methodtypeljava/lang/invoke/methodhandleljava/lang/invoke/methodtypeljava/lang/invoke/callsite #25 = methodtype #12 // v #26 = methodhandle #6#39 // invokestatic lambdalambda$getrunnable$0v #27 = nameandtype #40#16 // runljava/lang/runnable #28 = utf8 lambda #29 = nameandtype #15#16 // getrunnableljava/lang/runnable #30 = class #41 // java/lang/runnable #31 = nameandtype #40#12 // runv #32 = class #42 // java/lang/system #33 = nameandtype #43#44 // outljava/io/printstream #34 = utf8 i am a runnable #35 = class #45 // java/io/printstream #36 = nameandtype #46#47 // printlnljava/lang/stringv #37 = utf8 java/lang/object #38 = methodref #48#49 // java/lang/invoke/lambdametafactorymetafactoryljava/lang/invoke/methodhandles$lookupljava/lang/stringljava/lang/invoke/methodtypeljava/lang/invoke/methodtypeljava/lang/invoke/methodhandleljava/lang/invoke/methodtypeljava/lang/invoke/callsite #39 = methodref #3#50 // lambdalambda$getrunnable$0v #40 = utf8 run #41 = utf8 java/lang/runnable #42 = utf8 java/lang/system #43 = utf8 out #44 = utf8 ljava/io/printstream #45 = utf8 java/io/printstream #46 = utf8 println #47 = utf8 ljava/lang/stringv #48 = class #51 // java/lang/invoke/lambdametafactory #49 = nameandtype #52#56 // metafactoryljava/lang/invoke/methodhandles$lookupljava/lang/stringljava/lang/invoke/methodtypeljava/lang/invoke/methodtypeljava/lang/invoke/methodhandleljava/lang/invoke/methodtypeljava/lang/invoke/callsite #50 = nameandtype #19#12 // lambda$getrunnable$0v #51 = utf8 java/lang/invoke/lambdametafactory #52 = utf8 metafactory #53 = class #58 // java/lang/invoke/methodhandles$lookup #54 = utf8 lookup #55 = utf8 innerclasses #56 = utf8 ljava/lang/invoke/methodhandles$lookupljava/lang/stringljava/lang/invoke/methodtypeljava/lang/invoke/methodtypeljava/lang/invoke/methodhandleljava/lang/invoke/methodtypeljava/lang/invoke/callsite #57 = class #59 // java/lang/invoke/methodhandles #58 = utf8 java/lang/invoke/methodhandles$lookup #59 = utf8 java/lang/invoke/methodhandles { public lambda descriptor v flags accpublic code stack=1 locals=1 argssize=1 0 aload0 1 invokespecial #1 // method java/lang/object"<init>"v 4 return linenumbertable line 1 0 public javalangrunnable getrunnable descriptor ljava/lang/runnable flags accpublic code stack=1 locals=1 argssize=1 0 invokedynamic #2 0 // invokedynamic #0runljava/lang/runnable 5 areturn linenumbertable line 3 0 public static void mainjavalangstring[] descriptor [ljava/lang/stringv flags accpublic accstatic code stack=2 locals=1 argssize=1 0 new #3 // class lambda 3 dup 4 invokespecial #4 // method "<init>"v 7 invokevirtual #5 // method getrunnableljava/lang/runnable 10 invokeinterface #6 1 // interfacemethod java/lang/runnablerunv 15 return linenumbertable line 7 0 line 8 15 } sourcefile "lambdajava" innerclasses public static final #54= #53 of #57 //lookup=class java/lang/invoke/methodhandles$lookup of class java/lang/invoke/methodhandles bootstrapmethods 0 #24 invokestatic java/lang/invoke/lambdametafactorymetafactoryljava/lang/invoke/methodhandles$lookupljava/lang/stringljava/lang/invoke/methodtypeljava/lang/invoke/methodtypeljava/lang/invoke/methodhandleljava/lang/invoke/methodtypeljava/lang/invoke/callsite method arguments #25 v #26 invokestatic lambdalambda$getrunnable$0v #25 v анализировать что-нибудь броситься в глаз та-та-та-дам… анонимный класс 5 invokespecial #3 // method anonymousclass$1"<init>"lanonymousclassv лямбда 0 invokedynamic #2 0 // invokedynamic #0runljava/lang/runnable кажется анонимный класс захватить при создание ссылка на порождать он экземпляр anonymousclass$1"<init>"lanonymousclassv и быть держать её пока всесильный сборщик мусора™ не пометить он как недостижимый и не освободить от это бремя хотя никак этот ссылка внутри не использоваться но вот такой он анонимный жадина а если серьёзно то здесь потенциальный утечка память если вы отдавать экземпляр анонимный класс в внешний мир с лямбда это произойти только в тот случай если вы явно или неявно ссылаться на this в тело анонимный функция в противный случай как в это пример лямбда ссылка на вызывающий её экземпляр не держать делать свой рука предлагать весь читатель провести эксперимент и посмотреть что быть в каждый из случай если к строка добавить вызов tostring у порождать экземляр как в нога-то попасть обещать рассказать самый простой способ напороться на потенциальный утечка память — это использовать внутри лямбда нестатический метод внешний класс если вы в реальность неинтересно он внутренний состояние public class lambdacallsnonstatic { public runnable getrunnable { return  -> { nonstaticmethod } } public void nonstaticmethod { systemoutprintln"i am a runnable" } public static void mainstring[] args { new lambdacallsnonstaticgetrunnablerun } } лямбда получить ссылка на экземпляр класс её вызывающий хотя быть создать один раз но о это ниже 1 invokedynamic #2 0 // invokedynamic #0runllambdacallsnonstatic декомпиляция lambdacallsnonstaticclasscompiled from "lambdacallsnonstaticjava" public class lambdacallsnonstatic { public lambdacallsnonstatic code 0 aload0 1 invokespecial #1 // method java/lang/object"<init>"v 4 return public javalangrunnable getrunnable code 0 aload0 1 invokedynamic #2 0 // invokedynamic #0runllambdacallsnonstaticljava/lang/runnable 6 areturn public void nonstaticmethod code 0 getstatic #3 // field java/lang/systemoutljava/io/printstream 3 ldc #4 // string i am a runnable 5 invokevirtual #5 // method java/io/printstreamprintlnljava/lang/stringv 8 return public static void mainjavalangstring[] code 0 new #6 // class lambdacallsnonstatic 3 dup 4 invokespecial #7 // method "<init>"v 7 invokevirtual #8 // method getrunnableljava/lang/runnable 10 invokeinterface #9 1 // interfacemethod java/lang/runnablerunv 15 return } решение объявить использовать метод статический или вынести он в отдельный утильный класс и весь нет есть ещё один замечательный плюшка у лямбда по сравнение с анонимный класс если вы когда-нибудь работать в застенок кроваво-энтерпрайзный контора и не дать боже́ писать такой collectionssortlist new comparator<integer> { @override public int compareinteger o1 integer o2 { return -integercompareo1 o2 } } то подходить к вы о мудрый тимлида и говорить не экономно ты фёдор <имя разработчика> ресурс корпоративный расходовать давать мы это зарефакторить по-взрослому ведь новый экземпляр компаратор быть создаваться каждый раз при работа это фрагмент код в результат получаться такой портянка public class corporatecomparators { public static comparator<integer> integerreversecomparator { return integerreversecomparatorinstance } private enum integerreversecomparator implements comparator<integer> { instance @override public int compareinteger o1 integer o2 { return -integercompareo1 o2 } } }  collectionssortlist corporatecomparatorsintegerreversecomparator удобный же стать весь в свой файлик теперь лежать и переиспользовать можно с последний согласиться но удобный стать разве что если у вы ddr4 вместо серый вещество в голов читабельность такой код не просто падать а лететь в тартарары с сверхзвуковой с лямбда можно держать логика близкий к место непосредственный использование и не платить за это сверху collectionssortlist i1 i2 -> -integercomparei1 i2 анонимный функция не захватывать значение из внешний контекст быть лёгкий и создаваться один раз хотя спецификация не обязывать конкретный реализация виртуальный машина к такой поведение 15274 run-time evaluation of lambda expressions но в java hotspot vm наблюдаться именно это версия ява эксперимент проводиться на java version "18092" javatm se runtime environment build 18092-b14 java hotspottm 64-bit server vm build 2592-b14 mixed mode javac 18092 javap 18092 в заключение статья не претендовать на сверхстрогость академичность и полнота но я кажется такой я самонадеянный сейчас получить в комментарий по первое число в достаточный мера раскрывать два киллер-фич заставлять ещё большой проникнуться лямбда критика в комментарий конструктивный и не очень категорически приветствоваться 
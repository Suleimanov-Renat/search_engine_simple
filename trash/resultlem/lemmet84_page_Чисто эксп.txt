чисто экспериментальный приём портирование stream api из java 8 на java 6 год назад я рассказывать о тот как с помощь maven и retrolambda портировать свой приложение использовать языковой средство java 8 а также сопутствующий не совсем java 8” библиотека на android к сожаление новое java 8 api использовать не удаться ввиду банальный они отсутствие на более старый целевой платформа но поскольку сам идея не покидать я продолжительный время я стать интересный можно ли портировать например stream api на более старый платформа и не ограничиваться сам только возможность язык вроде лямбда-выражение в конечный итог такой идея подразумевать следующий как и в предыдущий случай нужно с помощь доступный инструмент в частность старый-добрый retrolambda переписать байткод stream api такой образ чтобы код использовать этот api мочь работать и на старое версия java почему именно java 6 честно говорить с этот версия java я проработать дольшея время java 5 я не застать а java 7 для я скорее как пролететь мимо также сразу повториться что весь инструкция привести в этот статья носить чисто экспериментальный характер и вряд ли — практический в один очередь из-за тот что прийтись пользоваться boot-classloader- что не всегда приемлить или возможно вообще а во-вторых сам реализация идея откровенно сыроватый и в она присутствовать множество неудобство и не совсем очевидный подводный камень инструмент итак набор необходимый инструмент представить следующий основнынить пакет openjdk 18045 apache ant 197 openjdk/jre 16040 и сопутствующий инструмент вовлечь в эксперимент retrolambda 230 ant shade task 01-snapshot помимо более старое версия openjdk пример портирование быть осуществляться с помощь ant а не maven я хоть и приверженец convention over configuration и уже год пять-шесть не пользоваться ant для решение именно этот задача я ant кажется куда более удобный инструмент в один очередь из-за простота а также из-за тонкий настройка что по правда говорить труднодостижимый в maven скорость работа и кросс-платформенность shell-скрипт быть бы ещё короче но я также часто использовать windows без cygwin и похожех примочка в качество proof of concept быть использоваться простой пример на stream api package test import javautilstreamstream import static javalangsystemout public final class entrypoint { private entrypoint { } public static void mainfinal string args { runas"stream"  -> streamofargsmapstringtouppercaseforeachentrypointdump } private static void runasfinal string name final runnable runnable { outprintln"pre " + name runnablerun outprintln"post " + name } private static void dumpfinal object o { outprintln">" + o } } несколько слово о тот как быть проходить эксперимент ant-овский buildxml разделить на множество шаг или этап каждый из который в процесс портирование отвести свой собственный директория это по крайний мера я здорово упрощать процесс поиск решение и отладка прослеживать изменение от шаг к шаг процесс портирование шаг 0 init как обычно один дело в ant почти всегда идти создание целевой директория <target name="init" description="initializes the workspace"> <mkdir dir="${targetdir}"/> </target> шаг 1 grab крайне важный состовлять экперимент являться минимальный точный список весь класс от который зависеть тестовый пример к сожаление я не известно можно ли это сделать простой и я потратить довольно много время чтобы метод многократный повторный запуск зарегистрировать весь нужный класс из jre 8 с другой сторона есть некоторый смысл попробовать стянуть весь пакет javautilstream и потом потратить ещё большой время на подтягивание другой зависимость и наверняка обработка инструмент тип proguard но я решить пойти на другой простой ухищрение вложить и внутренний класс я просто копировать с помощь маска $** это очень существенно экономить время и список некоторый класс существовать и в более старое версия java скорее всего нужно быть скопировать также поскольку в java 8 они обрести новое возможность это касаться например новое метод по-умолчание mapputifabsentobjectobject который не задействовать в тест но требоваться для он корректный работа <target name="01-grab" depends="init" description="step 01 grab some jre 8 classes"> <unzip src="${javahome}/lib/rtjar" dest="${step01targetdir}"> <patternset> <include name="java/lang/autocloseableclass"/> <include name="java/lang/iterableclass"/> <include name="java/util/arraysclass"/> <include name="java/util/abstractmapclass"/> <include name="java/util/enummapclass"/> <include name="java/util/enummap$**class"/> <include name="java/util/function/consumerclass"/> <include name="java/util/function/functionclass"/> <include name="java/util/function/supplierclass"/> <include name="java/util/iteratorclass"/> <include name="java/util/mapclass"/> <include name="java/util/objectsclass"/> <include name="java/util/spliteratorclass"/> <include name="java/util/spliterator$**class"/> <include name="java/util/spliteratorsclass"/> <include name="java/util/spliterators$**class"/> <include name="java/util/stream/abstractpipelineclass"/> <include name="java/util/stream/basestreamclass"/> <include name="java/util/stream/foreachopsclass"/> <include name="java/util/stream/foreachops$**class"/> <include name="java/util/stream/pipelinehelperclass"/> <include name="java/util/stream/referencepipelineclass"/> <include name="java/util/stream/referencepipeline$**class"/> <include name="java/util/stream/sinkclass"/> <include name="java/util/stream/sink$**class"/> <include name="java/util/stream/streamclass"/> <include name="java/util/stream/streamshapeclass"/> <include name="java/util/stream/streamopflagclass"/> <include name="java/util/stream/streamopflag$**class"/> <include name="java/util/stream/streamsupportclass"/> <include name="java/util/stream/terminalsinkclass"/> <include name="java/util/stream/terminalopclass"/> </patternset> </unzip> </target> действительно весьма впечатляющий список класс нужный только для простой как сперва кажется map и foreach шаг 2 compile скучный компиляция тестовый код простой некуда <target name="02-compile" depends="01-grab" description="step 02 compiles the source code dependent on the grabbed jre 8 classes"> <mkdir dir="${step02targetdir}"/> <javac srcdir="${srcdir}" destdir="${step02targetdir}" source="18" target="18"/> </target> шаг 3 merge этот шаг мочь показаться немного странный поскольку он просто сливать воедино результат копирование класс из java 8 rtjar и тестовый пример на самый дело это нужно для несколько следующий шаг который перемещать java-пакет для они правильный последующий обработка <target name="03-merge" depends="02-compile" description="step 03 merge into a single jar in order to relocate java 8 packages properly"> <zip basedir="${step01targetdir}" destfile="${step03targetfile}"/> <zip basedir="${step02targetdir}" destfile="${step03targetfile}" update="true"/> </target> шаг 4 shade для maven существовать один интересный плагин который уметь перемещать пакет изменять байткод class-файл напрямую я не знать мочь я плохо искать в интернет существовать ли он ant-овский аналог но я не остаться ничто другой кроме как самый написать небольшой расширение для ant являться простой адаптер для maven-плагин с единственный возможность только перемещение пакет другой возможность maven-shade-plugin отсутствовать на это этап для тот чтобы далёкий можно быть воспользоваться retrolambda нужно переименовать весь пакет java* в что-либо тип ~java* да-да именно тильда” — ведь почему бы и нет дело в тот что retrolambda полагаться на работа класс javalanginvokemethodhandles который запрещать использование класс с пакет java* и sun* как это есть в oracle jdk/jre поэтому временной перемещение пакет просто яваться способ ослепить” javalanginvokemethodhandles как и в шаг №1 я прийтись указать полный список класс по-отдельность через include-список если это не сделать и опустить список полностью shade в класс-файл также переместить и тот класс который не планироваться подвергать обработка в такой случай например javalangstring стать ~javalangstring по крайний мера это чётко видно из декомпилировать с помощь javap класс что сломать retrolambda который просто молча перестать преобразовавывать код и не сгенерировать ниодный класс для лямбд/invokedynamic прописывать весь класс в exclude-список считать более нецелесообразный потому что они просто сложный искать и прийтись бы ковыряться в class-файл с помощь javap в поиск лишний тильда <target name="04-shade" depends="03-merge" description="step 04 rename java* to ~java* in order to let retrolambda work since methodhandles require non-java packages"> <shade jar="${step03targetfile}" uberjar="${step04targetfile}"> <relocation pattern="java" shadedpattern="~java"> <include value="javalangautocloseable"/> <include value="javalangiterable"/> <include value="javautilarrays"/> <include value="javautilabstractmap"/> <include value="javautilenummap"/> <include value="javautilenummap$**"/> <include value="javautilfunctionconsumer"/> <include value="javautilfunctionfunction"/> <include value="javautilfunctionsupplier"/> <include value="javautiliterator"/> <include value="javautilmap"/> <include value="javautilobjects"/> <include value="javautilspliterator"/> <include value="javautilspliterator$**"/> <include value="javautilspliterators"/> <include value="javautilspliterators$**"/> <include value="javautilstreamabstractpipeline"/> <include value="javautilstreambasestream"/> <include value="javautilstreamforeachops"/> <include value="javautilstreamforeachops$**"/> <include value="javautilstreampipelinehelper"/> <include value="javautilstreamreferencepipeline"/> <include value="javautilstreamreferencepipeline$**"/> <include value="javautilstreamsink"/> <include value="javautilstreamsink$**"/> <include value="javautilstreamstream"/> <include value="javautilstreamstreamshape"/> <include value="javautilstreamstreamopflag"/> <include value="javautilstreamstreamopflag$**"/> <include value="javautilstreamstreamsupport"/> <include value="javautilstreamterminalsink"/> <include value="javautilstreamterminalop"/> </relocation> </shade> </target> небольшой отступление теоретически дублирование список в ant можно решить с помощь элемент поддерживать refid но это не получиться по несколько причина <relocation> не поддерживать refid в один очередь потому что аналог это аттрибут просто отсутствовать в maven-реализация и я бы хотеть чтобы два реализация быть похожий друг на друг один в один по крайний мера сейчас анатомически <relocation> и <patternset> различаться в первое применяться <include name=”” а в второе — <include value=””> здесь подозревать мой косяк и я не слишком следовать общепринятый соглашение simplerelocator использовать плагин для maven по видимый не поддерживать путь к класс-файл поэтому в второе случай название класс нужно прописывать формат где разделитель являться точка а не косой черта ещё один несовместимость конечно можно написать свой реализация правило перемещение но у я наверняка если бы это не противоречить никакой правило maven-плагин возникнуть бы соблазн предложить такой расширение разработчик maven-shade-plugin но иметь даже минимальный опыт мочь сказать что даже в случай положительный ответ на такой запрос это занять бы куча время просто экономия время так что весь этот недостаток решаться но явно не в рамка этот статья шаг 5 unzip следующий шаг распаковывать jar-файл с переместить пакет поскольку retrolambda мочь работать только с директория <target name="05-unzip" depends="04-shade" description="step 05 unpacking shaded jar in order to let retrolamda work"> <unzip src="${step04targetfile}" dest="${step05targetdir}"/> </target> шаг 6 retrolambda сам сердце эксперимент преобразование байткод версия 52 java 8 в версия 50 java 6 причём из-за использованый выше ухищрение retrolambda или стать быть jdk 8 спокойно и уже без лишний вопрос проинструментировать класс также обязательно нужно включить поддержка метод по-умолчание потому что множество новое функионал в java 8 строиться именно на они поскольку jre 7 и ниже не уметь работать с такой метод retrolambda просто копировать реализация такой метод для каждый класс в который он не быть переопределить это кстати говорить означать что применять retrolambda нужно только для связка конечный приложение и он библиотеки” иначе скорее всего можно столкнуться с проблема когда реализация default-метод попросту быть отсутствовать <target name="06-retrolambda" depends="05-unzip" description="step 06 perform downgrade from java 8 to java 6 bytecode"> <java jar="${retrolambdajar}" fork="true" failonerror="true"> <sysproperty key="retrolambdabytecodeversion" value="50"/> <sysproperty key="retrolambdaclasspath" value="${step05targetdir}"/> <sysproperty key="retrolambdadefaultmethods" value="true"/> <sysproperty key="retrolambdainputdir" value="${step05targetdir}"/> <sysproperty key="retrolambdaoutputdir" value="${step06targetdir}"/> </java> </target> шаг 7 zip собирать проинструментировать версия обратно в один файл чтобы запустить shade-плагин в обратный направление <target name="07-zip" depends="06-retrolambda" description="step 07 pack the downgraded classes back before unshading"> <zip basedir="${step06targetdir}" destfile="${step07targetfile}"/> </target> шаг 8 unshade к счастие для работа shade-плагин с перемещение в обратный направление достаточно только два параметр по завершение это этап пакет в приложение быть выровнять обратно и весь что быть ~java* снова стать java* <target name="08-unshade" depends="07-zip" description="step 08 relocate the ~java package back to the java package"> <shade jar="${step07targetfile}" uberjar="${step08targetfile}"> <relocation pattern="~java" shadedpattern="java"/> </shade> </target> шаг 9 unpack в это шаг класс просто распаковываться для последующий сборка два отдельный jar-файл снова ничто интересный <target name="09-unpack" depends="08-unshade" description="step 09 unpack the unshaded jar in order to create two separate jar files"> <unzip src="${step08targetfile}" dest="${step09targetdir}"/> </target> шаг 10 и 11 pack собирать весь класс воедино но отдельно — новый рантайм” и сам тестовый приложение и в который раз — весьма тривиальный и неинтересный шаг <target name="10-pack" depends="09-unpack" description="step 10 pack the downgraded java 8 runtime classes"> <zip basedir="${step09targetdir}" destfile="${step10targetfile}"> <include name="java/**"/> </zip> </target> <target name="11-pack" depends="09-unpack" description="step 11 pack the downgraded application classes"> <zip basedir="${step09targetdir}" destfile="${step11targetfile}"> <include name="test/**"/> </zip> </target> тестирование результат вот и весь в целевой директория лежать крошечный порт небольшой аспект из реальный stream api и он мочь запуститься на java 6 для это создать ещё один правило для ant-а <target name="run-as-java-6" description="runs the target artifact in java 6"> <fail unless="envjdk6home" message="jdk6home not set"/> <java jvm="${envjdk6home}/bin/java" classpath="${step11targetfile}" classname="${mainclass}" fork="true" failonerror="true"> <jvmarg value="-xbootclasspath/p${step10targetfile}"/> <arg value="foo"/> <arg value="bar"/> <arg value="baz"/> </java> </target> и вот тут нужно обратить просто особый внимание на использование не совсем стандартный -xbootclasspath/p вкратце он быть заключаться в следующий он позволять jvm указать откуда нужно загружать базовый класс в один очередь при это остальной класс из оригинальный rtjar быть лениво загружаться из $javahome/jre/lib/rtjar по мера необходимость убедиться в это можно использовать ключ -verboseclass при запуск jvm запуск самый пример также требовать переменный окружение jdk6home указывать на jdk 6 или jre 6 теперь при вызов run-as-java-6 результат успешный портирование быть вывести на стандартный вывод pre stream >foo >bar >baz post stream работать да заключение привыкнуть в написание код на java 8 хотеться чтобы этот код работать и на более старое версия java особенно если в наличие есть довольно старый и увесистый кодовый база и если в интернет часто можно увидеть вопрос о тот существовать ли вообще возможность работать именно с stream api на более старое версия java всегда сказать что нет ну почти что нет и быть правый конечно предлагаться альтернативный библиотека с схожий функционал работать на старое jre я лично большой всего импонировать google guava и я часто использовать её когда java 8 недостаточно экспериментальный хак есть экспериментальный хак и я сомневаться что далёкий демонстрация есть большой смысл идти далёкий но в цель исследование и дух экcпериментаторство почему бы и нет ознакомиться с эксперимент близкий можно на github нерешить и нерешаемый вопрос помимо проблема с refid в ant открытый для я лично оставаться несколько вопрос работать ли этот пример на другой реализация jvmработать на oracle jvm но лицензия oracle запрещать развёртывание приложение заменять часть rtjar с использование -xbootclasspath можно ли сформировать список класс зависимость автоматически не прибегать к ручной переборумна лично неизвестный автоматический метод такой анализ можно попробовать стянуть весь пакет javautilstream* целиком но и проблема думать быть большой есть ли возможность запустить этот пример на dalvik vmиметься в вид android я пробовать пропускать результат через dx и запускать dalvik vm с -xbootclasspath прямо на реальный устройство но dalvik упорно игнорировать такой просьба подозревать причина это являться то что приложение для dalvik vm форкаяться от zygote который очевидно ничто не подозревать о такой намерение большой почитать о тот почему это сделать нельзя и чем это чреватый можно почитать на stackoverflow и если бы и удаться запустить dalvikvm с -xbootclasspath я подозревать потребоваться бы некий лончер и для самый приложение который бы этот boot classpath и подменять такой сценарий по весь видимость не предоставляться возможный а как с gwt это совершенно другой история и другой подход буквально на день состояться долгожданный релиз gwt 280 к сожаление версия 270 ещё два год назад в который полноценно реализовать лямбда и прочий возможность для исходник написать на java 8 впрочем это весь быть и до релиз в snapshot-версия возиться с байткод в gwt нельзя потому как gwt работать только с исходный код для портирование stream api на клиентский сторона прийтись я думать просто собрать часть исходник из jdk 8 предварительно пропустить они через некий препроцессор который преобразовать исходник в удобоваримый для gwt вид пример портирование rxjava 